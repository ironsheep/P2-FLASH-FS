'' =================================================================================================
''
''   File....... flash_fs.spin2
''   Purpose.... This object is the full flash file system driver for the P2
''               it manages all but the first 512KB of the flash chip (where the boot image is stored)
''               it provides a standard (ANSI C like) file system interface to the flash chip
''   Author..... Chip Gracey
''   Conrtributions..... Jon McPhalen, Stephen M Moraco
''               -- see below for terms of use
''   E-mail.....stephen@ironsheep.biz
''   Started.... AUG 2023
''   Updated.... 19 SEP 2023
''
'' =================================================================================================
'' v1.2.0 - initial release of flash_fs with full API
'' v1.2.1 - revised seek() method parameters - can now seek relative to current position in file
'' v1.3.0 - update for flexspin compatibility, seek() returns file position, write() returns bytes written
'' v1.3.1 - more update for flexspin compatibility, adjusted seek(), read() and write() add file_size_for_handle()
'' v1.4.0 - Adjustments allowing multi-cog support
'' v2.0.0 - Add read/modify/write and non-destructive mount check
'' -------------------------------------------------------------------------------------------------


CON { version }

  LIB_VERSION = 200                                             ' 2.0.0

  #true,  ON, OFF
  #false, NO, YES


CON { fixed io pins }

  PGM_RX   = 63  { I }                                          ' programming / debug
  PGM_TX   = 62  { O }

  SF_CS    = 61  { O }                                          ' flash chip select
  SF_SCLK  = 60  { O }                                          ' flash clock
  SF_MOSI  = 59  { O }                                          ' flash data in
  SF_MISO  = 58  { I }                                          ' flash data out

  LED2     = 57  { O }                                          ' Eval and Edge LEDs
  LED1     = 56  { O }


CON { PUBLIC driver constants }

  ' Return Codes

  OKAY             = 0                                          ' No error / Success
  SUCCESS          = OKAY                                       ' No error / Success

' SK_* ENUM values (parameter to seek() method)
' SK_FILE_START: seek using position from start of file
' SK_CURRENT_POSN: seek where position is relative to current seek location in file
  #0, SK_Unknown, SK_FILE_START, SK_CURRENT_POSN

  E_BAD_HANDLE     = -1                                         ' Error: Handle in invalid
  E_NO_HANDLE      = -2                                         ' Error: Out of available handles
  E_FILE_NOT_FOUND = -3                                         ' Error: File not present
  E_DRIVE_FULL     = -4                                         ' Error: Out of space on flash chip
  E_FILE_WRITING   = -5                                         ' Error: File is open for writing
  E_FILE_READING   = -6                                         ' Error: File is open for reading
  E_FILE_OPEN      = -7                                         ' Error: File is open
  E_FILE_EXISTS    = -8                                         ' Error: the File exists
  E_END_OF_FILE    = -9                                         ' Error: no more data available, at end of file
  E_FILE_MODE      = -10                                        ' Error: file not opened in desired mode
  E_FILE_SEEK      = -11                                        ' Error: Attempted seek past either end of file
  E_BAD_BLOCKS_REMOVED = -12                                    ' Error: Block bit failure detetected, bad blocks removed
  E_NO_LOCK_AVAIL  = -13                                        ' Error: Unable to obtain a LOCK for driver use
  E_TRUNCATED_STRING = -14                                      ' Error: Buffer full, before reaching string terminator
  E_INCOMPLETE_STRING = -15                                     ' Error: End of file reached before string terminator
  E_SHORT_TRANSER = -16                                         ' Error: Too few bytes read or written
  E_NOT_MOUNTED = -17                                           ' Error: Filesystem NOT mounted (not yet accessible)
  E_BAD_FILE_LENGTH = -18                                       ' Error: File length given is negative or zero
  E_BAD_SEEK_ARG = -19                                          ' Error: Invalid seek argument

  BYTES_IN_HEAD_BLOCK = 3956
  WORDS_IN_HEAD_BLOCK = BYTES_IN_HEAD_BLOCK/2
  LONGS_IN_HEAD_BLOCK = BYTES_IN_HEAD_BLOCK/4

  BYTES_IN_BODY_BLOCK = 4088
  WORD_IN_BODY_BLOCK = BYTES_IN_BODY_BLOCK/2
  LONGS_IN_BODY_BLOCK = BYTES_IN_BODY_BLOCK/4

CON { PRIVATE driver constants }

  ' optionally customizable

  FIRST_BLOCK      = $080                                       ' Physical address of first block in this flash file system
  LAST_BLOCK       = $FFF                                       ' Physical address of last block in this flash file system
  MAX_FILES_OPEN   = 2                                          ' Maximum number of files that can be open at one time


  ' NOT customizable! below here

  BLOCKS           = LAST_BLOCK - FIRST_BLOCK+1                 ' Number of blocks in flash allocated to this file system

  BLOCK_SIZE       = $1000                                      ' Size in bytes: 4KB block (4096 bytes)
  BLOCK_SIZE_EXP   = encod BLOCK_SIZE

  ADDR_HEAD_FN_CRC  = $004                                      ' Offset in head block of filename CRC
  ADDR_HEAD_SONAME  = $008                                      ' Offset in head block of first filename byte
  ADDR_HEAD_DATA    = $088                                      ' Offset in head block of first data byte
  ADDR_BODY_DATA    = $004                                      ' Offset in body block of first data byte

  FILENAME_SIZE    = $088-$008                                  ' File name string length: 127 characters plus 0 terminator
  FILENAME_SIZE_EXP   = encod FILENAME_SIZE

  ID_TO_BLOCKS_SZ  = (BLOCKS * 12 + 15) / 16                    ' 12-bit fields in WORD array (rounded to full WORD)
  FLAGS_SIZE       = (BLOCKS * 1 + 7) / 8                       ' 1-bit fields in BYTE array (rounded to full BYTE)
  STATES_SIZE      = (BLOCKS * 2 + 7) / 8                       ' 2-bit fields in BYTE array (rounded to full BYTE)


  B_FREE           = %00                                        ' Block is not in use (free)
  B_TEMP           = %01                                        ' Block is being put to use
  B_HEAD           = %10                                        ' Block is head of a file (contains filename)
  B_BODY           = %11                                        ' BLock is body of file (any blocks after head)

  H_READ           = %0001                                       ' Existing file is being read
  H_WRITE          = %0010                                       ' New file is being written
  H_FORK           = %0100                                       ' Existing file is being written and forked at some block (rewrite/append)
  H_MODIFY         = %1000                                       ' Existing file is being modified

  H_APPEND = H_WRITE | H_FORK                                    ' New file is being written or existing is being rewritten
  H_OVERWRITE = H_WRITE | H_MODIFY                               ' New file is being written or existing is being rewritten

  H_READ_WRITE     = H_READ | H_WRITE                           ' (Any) File is open for reading and/or writing
  H_READ_ONLY      = H_READ                                     ' Existing File is open for reading only

  NOT_ENABLED      = -1                                         ' this feature is NOT enabled (e.g., seeking)
  NOT_VALID        = -30                                        ' this value is not initialized

DAT { pre-initialized: driver state tracking tables }

' physically: 3/4 of a word (12 bits) for every valid block ID, 12 bits per ID
' logically: a "BLOCKS"-sized array of 12-bit variables, 1 for ea. block ID - indexed by block ID
' contains block_address in ea. 12 bit field
IDToBlocks    WORD      0[ID_TO_BLOCKS_SZ]                                      'ID-to-block translation table
IDToBlock     LONG      0                                                       '(field pointer to 12-bit variables)

' physically: 1 byte for every 8 valid block IDs, 1 bit per block ID
' logically: a "BLOCKS"-sized array of single bit variables, 1 for ea. block ID - indexed by block ID
' contains [0,1] in ea. 1 bit field, where 1 means ID is valid
IDValids      BYTE      0[FLAGS_SIZE]                                           'ID-valid flags
IDValid       LONG      0                                                       '(field pointer to 1-bit variables)

' physically: 1 byte for every 4 valid block IDs, 2 bits per block ID
' logically: a "BLOCKS"-sized array of 2-bit variables, 1 for ea. block ID - indexed by block ID
' contains a Block-State value in ea. 2 bit field [B_FREE, B_TEMP, B_HEAD, B_BODY]
BlockStates   BYTE      0[STATES_SIZE]                                          'block states
BlockState    LONG      0                                                       '(field pointer to 2-bit variables)

' handle-related variables and buffers
'   handle is index into each of the arrays below

hStatus         BYTE    0[MAX_FILES_OPEN]                                         'handle: status [H_READ, H_WRITE, H_REPLACE]
hHeadBlockID    WORD    NOT_VALID[MAX_FILES_OPEN]                                 'handle: first blockID of file chain
hChainBlockID   WORD    0[MAX_FILES_OPEN]                                         'handle: first blockID of commit chain
hChainBlockAddr WORD    0[MAX_FILES_OPEN]                                         'handle: first block_address of commit chain
hChainLifeCycle BYTE    0[MAX_FILES_OPEN]                                         'handle: first block lifecycle (cycle value for replacement first block of chain)
hModified       BYTE    0[MAX_FILES_OPEN]                                         'handle: current block is modified
hEndPtr         WORD    0[MAX_FILES_OPEN]                                         'handle: pointer to next byte in block
hWriteCount     LONG    0[MAX_FILES_OPEN]                                         'handle: count of bytes written to file (or appended)
hSeekPtr        LONG    NOT_ENABLED[MAX_FILES_OPEN]                               'handle: seek endptr within file
hSeekFileOffset LONG    0[MAX_FILES_OPEN]                                         'handle: seek offset within entire file
hCircularLength LONG    0[MAX_FILES_OPEN]                                         'handle: circular buffer length in byt
hFilename       BYTE    0[MAX_FILES_OPEN * FILENAME_SIZE]                         'handle: 59+1 byte buffer for filename
hBlockBuff      BYTE    0[MAX_FILES_OPEN * BLOCK_SIZE]                            'handle: 4KB buffer for file data

tmpBlockBuffer  BYTE     0[BLOCK_SIZE]                                            'buffer used for copying blocks

errorCode       LONG    0[8]                                                      'most recent error code
fsLock          LONG    -1                                                        'flash lock semaphore for driver use
fsMounted       LONG    false                                                     ' T/F where T means the filesystem is mounted
fsFreeHndlCt    LONG    MAX_FILES_OPEN
fsCogCts        LONG    $7fff_ffff[8]                                             'cog counts: one for each cog that is attempting to start the filesystem

CON ' --- Public Methods ---

PUB null()

'' This is not an application
''  (invoke format() or mount() to use the flash file system)


PUB version() : result

'' Returns flash file system library version as integer
'' -- e.g., version 120 is 1.2.0 (major, minor, bugfix)

  return LIB_VERSION

{$flexspin
VAR
   long m_sn_hi, m_sn_lo        ' temporary storage for serial number read
}

PUB serial_number() : sn_hi, sn_lo

'' Returns 64-bit unique id of flash chip
''
'' @returns sn_hi - high 32 bits of 64-bit unique id of flash chip (0 when error return)
'' @returns sn_lo - low 32 bits of 64-bit unique id of flash chip (0 when error return)
'' (sets error() to E_NOT_MOUNTED and returns 0,0 if filesystem has not been mounted)

  if fsMounted == false
    LONG[@errorCode][cogid()] := E_NOT_MOUNTED
  else

    repeat while locktry(fsLock) == 0                                           ' lock for exlusive use

    LONG[@errorCode][cogid()] := SUCCESS

    flash_command($4B, 1)
    flash_send($00, 4)
{$flexspin
#ifdef __FLEXSPIN__
    ' flexspin does not like using HUB variables (@) in inline assembly
    ' so do the read into a class member in HUB, then copy to the local
    ' variables in registers
    flash_receive(@m_sn_hi, 8)
    sn_hi := m_sn_hi
    sn_lo := m_sn_lo
#else
}
    flash_receive(@sn_hi, 8)
{$flexspin #endif}

    ' UID values are stored Big Endian
    ' -- swap ends to correct LE reads from flash

    org
                movbyts     sn_hi, #%%0123
                movbyts     sn_lo, #%%0123
    end

    lockrel(fsLock)                                                             ' release the lock, we're done with it

PUB can_mount() : status | block_address, signature, BYTE blockTypeBits, bFoundDupeId, fileCount, badBlockCount

    if fsMounted == true
        return (LONG[@errorCode][cogid()] := SUCCESS)                           ' don't mount if already mounted

    if fsLock == -1                                                             ' don't acquire lock if already have it
        if setup_semaphore() < 0
            return LONG[@errorCode][cogid()]

    'debug("* mntCk: can_mount()?")
    LONG[@errorCode][cogid()] := SUCCESS                                        ' preset to success

    'debug("- have lock, trying...")
    repeat while locktry(fsLock) == 0                                           ' try to get the lock

    'debug("- mounting...")
    bytefill(@hStatus, 0, MAX_FILES_OPEN)                                       'clear handles
    bytefill(@IDValids, 0, Flags_SIZE)                                          'clear ID flags
    bytefill(@BlockStates, 0, States_SIZE)                                      'clear block states to B_FREE

    IDToBlock  := ^@IDToBlocks.[11..0]                                          'set field pointers
    IDValid    := ^@IDValids.[0]
    BlockState := ^@BlockStates.[1..0]

    'debug("mntCk: - fixing power-out leftovers...")
    bFoundDupeId := false
    repeat BLOCKS with block_address                                            'check each block and fix any duplicate IDs
        if(check_block_read_only(block_address))                                '(recovers from incomplete block switchover due to power loss)
          bFoundDupeId := true
          quit  ' abort we have answer

    'debug("mntCk: - locating files...")
    repeat BLOCKS with block_address                                            'trace head blocks and cancel any broken files
        if field[BlockState][block_address] == B_TEMP                           'is this a valid block?
            flash_read_block_addr(block_address, @blockTypeBits, $000, $000)    'yes, read first byte of block
            ifnot blockTypeBits.[1]                                             'is this a head block?
                'debug("mnt: - head block ", uhex_word(block_address))
                ifnot trace_file_set_flags(block_address, true)                 'yes, trace file, set block states to B_HEAD/B_BODY
                    trace_file_set_flags(block_address, false)                  'if error, retrace file, return block states to B_TEMP
                else
                    fileCount++

    'debug("mntCk: - clearing dead blocks...")
    repeat BLOCKS with block_address                                            'cancel sTEMP blocks that didn't become sHEAD/sBODY blocks
        if field[BlockState][block_address] == B_TEMP                           'is this an B_TEMP block?
            flash_read_block_addr(block_address, @signature, $000, $003)        'if so, read first long of block to get ID
            field[IDValid][signature.[19..8]]~                                  '..cancel ID flag (bit := 0)
            field[BlockState][block_address] := B_FREE                          '..return block state to B_FREE
            badBlockCount++                                                     '..would cancel block to inhibit future CRC checks
            'debug(" -- found dead block...")
            status :=  (LONG[@errorCode][cogid()] := E_BAD_BLOCKS_REMOVED)

    'debug("mntCk: - mount test done")
    status := fileCount > 0 and badBlockCount == 0 ? true :false

    lockrel(fsLock)              ' release the lock, we're done with it
    'debug("- lock released")


PUB mount() : status | block_address, blockTypeBits, signature

'' Mount the filesystem so it is ready to use after scanning all blocks and initilizing internal tables and buffers
''
'' @returns status - E_BAD_BLOCKS_REMOVED if BAD blocks were found and fixed,
'' .. E_NO_LOCK_AVAIL if all 16 LOCKs are in use, otherwise 0 for success

' Local Variables:
' @local block_address - the block offset within the file system
' @local blockTypeBits - block type and lifeCycle bits of block being checked
' @local signature - block state bits of block being checked

    if fsMounted == true
        return (LONG[@errorCode][cogid()] := SUCCESS)                           ' don't mount if already mounted

    if fsLock == -1                                                             ' don't acquire lock if already have it
        if setup_semaphore() < 0
            return LONG[@errorCode][cogid()]

    'debug("* mount()")
    LONG[@errorCode][cogid()] := SUCCESS                                        ' preset to success

    'debug("- have lock, trying...")
    repeat while locktry(fsLock) == 0                                           ' try to get the lock

   'debug("- locked")
    fsMounted := true                                                           ' set "mounted" inidcation

    'debug("- mounting...")
    bytefill(@hStatus, 0, MAX_FILES_OPEN)                                       'clear handles
    bytefill(@IDValids, 0, Flags_SIZE)                                          'clear ID flags
    bytefill(@BlockStates, 0, States_SIZE)                                      'clear block states to B_FREE

    IDToBlock  := ^@IDToBlocks.[11..0]                                          'set field pointers
    IDValid    := ^@IDValids.[0]
    BlockState := ^@BlockStates.[1..0]

    'debug("mnt: - fixing power-out leftovers...")
    repeat BLOCKS with block_address                                            'check each block and fix any duplicate IDs
        check_block_fix_dupe_id(block_address)                                  '(recovers from incomplete block switchover due to power loss)

    'debug("mnt: - locating files...")
    repeat BLOCKS with block_address                                            'trace head blocks and cancel any broken files
        if field[BlockState][block_address] == B_TEMP                           'is this a valid block?
            flash_read_block_addr(block_address, @blockTypeBits, $000, $000)    'yes, read first byte of block
            ifnot blockTypeBits.[1]                                             'is this a head block?
                'debug("mnt: - head block ", uhex_word(block_address))
                ifnot trace_file_set_flags(block_address, true)                 'yes, trace file, set block states to B_HEAD/B_BODY
                    trace_file_set_flags(block_address, false)                  'if error, retrace file, return block states to B_TEMP

    'debug("mnt: - clearing dead blocks...")
    repeat BLOCKS with block_address                                            'cancel B_TEMP blocks that didn't become B_HEAD/B_BODY blocks
        if field[BlockState][block_address] == B_TEMP                           'is this an B_TEMP block?
            flash_read_block_addr(block_address, @signature, $000, $003)             'if so, read first long of block to get ID
            field[IDValid][signature.[19..8]]~                                  '..cancel ID flag (bit := 0)
            field[BlockState][block_address] := B_FREE                          '..return block state to B_FREE
            flash_cancel_block(block_address)                                   '..cancel block to inhibit future CRC checks
            'debug(" -- found dead block...")
            status :=  (LONG[@errorCode][cogid()] := E_BAD_BLOCKS_REMOVED)

    'debug("mnt: - mount done")

    lockrel(fsLock)              ' release the lock, we're done with it
    'debug("- lock released")


PUB mounted() : bool

'' Returns the mounted status of the filesystem
''  (saves us from having to find creative ways to get an error code telling us this)
''
'' @returns bool - True/False where True means the filesystem has already been successfully mounted

  return fsMounted


PUB unmount() : status | handle, tmpFsLock, tmpStatus

'' Prepare for shutdown / power-off by closing any open files
''
'' @returns status - 0 (SUCCESS) if successful,
'' .. E_NOT_MOUNTED if filesystem had not been mounted

' Local Variables:
' @local handle - temporary handle to use when closing files

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  status := LONG[@errorCode][cogid()] := SUCCESS

  'debug("* unmount()")
  repeat handle from 0 to MAX_FILES_OPEN - 1                                    ' for each handle
    if hStatus[handle]                                                          ' if handle is open...
        tmpStatus := close_no_lock(handle)                                      ' ..close it!
        if tmpStatus < 0
            status := tmpStatus

  tmpFsLock := fsLock
  fsLock := -1
  fsMounted := false                                                            ' clear "mounted" indication
  lockrel(tmpFsLock)                                                            ' release the lock, we're done with it
  lockret(tmpFsLock)


PUB format() : status | block_address, cycleBits

'' Format the file system blocks and (re)mount it
''
'' @returns status - 0 (SUCCESS) if successful,
'' .. E_BAD_BLOCKS_REMOVED if BAD blocks were found and fixed,
'' .. E_NO_LOCK_AVAIL if all 16 LOCKs are in use,
'' .. E_NOT_MOUNTED if filesystem has not been mounted

' Local Variables:
' @local block_address - the block offset within the file system
' @local cycleBits - lifeCycle bit-pattern found in block

  'debug("* format()")
  ' ensure we have a lock first!  Abort if we can't get one

    if fsLock == -1                                                             ' don't acquire lock if already have it
        if setup_semaphore() < 0
            return LONG[@errorCode][cogid()]

    'debug("* format()")

    'debug("- have lock, trying...")
    repeat while locktry(fsLock) == 0                                           ' try to get the lock

    LONG[@errorCode][cogid()] := SUCCESS

    'debug("- formatting...")
    repeat block_address from 0 to BLOCKS - 1                                   'cancel all active blocks
        flash_read_block_addr(block_address, @cycleBits, $000, $000)
        'if block_address // 128 == 0
        '  debug(" -- block ", uhex_word_(block_address),", cycle...", ubin_byte(cycleBits))
        if lookdown(cycleBits.[7..5] : %011, %101, %110)
            'debug(" -- clearing...")
            flash_cancel_block(block_address)

    'debug("- formatting done")
    fsMounted := false                                                          ' clear "mounted" indcation so it will mount the scan structures

    lockrel(fsLock)                                                             ' release the lock, we're done with it
    'debug("- lock released")
    return Mount()                                                              '(re)mount flash


PUB error() : result

'' Returns error code from most recent operation
''
'' @returns result - latest error code (SUCCESS, for no error)

  return LONG[@errorCode][cogid()]


PUB open(p_filename, mode) : handle | findings, bFileExists

'' Open file in mode; return handle (0..n) if successful
''
'' @param p_filename - address of a zstring containing the filename
'' @param mode - the mode in which to open the file:
'' -- mode "r", "R" to read from an existing file
'' -- mode "w", "W" to write to a new file (or overwrites existing file)
'' -- mode "a", "A" to append to the end of an existing file (file is created if doesn't exist)
'' @returns handle - handle to open file if successful,
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_NO_HANDLE if no handle is available,
'' .. E_FILE_MODE if mode letter(s) is/are invalid,
'' .. E_DRIVE_FULL if flash filesystem is full (write/append mode),
'' .. E_FILE_OPEN if file is already open,
'' .. E_FILE_NOT_FOUND if file does not exist (read mode)

' PENDING -- mode "r+", "R+" to read from or / write to anywhere within an existing file

{
    ANSI C file info
    REF: https://www.tutorialspoint.com/cprogramming/c_file_io.htm
    REF: https://en.wikipedia.org/wiki/C_file_input/output
        "r"  (read-only) Open a file for reading.  The file must exist.
        "w"  (write-only) Create an empty file for writing.  If a file with the same name already exists,
             its contents are discarded and the file is treated as a new empty file.
        "a"  (write-only) Append to a file.  Writing operations append data at the end of the file.
             The file is created if it does not exist.
        "r+" (read-write) Open a file for update both reading and writing.  The file must exist.
        "w+" (read-write) Create an empty file for both reading and writing.  If a file with the same name
             already exists its contents are discarded and the file is treated as a new empty file.
        "a+" (read-write) Opens a text file for both reading and writing. It creates the file if it does not exist.
             The reading will start from the beginning but writing can only be appended.
}
  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)
  elseif fsFreeHndlCt == 0
    return (LONG[@errorCode][cogid()] := E_NO_HANDLE)

  ' mode-specific checks
  case mode
    "r", "R":
    "a", "A", "w", "W", "r+", "R+":
      ifnot blocks_free()                                                       'if no free block exists, abort with error
        return (LONG[@errorCode][cogid()] := E_DRIVE_FULL)
    other: return (LONG[@errorCode][cogid()] := E_FILE_MODE)

  'debug("open(", udec_(handle), ") ENTRY get sem #", udec_(fsLock))
  repeat while locktry(fsLock) == 0                                             'lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                'new operation clear any prior error code
  handle := NOT_VALID

  ' determine if our file exists, once
  bFileExists := exists_no_lock(p_filename)

  ' do checks that require the lock
  case mode
    "r", "R", "r+", "R+":
      ifnot bFileExists                                                  'if no free block exists, abort with error
        'debug("open(", sdec_(handle), ") filename=[", zstr_(p_filename), "]")
        handle := (LONG[@errorCode][cogid()] := E_FILE_NOT_FOUND)

  if handle == NOT_VALID and is_file_open(p_filename, H_READ_WRITE)                                     'if file is already open, abort
    handle := (LONG[@errorCode][cogid()] := E_FILE_OPEN)

  elseif handle == NOT_VALID and fsFreeHndlCt == 0                                                          'yep, check this again since we have the lock
    handle := (LONG[@errorCode][cogid()] := E_NO_HANDLE)

  if LONG[@errorCode][cogid()] <> SUCCESS
    lockrel(fsLock)                                                             ' aborting, release the lock
    'debug("open(", sdec_(handle), ") ABORT freed sem #", udec_(fsLock), " err=", sdec_(LONG[@errorCode][cogid()]))
    return

  ' the following calls release the lock
  case mode
    "r", "R"  : handle := finish_open_read(p_filename, 0)
    "w", "W"  : handle := finish_open_write(p_filename, 0)
    "r+", "R+": handle := finish_open_modify(p_filename)
    "a", "A"  :
      if bFileExists
          handle := finish_open_append(p_filename, 0)
      else
          handle := finish_open_write(p_filename, 0)

  if handle < 0
    LONG[@errorCode][cogid()] := handle

  'debug("open(", sdec_(handle), ") EXIT freed sem #", udec_(fsLock))


PUB open_circular(p_filename, mode, max_file_length) : handle | bFileExists

'' Open circular file of max_file_length in mode; return handle (0..n) if successful
''
'' @param p_filename - address of a zstring containing the filename
'' @param mode - the mode in which to open the file:
'' -- mode "a", "A" to append to the end of an existing circular file (file created if doesn't exist)
'' -- mode "r", "R" to read from an existing circular file
'' @param max_file_length - constrain the file to this length (in bytes)
'' @returns handle - handle to open file if successful,
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_NO_HANDLE if no handle is available,
'' .. E_BAD_FILE_LENGTH if file length is negative or zero,
'' .. E_FILE_MODE if mode letter(s) is/are invalid,
'' .. E_FILE_NOT_FOUND if file does not exist (read mode),
'' .. E_DRIVE_FULL if flash filesystem is full (write/append mode),
'' .. E_FILE_OPEN if file is already open

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)
  elseif fsFreeHndlCt == 0
    return (LONG[@errorCode][cogid()] := E_NO_HANDLE)
  elseif max_file_length < 1
    return (LONG[@errorCode][cogid()] := E_BAD_FILE_LENGTH)

  ' do we have a legal mode?
  case mode
    "r", "R":
    "a", "A":
    '"r+", "R+": handle := finish_open_modify(p_filename)
    other: return (LONG[@errorCode][cogid()] := E_FILE_MODE)

  ' acquire lock
  repeat while locktry(fsLock) == 0                                             'lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          'new operation clear any prior error code
  handle := NOT_VALID

  ' determine if our file exists, once
  bFileExists := exists_no_lock(p_filename)

  ' do checks that require the lock
  case mode
    "r", "R":
      ifnot bFileExists                                                  'if no free block exists, abort with error
        handle := (LONG[@errorCode][cogid()] := E_FILE_NOT_FOUND)
    "a", "A":
    '"r+", "R+": handle := finish_open_modify(p_filename)
      ifnot blocks_free()                                                       'if no free block exists, abort with error
        handle := (LONG[@errorCode][cogid()] := E_DRIVE_FULL)

  if handle == NOT_VALID and is_file_open(p_filename, H_READ_WRITE)                                     'if file is already open, abort
    handle := (LONG[@errorCode][cogid()] := E_FILE_OPEN)

  if LONG[@errorCode][cogid()] <> SUCCESS
    lockrel(fsLock)                                                             ' aborting, release the lock
    return

  ' the following calls release the lock
  case mode
    "a", "A":
      if bFileExists
        handle := finish_open_append(p_filename, max_file_length)
      else
        handle := finish_open_write(p_filename, max_file_length)
    "r", "R": handle := finish_open_read(p_filename, max_file_length)

  if handle < 0
    LONG[@errorCode][cogid()] := handle


PUB flush(handle) : status

'' Logically, "close", then "reopen file in same mode" (but you don't lose filehandle when you flush() instead
''
'' @param handle - a handle to an open file
'' @returns status - 0 (SUCCESS) if successful,
'' .. E_FILE_MODE if close doesn't recognize this file mode (internal error),
'' .. E_BAD_HANDLE if the handle is not valid

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)
  elseif handle < 0 or handle > MAX_FILES_OPEN - 1
    return (LONG[@errorCode][cogid()] := E_BAD_HANDLE)

  repeat while locktry(fsLock) == 0                                             'lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          'new operation clear any prior error code

'' Flush write buffer, completes any write operation, but leaves file open

  case hStatus[handle]

    H_WRITE, H_APPEND:             'write/rewrite/append mode?
      close(handle)                 'close file
      start_modify(handle, H_APPEND, hHeadBlockID[handle], hCircularLength[handle])  'reopen file in append mode

    H_OVERWRITE:                   'modify mode?
      if hModified[handle]~             'if block was modified (post-clear)..
        rewrite_block(handle)                '..rewrite block

    other:                      'other mode?
      LONG[@errorCode][cogid()] := E_FILE_MODE                  'flush not allowed, abort

  lockrel(fsLock)                                                               ' release the lock, we're done with it


PUB close(handle) : status

'' Close an open file, completes the file write, rewrite, or read-modify-write then frees handle
''
'' @param handle - a handle to an open file
'' @returns status - 0 (SUCCESS) if successful,
'' .. E_FILE_MODE if close doesn't recognize this file mode (internal error),
'' .. E_BAD_HANDLE if the handle is not valid

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)
  elseif handle < 0 or handle > MAX_FILES_OPEN - 1
    return (LONG[@errorCode][cogid()] := E_BAD_HANDLE)

  'debug("close(", udec_(handle), ") ENTRY get sem #", udec_(fsLock))
  repeat while locktry(fsLock) == 0                                             'lock for exlusive use

  status := close_no_lock(handle)                                       'commit our file changes

  lockrel(fsLock)                                                               ' release the lock, we're done with it
  'debug("close(", sdec_(handle), ") EXIT freed sem #", udec_(fsLock))


PUB rename(p_cur_filename, p_new_filename) : status | signature, new_block_address, cur_block_address, next_cycle_bits

'' Rename a a file named p_cur_filename to p_new_filename
''
'' @param p_cur_filename - address of a zstring containing the existing filename
'' @param p_new_filename - address of a zstring containing the new filename
'' @returns status - 0 (SUCCESS) if successful,
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_FILE_NOT_FOUND if old file doesn't exist,
'' .. E_FILE_OPEN if either file is open,
'' .. E_FILE_EXISTS if new file already exists,
'' .. E_DRIVE_FULL if no available space left in filesystem

' Local Variables:
' @local signature - block state bits of block being renamed
' @local new_block_address - the block offset within the file system for the new block
' @local cur_block_address - the block offset within the file system for the old block
' @local next_cycle_bits - active lifecycle bits for new block indicating block is newer than block containing the old filename

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)

  repeat while locktry(fsLock) == 0                                            ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          ' new operation clear any prior error code

  if is_file_open(p_cur_filename, H_READ_WRITE)                                 'if old file is open, abort
    status := (LONG[@errorCode][cogid()] := E_FILE_OPEN)

  elseif is_file_open(p_new_filename, H_READ_WRITE)                             'if new file is open, abort
    status := (LONG[@errorCode][cogid()] := E_FILE_OPEN)

  elseifnot available_blocks()                                                  ' if no more blocks , abort
    status :=  (LONG[@errorCode][cogid()] := E_DRIVE_FULL)

  elseif get_file_head_signature(p_new_filename)                                'if new file exists, abort
    status := (LONG[@errorCode][cogid()] := E_FILE_EXISTS)

  elseifnot signature := get_file_head_signature(p_cur_filename)                'if old file doesn't exist, abort
    status := (LONG[@errorCode][cogid()] := E_FILE_NOT_FOUND)

  else
    ' a file rename consists of replacing the current head block of the file with a new head block containing the new filename
    ' then cancelling the old head block
    new_block_address := next_block_address()                                   'get a new block to use for renaming (may move head block)
    cur_block_address := field[IDToBlock][signature.[19..8]]                    'get head block of file to rename (AddressOfNextBlock may have changed lookup)

    flash_read_block_addr(cur_block_address, @tmpBlockBuffer, $000, $FFF)           'read head block of file to rename
    tmpBlockBuffer.long[1].[31..12] := filename_crc(p_new_filename)   'install new filename CRC
    bytefill(@tmpBlockBuffer + $008, $FF, FILENAME_SIZE)       'clear filename space to prevent old trailing chrs
    strcopy(@tmpBlockBuffer + $008, p_new_filename, FILENAME_SIZE - 1)   'copy new filename into filename space
    flash_program_updated_block(new_block_address, @tmpBlockBuffer)         'program updated block
    flash_cancel_block(cur_block_address)                     'cancel old block

    field[IDToBlock][signature.[19..8]] := new_block_address                    'update IDToBlock
    field[BlockState][new_block_address] := B_HEAD                              'make new block HEAD
    field[BlockState][cur_block_address] := B_FREE                              'make old block FREE

  lockrel(fsLock)                                                               ' release the lock, we're done with it


PUB delete(p_filename) : status | signature

'' Delete a named file
''
'' @param p_filename - address of a zstring containing the filename
'' @returns status - 0 (SUCCESS) if successful,
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_FILE_NOT_FOUND if file doesn't exist,
'' .. E_FILE_OPEN if file is open

' Local Variables:
' @local signature - block state bits of block being removed

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  status := LONG[@errorCode][cogid()] := SUCCESS                                                          ' new operation clear any prior error code

  if is_file_open(p_filename, H_READ_WRITE)                                     'if file open in any mode, abort
    status := (LONG[@errorCode][cogid()] := E_FILE_OPEN)

  elseifnot signature := get_file_head_signature(p_filename)                    'if file doesn't exist, abort
    status := (LONG[@errorCode][cogid()] := E_FILE_NOT_FOUND)

  else
    ' a file delete consists of cancelling all blocks in the file chain
    delete_chain_from_id(signature.[19..8], 0, 0, False)        'cancel and free all blocks in file, don't keep first ID valid

  lockrel(fsLock)                                                               ' release the lock, we're done with it


PUB create_file(p_filename, fillValue, byteCount) : status | signature, headBlockID, block_id, block_address, NotFirst, dataOffset, isLast, currOffset, NextID_EndPtr

'' Make a file of a byteCount size filled with fillValue bytes - use OpenModify() to read and write contents
''
'' @param p_filename - address of zstring containing name for new file
'' @param fillValue - initial value for all bytes in file
'' @param byteCount - desired length of file in bytes
'' @returns status -

' Local Variables:
' @local signature -
' @local headBlockID -
' @local block_id -
' @local block_address -
' @local NotFirst -
' @local dataOffset -
' @local isLast -
' @local currOffset -
' @local NextID_EndPtr -

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                          ' new operation clear any prior error code

  if is_File_Open(p_filename, H_READ_WRITE)                                     'if file is open, abort
    status := (LONG[@errorCode][cogid()] := E_FILE_OPEN)

  elseifnot available_blocks()                                                  ' if no more blocks , abort
    status :=  (LONG[@errorCode][cogid()] := E_DRIVE_FULL)

  elseif signature := get_file_head_signature(p_filename)                       'if file exists, abort
    status := (LONG[@errorCode][cogid()] := E_FILE_EXISTS)

  else

    block_id := headBlockID := next_available_block_id()                        'get initial ID

    repeat
      block_address := next_block_address()                                     'get a new block now (may alter BlockBuff and IDToBlock)
      ifnot NotFirst                                                            'if first block..
        build_head_block(@tmpBlockBuffer, p_filename, 0)                        '..build head block in buffer
        dataOffset := $088                                                      '..set data start for head block
      else                                                                      'if not first block..
        bytefill(@tmpBlockBuffer, fillValue, BLOCK_SIZE)                        '..clear buffer for body block
        dataOffset := $004                                                      '..set data start for body block
      if isLast := byteCount <= (currOffset += $FFC - dataOffset)               'if last block.. (update position and check if last block)
        NextID_EndPtr := byteCount - currOffset + $FFC                          '..get EndPtr
      else                                                                      'if not last block..
        NextID_EndPtr := next_available_block_id()                              '..get NextID
      tmpBlockBuffer.[0] := !isLast                                             'set more/last bit
      tmpBlockBuffer.long.[19..8] := block_id                                   'set ThisID
      tmpBlockBuffer.long.[31..20] := NextID_EndPtr                             'set NextID or EndPtr
      flash_program_block(block_address, @tmpBlockBuffer, %011)                 'program block
      if NotFirst                                                               'if not head block..
        flash_activate_block(block_address, %011)                               '..activate body block
      field[IDToBlock][block_id] := block_address                               'set IDToBlock
      field[BlockState][block_address] := NotFirst~~ ? B_BODY : B_HEAD          'set block state to head/body, set NotFirst
      block_id := NextID_EndPtr                                                 'switch to next ID
    until isLast                                                                'loop until last block done

    flash_activate_block(field[IDToBlock][headBlockID], %011)                   'now activate head block to activate file

  lockrel(fsLock)                                                               ' release the lock, we're done with it


PUB exists(p_filename) : bool

'' Determine if named file is present in the file system
''
'' @param p_filename - address of a zstring containing the filename
'' @returns result - True/False where True means the file exists
'' (sets error() to E_NOT_MOUNTED and returns false if filesystem has not been mounted)

  bool := false
  if fsMounted == false
    LONG[@errorCode][cogid()] := E_NOT_MOUNTED
  else
    repeat while locktry(fsLock) == 0                                           ' lock for exlusive use

    LONG[@errorCode][cogid()] := SUCCESS                                                        ' new operation clear any prior error code

    bool := exists_no_lock(p_filename)

    lockrel(fsLock)                                                             ' release the lock, we're done with it


PUB file_size(p_filename) : size_in_bytes | signature

'' Return size of file in bytes
''
'' @param p_filename - address of a zstring containing the filename
'' @returns size_in_bytes - either the count of bytes contained in the file or
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_FILE_NOT_FOUND if the file doesn't exist

' Local Variables:
' @local signature - block state bits of block being checked

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          ' new operation clear any prior error code

  if signature := get_file_head_signature(p_filename)                           'does file exist?
    size_in_bytes, _, _ := count_file_bytes(field[IDToBlock][signature.[19..8]])
  else
    size_in_bytes := (LONG[@errorCode][cogid()] := E_FILE_NOT_FOUND)

  lockrel(fsLock)                                                               ' release the lock, we're done with it


PUB file_size_for_handle(handle) : size_in_bytes

'' Return size of file in bytes
''
'' @param handle - a handle to an open file
'' @returns size_in_bytes - either the count of bytes contained in the file or
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_FILE_NOT_FOUND if the file doesn't exist

' Local Variables:
' @local signature - block state bits of block being checked

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          ' new operation clear any prior error code

  if hHeadBlockID[handle] <> NOT_VALID                                          'should we not know the current file lenght..
    size_in_bytes, _, _ := count_file_bytes(field[IDToBlock][hHeadBlockID[handle]])
  else
    size_in_bytes := (LONG[@errorCode][cogid()] := E_FILE_NOT_FOUND)

  lockrel(fsLock)                                                               ' release the lock, we're done with it


PUB file_size_unused(p_filename) : size_in_bytes_unused | signature

'' Return the number of bytes not yet written in the last allocated block
''
'' @param p_filename - address of a zstring containing the filename
'' @returns size_in_bytes_unused - either the count of unwritten bytes of the file or
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_FILE_NOT_FOUND if the file doesn't exist

' Local Variables:
' @local signature - block state bits of block being checked

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          ' new operation clear any prior error code

  if signature := get_file_head_signature(p_filename)                           'does file exist?
    _, size_in_bytes_unused, _ := count_file_bytes(field[IDToBlock][signature.[19..8]])
  else
    size_in_bytes_unused := (LONG[@errorCode][cogid()] := E_FILE_NOT_FOUND)

  'debug("file_size_unused(", zstr_(p_filename), ") = (", sdec_(size_in_bytes_unused), ")")

  lockrel(fsLock)                                                               ' release the lock, we're done with it


PUB seek(handle, position, whence) : end_position | file_length, file_position, block_id, pBuff

'' Postion seek file pointer to position within the file or at the end of the file
'' -- use 0, SK_FILE_START for position to seek to the start of the file
'' -- use POSX, SK_FILE_START (largest positive LONG value) for position to seek to the current end of the file
'' -- use 0, SK_CURRENT_POSN to get the current position within the file
''
'' @param handle - a handle to an open file
'' @param position - position (in bytes) within the file (0 to length-1)
''  use  seek(handle, POSX, SK_FILE_START) to seek to end of the file
'' @param whence - meaning of position: [SK_FILE_START, SK_CURRENT_POSN]
'' @returns end_position - within the file to which the file pointer was set, or
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_BAD_HANDLE if the handle is not valid,
'' .. E_BAD_SEEK_ARG if invalid whence value,
'' .. E_FILE_MODE if the file is not open in a mode supporting seeks,
'' .. E_FILE_SEEK if attempted seek past either end of file (and didn't use POSX for tail)

' Local Variables:
' @local file_length - temporary for calculated file length
' @local file_position - temporary for calculated seek position

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)
  elseif handle < 0 or handle > MAX_FILES_OPEN - 1
    return (LONG[@errorCode][cogid()] := E_BAD_HANDLE)
  elseif whence <> SK_FILE_START and whence <> SK_CURRENT_POSN
    return (LONG[@errorCode][cogid()] := E_BAD_SEEK_ARG)
  elseif whence == SK_FILE_START and position < 0
    'debug("seek() early out")
    return (LONG[@errorCode][cogid()] := E_FILE_SEEK)

  case hStatus[handle]                                                          'get handle
    H_READ:                                                                     'READ?
      {okay, direct access allowed}
    H_OVERWRITE:                                                                'WRITE and MODIFY?
      {okay, direct access allowed}
    other:
      return (LONG[@errorCode][cogid()] := E_FILE_MODE)                         ' no, abort with error (open mode does not support seeking)

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                          ' new operation clear any prior error code

  if whence == SK_FILE_START                                                    ' if seeking from current position
    file_position := position
  else
    ' for SK_CURRENT_POSN, we need to calculate the adjusted position
    file_position := hSeekPtr[handle] <> NOT_ENABLED ? hSeekFileOffset[handle] : 0 ' if seek mode enabled, use seek pointer, else use 0
    file_position += position                                                   ' calculate the adjusted position

  file_length, _, _ := count_file_bytes(field[IDToBlock][hHeadBlockID[handle]]) ' get the file length

  if file_length > 0 and position == POSX                                       ' if have file length and attempting to seek beyond, limit to end of file
    file_position := file_length

  'debug("seek(", sdec_(position), "), ", sdec(file_position), udec(file_length))

  if file_length < 0
    end_position := (LONG[@errorCode][cogid()] := file_length)                  ' error, return the error code instead of a SUCCESS status
  elseif hCircularLength[handle] > 0 and (file_position < 0 or file_position > hCircularLength[handle]) ' if circular file and position is out of range
   'debug("seek() circular out")
   end_position := (LONG[@errorCode][cogid()] := E_FILE_SEEK)                  ' abort with error
  elseif file_position >= 0 and file_position <= file_length                    ' is position within file? ( allow length + 1 for append )
    'debug("seek(", udec_(file_position), "), FSize=(", udec_(file_length), ") going to location, offset=(", sdec_(position), ")")
    seek_no_locks(handle, file_position)
    end_position := file_position                                               ' no, return SUCCESS
  else
   'debug("seek() file-range out")
   end_position := (LONG[@errorCode][cogid()] := E_FILE_SEEK)                  ' no, abort with error

  lockrel(fsLock)                                                               ' release the lock, we're done with it


PUB write(handle, p_buffer, count) : bytes_written | checkValue, byteIndex, wr_value, wr_status

'' Write count bytes from p_buffer to the file associated with handle
''
'' @param handle - the handle to the file to which to write byte(s)
'' @param p_buffer - the address of the buffer containing the users' data to write
'' @param count - the number of bytes to write to the file
'' @returns bytes_written - the count of bytes written to the file or,
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for writing,

' Local Variables:
' @local checkValue - a temporary variable to hold the status returned from checking the handle
' @local byteIndex - the index into the users' buffer for the next byte to write
' @local wr_value - the next value to be written to the file
' @local wr_status - the status returned from the wr_byte() function

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)

  'debug("write(", udec_(handle), ") ENTRY get sem #", udec_(fsLock))
  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                          ' new operation clear any prior error code

  'debug("write(", udec(handle), uhex_long(p_buffer), udec(count) ,")")

  if (checkValue := ensure_handle_mode(handle, H_WRITE)) < 0        ' is handle valid and open for writing?
     bytes_written := (LONG[@errorCode][cogid()] := checkValue)                 ' no, return error code
  else
    'debug("write() [",zstr_(p_buffer),"](",udec_(count),")")
    bytes_written := 0
    repeat byteIndex from 0 to count - 1                                        ' for the max length of the buffer
        wr_value := BYTE[p_buffer][byteIndex]
        if (wr_status := wr_byte_no_locks(handle, wr_value)) < 0                ' write a byte to the file (or to seek location in file)
            LONG[@errorCode][cogid()] := wr_status                              ' an error occured, set the error code
            if bytes_written == 0                                               ' if no bytes written, return error
                bytes_written := errorCode
            quit
        else
            bytes_written++                                                     ' keep track of bytes written

  lockrel(fsLock)                                                               ' release the lock, we're done with it
  'debug("write(", udec_(handle), ") EXIT freed sem #", udec_(fsLock))


PUB wr_byte(handle, byteValue) : status | checkValue

'' Write a byte to a file that is open for write or rewrite
''
'' @param handle - handle to a file that is open for write or rewrite
'' @param byteValue - value to write to the file
'' @returns status - 0 (SUCCESS) if successful,
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for writing

' Local Variables:
' @local checkValue - a temporary variable to hold the status returned from checking the handle

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)

  'debug("wr_byte(", udec_(handle), ") ENTRY get sem #", udec_(fsLock))
  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          ' new operation clear any prior error code

  if (checkValue := ensure_handle_mode(handle, H_WRITE)) < 0        ' is handle valid and open for writing?
    status := (LONG[@errorCode][cogid()] := checkValue)                                         ' no, return error code
  else
    status := wr_byte_no_locks(handle, byteValue)

  lockrel(fsLock)                                                               ' release the lock, we're done with it
  'debug("wr_byte(", udec_(handle), ") EXIT freed sem #", udec_(fsLock))


PUB wr_word(handle, word_value) : status | writeLength

'' Write WORD (16-bits) to file associated with handle
'' -- order is Little Endian
''
'' @param handle - the handle of the file to which to write the WORD
'' @param word_value - the 16 bit WORD to write to the file
'' @returns status - 0 (SUCCESS) if successful,
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for writing

  writeLength := write(handle, @word_value, 2)
  status := (writeLength < 0) ? writeLength : SUCCESS


PUB wr_long(handle, long_value) : status | writeLength

'' Write LONG (32-bits) to file associated with handle
'' -- order is Little Endian
''
'' @param handle - the handle of the file to which to write the LONG
'' @param long_value - the 32 bit LONG to write to the file
'' @returns status - 0 (SUCCESS) if successful,
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for writing

  writeLength := write(handle, @long_value, 4)
  status := (writeLength < 0) ? writeLength : SUCCESS


PUB wr_str(handle, p_str) : status | writeLength

'' Write string (including the terminator) from p_str to file associate with handle
''
'' @param handle - the handle of the file to which to write the zString
'' @param p_str - the address of the zString to write to the file
'' @returns status - 0 (SUCCESS) if successful,
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for writing

  'debug("write_str() [",zstr_(p_str),"](",udec_(strsize(p_str)+1),")")
  writeLength := write(handle, p_str, strsize(p_str)+1)                 ' include string terminator
  status := (writeLength < 0) ? writeLength : SUCCESS


PUB read(handle, p_buffer, count) : bytes_read | byteIndex, readValue, checkValue

'' Read count bytes from file associated with handle into p_buffer or to end of file which ever comes first
'' -- returns count of bytes read
''  check error() == SUCCESS before using contents of p_buffer
''  if error() <> SUCCESS then bytes_read is number of bytes read before error occurred
''  "bytes_read < expected" also indicates a non-SUCCESS value in error()
''
'' @param handle - the handle to the file from which to read bytes
'' @param p_buffer - address of the buffer into which to place the bytes read
'' @param count - the maximum number of bytes to place into the buffer
'' @returns bytes_read - the number of bytes actually read from the file
'' --> If error() <> SUCCESS then it will be one of the following reasons:
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for reading,
'' .. E_END_OF_FILE if attempted read beyond written data,

' Local Variables:
' @local byteIndex - the index into the users' buffer for the next byte to be read
' @local readValue - a temporary variable to hold the byte read from the file (or the returned error code)
' @local checkValue - a temporary variable to hold the status returned from checking the handle

  if fsMounted == false
    LONG[@errorCode][cogid()] := E_NOT_MOUNTED
    return

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          ' new operation clear any prior error code

  if (checkValue := ensure_handle_mode(handle, H_READ | H_MODIFY)) < 0                     ' is handle valid and open for reading?
     LONG[@errorCode][cogid()] := checkValue                                                    ' no, set system error
     bytes_read := 0                                                            ' no, 0 bytes read
  else
    bytes_read := 0
    repeat byteIndex from 0 to count - 1                                        ' for the max length of the buffer
      if (readValue := rd_byte_no_locks(handle)) < 0                            ' read a byte from the file (or seek location)
          LONG[@errorCode][cogid()] := readValue                                                ' another error occured, set system error
          quit
      else
        BYTE[p_buffer][byteIndex] := readValue                                  ' no error, place byte in the users buffer
        bytes_read++                                                        ' update count of bytes read

  'debug("read(", udec_(count),") = (", sdec_(bytes_read),")")

  lockrel(fsLock)                                    ' release the lock, we're done with it


PUB rd_byte(handle) : byteValue | ptr, signature, checkValue

'' Read next byte from file associated with handle
''  -- negative value indicates error or end of file
''
'' @param handle - the handle to the file from which to read a byte
'' @returns byteValue - the next byte [0-255] from the file, or
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for reading,
'' .. E_END_OF_FILE if no more data

' Local Variables:
' @local ptr - the address of the 4KB buffer for the file associated with this handle
' @local signature - the block state bits of the block being checked
' @local checkValue - a temporary variable to hold the status returned from checking the handle

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          ' new operation clear any prior error code

  if (checkValue := ensure_handle_mode(handle, H_READ)) < 0                     ' is handle valid and open for reading?
    byteValue := (LONG[@errorCode][cogid()] := checkValue)                                          ' no, return error code
  else
    byteValue := rd_byte_no_locks(handle)                                           ' read a byte from the file (or seek location)

  lockrel(fsLock)                                                               ' release the lock, we're done with it


PUB rd_word(handle) : wordValue | readLength

'' Read next WORD from file associated with the handle
''  -- negative value indicates error or end of file
''
'' @param handle - the handle to the file from which to read a WORD
'' @returns result - the WORD value read from the file, or:
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_WRITING if the file is not open for reading,
'' .. E_END_OF_FILE if attempted read beyond written data

  if (readLength := read(handle, @wordValue, 2)) <> 2
    return LONG[@errorCode][cogid()]


PUB rd_long(handle) : longValue | status, readCount

'' Read next LONG from file associated with the handle
''  NOTE: negative values can be legitimate values, so
''  check error() == SUCCESS before using value
''
'' @param handle - the handle to the file from which to read a LONG
'' @returns value - the LONG value read from the file
''  error() when not SUCCESS could be:
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_WRITING if the file is not open for reading,
'' .. E_END_OF_FILE if attempted read beyond written data

  read(handle, @longValue, 4)


PUB rd_str(handle, p_str, count) : bytes_read | byteIndex, readValue, checkValue

'' Read zstring from file at handle into buffer at p_str (count is max length of string + terminator)
''  check error() == SUCCESS before using value
''
'' @param handle - the handle to the file from which to read a zstring
'' @param p_str - the address of the buffer into which to place the zstring
'' @param count - the maximum number of bytes to place into the buffer (including the terminator)
'' @returns bytes_read - the number of bytes placed into the buffer (strsize() of the string read)
''  error() when not SUCCESS could be:
'' .. E_NOT_MOUNTED if filesystem has not been mounted,
'' .. E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for reading,
'' .. E_END_OF_FILE if attempted read beyond written data

' Local Variables:
' @local byteIndex - the index into the users' buffer for the next byte to be read
' @local readValue - a temporary variable to hold the byte read from the file (or the returned error code)
' @local checkValue - a temporary variable to hold the status returned from checking the handle

  if fsMounted == false
    LONG[@errorCode][cogid()] := E_NOT_MOUNTED
    return

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          ' new operation clear any prior error code

  bytefill(p_str, 0, count)                                                     ' clear the users buffer
  bytes_read := 0
  if (checkValue := ensure_handle_mode(handle, H_READ)) < 0                     ' is handle valid and open for reading?
     LONG[@errorCode][cogid()] := checkValue                                                    ' no, set error code
  else
    repeat byteIndex from 0 to count - 1                                        ' for the max length of the buffer
      if (readValue := rd_byte(handle)) < 0                                     ' read a byte from the file, have error?
        'debug("EEE: ", sdec(readValue))
        if readValue == E_END_OF_FILE                                           ' yes, if we've reached end of file return the number of bytes read
          if byteIndex == 0                                                     ' if we've not read any bytes
            LONG[@errorCode][cogid()] := readValue                                              ' ..abort with end of file
          else                                                                  ' else
            BYTE[p_str][byteIndex] := 0                                         ' place a 0 terminator in the users buffer
            LONG[@errorCode][cogid()] := E_INCOMPLETE_STRING                                    ' return error saying file ended without string terminator
        else
          LONG[@errorCode][cogid()] := readValue                                                ' another error occured, return the error code
        quit  ' have one of the above errors, end loop
      else
        'debug("ok: ", uhex_byte(readValue))
        if byteIndex == count - 1 and readValue <> 0                            ' no error, if we've reached the end of the buffer and the byte read is not a 0 terminator
          BYTE[p_str][byteIndex] := 0                                           ' ..place a 0 terminator in the users buffer
          LONG[@errorCode][cogid()] := E_TRUNCATED_STRING                                       ' ..abort with error
          quit  ' have error end loop
        else
            BYTE[p_str][byteIndex] := readValue                                 ' no error, place byte in the users buffer (could be terminator)
            if readValue == 0                                                   ' if this is a string terminator...
              quit                                                              '  found terminator, end loop
            else
              bytes_read++                                                      ' count this byte received

  lockrel(fsLock)                                    ' release the lock, we're done with it


PUB directory(p_block_id, p_filename, p_file_size) : status | blockID, block_address, signature

'' Get next file's filename and size in bytes via current blockID
''  NOTE: p_filename must be address of a 128 byte buffer!
''
'' @param p_block_id - the next block ID to check for a file head. (Initialize to 0, will be auto-advanced by each call to this method)
'' @param p_filename - the filename of the file found (or a zero length string if no more files, must be address of 128 byte buffer!)
'' @param p_file_size - the number of bytes in the file found (or 0 when no more files)
'' @returns status - 0 (SUCCESS) if successful,
'' .. E_NOT_MOUNTED if filesystem has not been mounted

' Local Variables:
' @local blockID - the id of the block being checked
' @local block_address - the offset within the file system of the block being checked
' @local signature - temporary storage for the block state bits of the block being checked

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED)

  repeat while locktry(fsLock) == 0                                            ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          ' new operation clear any prior error code

  BYTE[p_filename][0] := 0                                                      'reset filename

  repeat while LONG[p_block_id] < BLOCKS                                        'scan any remaining blockID's for file heads
        blockID := LONG[p_block_id]++                                           'get current blockID and post-increment it
        if field[IDValid][blockID]                                              'block ID valid?
          block_address := field[IDToBlock][blockID]                            'yes, get block addr from block ID
          if field[BlockState][block_address] == B_HEAD                         'is this a HEAD block?
            flash_read_block_addr(block_address, p_filename, $008, $088)             'yes, read filename
            LONG[p_file_size], _, _ := count_file_bytes(block_address)          'get file size
            quit

  lockrel(fsLock)                                    ' release the lock, we're done with it

PUB stats() : used_blocks, free_blocks, file_count | block_address

'' Get filesystem stats: used/free block counts and file count
''
'' @returns used_blocks - the number of blocks in use (or E_NOT_MOUNTED if the file system is NOT mounted)
'' @returns free_blocks - the number of free blocks (or 0 if there is an error)
'' @returns file_count - the number of files recorded in filesystem (or 0 if there is an error)

' Local Variables:
' @local block_address - the block offset within the file system

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED), 0, 0

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS                                                          ' new operation clear any prior error code

  used_blocks := 0
  free_blocks := 0
  file_count := 0

  repeat BLOCKS with block_address
    case field[BlockState][block_address]
      B_FREE: free_blocks++
      B_TEMP: used_blocks++
      B_HEAD: used_blocks++
              file_count++
      B_BODY: used_blocks++

  lockrel(fsLock)                                                               ' release the lock, we're done with it


PUB string_for_error(error_code) : p_interpretation

'' Return a string describing the error code
''
'' @param error_code - the error code to translate
'' @returns p_interpretation - interpretation of the errcode

    case error_code
        SUCCESS:                p_interpretation := @"SUCCESS: No error"
        E_BAD_HANDLE:           p_interpretation := @"E_BAD_HANDLE: Handle is invalid"
        E_NO_HANDLE:            p_interpretation := @"E_NO_HANDLE: Out of available handles"
        E_FILE_NOT_FOUND:       p_interpretation := @"E_FILE_NOT_FOUND: File not present"
        E_DRIVE_FULL:           p_interpretation := @"E_DRIVE_FULL: Out of space on flash chip"
        E_FILE_WRITING:         p_interpretation := @"E_FILE_WRITING: File is open for writing"
        E_FILE_READING:         p_interpretation := @"E_FILE_READING: File is open for reading"
        E_FILE_OPEN:            p_interpretation := @"E_FILE_OPEN: File is open"
        E_FILE_EXISTS:          p_interpretation := @"E_FILE_EXISTS: the File exists"
        E_END_OF_FILE:          p_interpretation := @"E_END_OF_FILE: no more data available, at end of file"
        E_FILE_MODE:            p_interpretation := @"E_FILE_MODE: file not opened in desired mode"
        E_FILE_SEEK:            p_interpretation := @"E_FILE_SEEK: Attempted seek past either end of file"
        E_BAD_BLOCKS_REMOVED:   p_interpretation := @"E_BAD_BLOCKS_REMOVED: Block bit failure detetected, bad blocks removed"
        E_NO_LOCK_AVAIL:        p_interpretation := @"E_NO_LOCK_AVAIL: Unable to obtain a LOCK for driver use"
        E_TRUNCATED_STRING:     p_interpretation := @"E_TRUNCATED_STRING: Buffer full, before reaching string terminator"
        E_INCOMPLETE_STRING:    p_interpretation := @"E_INCOMPLETE_STRING: End of file reached before string terminator"
        E_SHORT_TRANSER:        p_interpretation := @"E_SHORT_TRANSER: Too few bytes read or written"
        E_NOT_MOUNTED:          p_interpretation := @"E_NOT_MOUNTED: Filesystem NOT yet accessible"
        E_BAD_FILE_LENGTH:      p_interpretation := @"E_BAD_FILE_LENGTH: File length is negative or zero"
        E_BAD_SEEK_ARG:         p_interpretation := @"E_BAD_SEEK_ARG: Invalid seek argument"
        other:                  p_interpretation := @"???: Unknown error code ???"



CON ' --- Private Methods ---


PRI finish_open_read(p_filename, max_file_length) : handle | signature, lenInBytes, offsetInBytes, endPtr, block_address

' Open a file for reading, returning handle if success
'
' @param p_filename - address of a zstring containing the filename
' @returns handle - handle to open file if successful,
' .. or E_FILE_NOT_FOUND if file doesn't exist,

' Local Variables:
' @local signature - the block state bits of the block being checked

  'debug("* finish_open_read([", zstr_(p_filename), "], bytes=", udec_(max_file_length), ") - ENTRY")
  ifnot signature := get_file_head_signature(p_filename)                        'if file doesn't exist, abort
    handle := (LONG[@errorCode][cogid()] := E_FILE_NOT_FOUND)
  else

    handle := new_handle(p_filename)                                            'get new handle, aborts if no handle available
    hStatus[handle] := H_READ                                                   'set handle status to READ
    hHeadBlockID[handle] := signature.[19..8]                                   'get head ID for use by Seek()
    seek_no_locks(handle, 0)                                                    'seek to start of file

  'debug(" -- open_read() freed sem #", udec_(fsLock))
  lockrel(fsLock)                                                               ' release the lock, we're done with it


PRI finish_open_write(p_filename, max_file_length) : handle | signature, ptr

' Open a file for (re)writing, returning handle if success
'  (overwrites existing file, if you wish to prevent overwrite, use exists() to check!)
'
' @param p_filename - address of a zstring containing the filename
' @returns handle - handle to open file if successful,
' .. or E_NO_HANDLE if no handle is available

' Local Variables:
' @local signature - the block state bits of the block being checked
' @local ptr - the address of the 4KB buffer for the file associated with this handle
    'debug("* finish_open_write(", zstr_(p_filename), ", bytes=", udec_(max_file_length), ") - ENTRY")

  handle := new_handle(p_filename)            'get new handle, abort if no handle available

  if signature := get_file_head_signature(p_filename)         'if file already exists, rewrite it
    start_write(handle, H_APPEND, signature.[19..8], next_active_cycle(signature.[7..5]))
  else                          'else, write it
    start_write(handle, H_WRITE, next_available_block_id(), %011)
    ' NO, we don't write empty files!
    ' hModified[handle]~~                 'force first block to be written in case no data
    'debug("open() WRITE ", uhex_word(hEndPtr[handle], handle))

  'debug(" -- open_write() freed sem #", udec_(fsLock))
  lockrel(fsLock)                                                             ' release the lock, we're done with it


PRI finish_open_append(p_filename, max_file_length) : handle | signature, end_block_address, endPtr, bytes_used, ptr

' Open for append, returning handle if success
'  NOTE: this is called only if file already exists
'  (if it didn't exist finish_open_write() would have been called instead)
'
' @param p_filename - address of a zstring containing the filename
' @returns handle - handle to open file if successful,
' .. or E_NO_HANDLE if no handle is available

    'debug("* finish_open_append(", zstr_(p_filename), ", bytes=", udec_(max_file_length), ") - ENTRY")

    'debug("finish_open_append() get handle")

    handle := new_handle(p_filename)                    'get new handle, set error() if no handle available
    hCircularLength[handle] := max_file_length           'set size limit if non-zero

    if signature := get_file_head_signature(p_filename)         'if file already exists, append it
      start_modify(handle, H_APPEND, signature.[19..8], $FFFFFF)
    else                          'else, write it
      start_write(handle, H_WRITE, next_available_block_id(), %011)
      ' NO, we don't write empty files!
      'hModified[handle]~~                 'force first block to be written in case no data

    lockrel(fsLock)                                    ' release the lock, we're done with it


PRI finish_open_modify(p_filename) : handle | signature

' Open an existing file for reading and writing within current file boundaries, returns handle
'
' Subsequent calls are allowed to:
'   seek(),
'   rd_byte(), rd_word(), rd_long(), read(), rd_str()
'   wr_byte(), wr_word(), wr_long(), write(), wr_str()
'   flush()
'   close() - releases handle
'
' @param p_filename - address of a zstring containing the filename
' @returns handle - handle to open file

' Local Variables:
' @local signature - the block state bits of the block being checked

  signature := get_file_head_signature(p_filename)
  handle := new_handle(p_filename)            'get new handle, abort if no handle available

  start_modify(handle, H_OVERWRITE, signature.[19..8], 0)  'go to start of file

  lockrel(fsLock)                                                             ' release the lock, we're done with it


PRI exists_no_lock(p_filename) : bool

' Determine if named file is present in the file system
' . (internal version - for use when caller has already grabbed lock)
'
' @param p_filename - address of a zstring containing the filename
' @returns bool - True/False where True means the file exists

  bool := get_file_head_signature(p_filename) ? true : false


PRI rd_byte_no_locks(handle) : byteValue | pBuff, signature, isSeeking, endPtr

' Read next BYTE from file associated with handle
'  -- negative value indicates error or end of file

' @param handle - the handle to the file from which to read a byte
' @returns value - the next byte [0-255] from the file, or:
' .. E_END_OF_FILE if no more data,
' .. E_FILE_MODE if read not allowed for this file,

' Local Variables:
' @local ptr - the address of the 4KB buffer for the file associated with this handle
' @local signature - the block state bits of the block being checked
' @local isSeeking - temporary variable T/F where T we use hSeekPtr vs hEndPtr
' @local endPtr - temporary variable value of whichever Ptr we are using

  isSeeking := (hSeekPtr[handle] <> NOT_ENABLED) ? true : false                 ' is seek pointer in use?
  endPtr := isSeeking ? hSeekPtr[handle] : hEndPtr[handle]

  pBuff := buffer_pointer(handle)                                                 ' get buffer pointer
  signature := LONG[pBuff]                                                        ' get first long

  case hStatus[handle]

    H_READ, H_OVERWRITE:                'read/modify mode?
      ifnot signature.[0]                                                       ' if last block and no more data, return error code
        if endPtr == LONG[pBuff].[31..20]
          'debug("* rdByte EOF")
          return  (LONG[@errorCode][cogid()] := E_END_OF_FILE)
      else
        if endPtr == $FFC                                                       ' else, if no more data then read next body block
          if hStatus[handle] & H_MODIFY                                         '..and if modify mode..
            if hModified[handle]~                                               '..and if block was modified (post-clears)..
              rewrite_block(handle)                                             '..then rewrite block (might move a block)
          flash_read_block_addr(field[IDToBlock][signature.[31..20]], pBuff, $000, $FFF)
          endPtr := $004

    other:                      'other mode?
      'debug("* rdByte FILE MODE ERR")
      return (LONG[@errorCode][cogid()] := E_FILE_MODE)                         'read not allowed, abort

  byteValue := BYTE[pBuff][endPtr++]                                            ' get data byte to return and increment pointer
  if isSeeking
    hSeekPtr[handle] := endPtr                                                  ' point to start of data in body block
    hSeekFileOffset[handle] += 1                                                ' we moved keep track
  else
    hEndPtr[handle] := endPtr                                                   ' point to start of data in body block
    'debug("+ rd_byte() ", uhex_word(hEndPtr[handle], handle))
  'debug("rd_byte() [",uhex_byte_(byteValue),"]")


PRI wr_byte_no_locks(handle, byteValue) : status | pBuff, nextBlockID, isSeeking, endPtr, shouldWrite

' Write a byte to a file that is open for write or rewrite
'
' @param handle - handle to a file that is open for write or rewrite
' @param byteValue - value to write to the file
' @returns status - 0 (SUCCESS) if successful,
' .. E_BAD_HANDLE if the handle is not valid

' Local Variables:
' @local ptr - the address of the 4KB buffer for the file associated with this handle
' @local nextBlockID - block ID of the next block to write to the file

  isSeeking := (hSeekPtr[handle] <> NOT_ENABLED) ? true : false                 ' is seek pointer in use?
  endPtr := isSeeking ? hSeekPtr[handle] : hEndPtr[handle]

  pBuff := buffer_pointer(handle)                                               'get buffer pointer
  hWriteCount[handle]++                                                         'increment byte count
  status:= SUCCESS
  shouldWrite := true
  case hStatus[handle]

    H_WRITE, H_APPEND:                                                          'write/rewrite/append mode?
      if hEndPtr[handle] == $FFC                                                'if current block full..
        long[pBuff].[0]~~                                                       '..make more block
        nextBlockID := next_available_block_id()                                '..get next ID to link to
        write_block(handle, nextBlockID)                                        '..write current block with NextID link
        bytefill(pBuff, $FF, BLOCK_SIZE)                                        '..erase block buffer to build new body block
        long[pBuff].[0]~                                                        '..make last block
        long[pBuff].[19..8] := nextBlockID                                      '..set ID
        hEndPtr[handle] := $004                                                 '..point to start of data in new block

    H_OVERWRITE:                                                                'modify mode?
      ifnot long[pBuff].[0]                                                     'if last block..
        if hEndPtr[handle] == long[pBuff].[31..20]                              '..and if end of data
          shouldWrite := false                                                  '..then return without writing
          ' FIXME: TODO: should this return an ERROR?!!
      else                                                                      'if not last block..
        if hEndPtr[handle] == $FFC                                              '..and if block full
          if hModified[handle]~                                                  '..and if block was modified
            rewrite_block(handle)                                               '..then rewrite block (might move a block)
          flash_read_block_id(long[pBuff].[31..20], pBuff, $000, $FFF)          '..read next block
          hEndPtr[handle] := $004                                               '..point to start of data in next block

    other:                                                                      'other mode?
      status := E_FILE_MODE                                                     'write not allowed, abort

  if status == SUCCESS and shouldWrite == true
    hSeekFileOffset[handle]++                                                   'increment location
    hModified[handle]~~                                                         'set modified flag
    byte[pBuff][hEndPtr[handle]++] := byteValue                                 'write byte into block buffer, post-increment pointer


PRI seek_no_locks(handle, file_position) | pBuff, block_id

' seek file associted with handle to new position
'
' @param handle - handle to open file
' @param file_position - desired file postion

' Local Variables:
' @local pBuff - a temporary pointer to the handles block buffer
' @local block_id - temp block id

    pBuff := buffer_pointer(handle)                                             'get block buffer pointer
    block_id, hEndPtr[handle], hSeekFileOffset[handle] := locate_file_byte(hHeadBlockID[handle], file_position) 'locate byte in file
    'debug("seek_no_locks() ", udec(file_position, hSeekFileOffset[handle]))
    if hStatus[handle] & H_MODIFY                                               'if modify mode..
      if block_id <> long[pBuff].[19..8]                                        '..and if different block block ID
        if hModified[handle]~                                                   '..and if block was modified (post-clears)
          rewrite_block(handle)                                                 '..then rewrite block (might move a block)

    hSeekPtr[handle] := hEndPtr[handle]                                         ' point to start of data in body block
    flash_read_block_id(block_id, pBuff, $000, $FFF)          'read new block into buffer


PRI close_no_lock(handle) : status | fileMode, sizeLimit, chain_block_address, head_block_id, chain_block_id, chainState

' Close an open file, completes the file write, rewrite, or read-modify-write then frees handle
' . (do all the close operations, caller has locked and will release)
'
' @param handle - a handle to an open file
' @returns status - 0 (SUCCESS) if successful,
' .. E_FILE_MODE if close doesn't recognize this file mode (internal error),
' .. E_BAD_HANDLE if the handle is not valid

  LONG[@errorCode][cogid()] := SUCCESS                                          'new operation clear any prior error code
  fileMode := hStatus[handle]~                                                  'get handle and post-clear it

  if hModified[handle]                                                          ' if modified
    case fileMode
      H_WRITE, H_APPEND:                                                        'write/rewrite/append mode?
        write_block(handle, hEndPtr[handle])                                    'write last block with EndPtr

        sizeLimit := hCircularLength[handle]                                    'get size limit
        head_block_id := hHeadBlockID[handle]                                   'get head ID
        chain_block_id := hChainBlockID[handle]                                 'get fork ID
        chain_block_address := hChainBlockAddr[handle]                          'get fork block
        chainState := chain_block_id == head_block_id ? B_HEAD : B_BODY         'get fork block state

        flash_activate_block(chain_block_address, hChainLifeCycle[handle])      'replace old head block if rewrite or old last block if append

        if fileMode & H_FORK                                                      'if rewrite/append..
          delete_chain_from_id(chain_block_id, 0, 0, True)                      '..delete old fork block through end of file, keeping first ID valid

        field[BlockState][chain_block_address] := chainState                    'change new fork block status from sTEMP to sHEAD/sBODY
        field[IDToBlock][chain_block_id] := chain_block_address                 'update IDToBlock to point to new fork block

        if sizeLimit                                                            'if size limit non-zero..
          froncate_file(head_block_id, sizeLimit)                               '..froncate file to size limit

      H_OVERWRITE:                                                              'modify mode?
        rewrite_block(handle)                                                   '..rewrite block

  hSeekPtr[handle] := NOT_ENABLED                                               ' Ensure seek mode is disabled for this handle
  hSeekFileOffset[handle] := 0                                                  ' reset user requested postion within file
  hChainBlockID[handle] := 0                                                    ' Clear commit-chain info
  hChainBlockAddr[handle] := 0
  hChainLifeCycle[handle] := 0
  hWriteCount[handle] := 0                                                      ' reset write count, all written
  hCircularLength[handle] := 0                                                  ' Ensure circular mode is disabled for this handle
  hHeadBlockID[handle] := NOT_VALID                                             ' clear association with external file

  fsFreeHndlCt++                                                                'show that handle is now avail
  hStatus[handle]~                                                              'show no file-mode associated


PRI start_write(handle, fileMode, headBlockID, HeadCycle)

' configure file for H_WRITE or H_APPEND
'
' @param handle -
' @param fileMode -
' @param headBlockID -
' @param HeadCycle -

  build_head_block(buffer_pointer(handle), filename_pointer(handle), headBlockID) 'build head block in buffer

  hStatus[handle] := fileMode             'set status
  hHeadBlockID[handle] := headBlockID             'set head block ID
  hChainBlockID[handle] := headBlockID             'set fork block ID to head block ID
  hChainLifeCycle[handle] := HeadCycle           'set fork cycle to head cycle
  hEndPtr[handle] := $088             'point to first byte in head block


PRI start_modify(handle, fileMode, headBlockID, Location) | block_id, pBuff

' configure file for H_APPEND or H_OVERWRITE
'
' @param handle -
' @param fileMode -
' @param headBlockID -
' @param Location -

' Local Variables:
' @local block_id -
' @local pBuff -

  block_id, hEndPtr[handle], hSeekFileOffset[handle] := locate_file_byte(headBlockID, Location)  'locate block and block pointer by Location

  pBuff := buffer_pointer(handle)             'get block buffer pointer
  flash_read_block_id(block_id, pBuff, $000, $FFF)          'read located block into buffer

  hStatus[handle] := fileMode             'set status
  hHeadBlockID[handle] := headBlockID             'set head block ID
  hChainBlockID[handle] := block_id                 'set fork block ID to located block ID
  hChainLifeCycle[handle] := next_active_cycle(long[pBuff].[7..5])   'set fork cycle to next cycle of located block


PRI build_head_block(pBuff, pFilename, headBlockID)

' initialize empty block with control information
'
' @param pBuff - address of block in RAM
' @param pFilename - address of zstring containing the filename of this file
' @param headBlockID - the head block id for this new file

  bytefill(pBuff, $FF, BLOCK_SIZE)          'erase block buffer to build new head block
  long[pBuff].[1..0] := %00             'set head/last
  long[pBuff].[19..8] := headBlockID             'set head block ID
  long[pBuff][1].[11..0] := $000            'clear data offset
  long[pBuff][1].[31..12] := filename_crc(pFilename) 'set filename CRC
  strcopy(pBuff + $008, pFilename, FILENAME_SIZE - 1)   'set filename


PRI write_block(handle, NextID_EndPtr) | pBuff, block_id, block_address

' ...
'
' @param handle -
' @param NextID_EndPtr -

' Local Variables:
' @local pBuff -
' @local block_id -
' @local block_address -

  pBuff := buffer_pointer(handle)             'get block buffer pointer
  long[pBuff].[31..20] := NextID_EndPtr         'set NextID/EndPtr
  block_id := long[pBuff].[19..8]             'get block ID of block

  block_address := next_block_address()                'get a new block (may alter IDToBlock)

  if block_id == hChainBlockID[handle]              'if this is the fork block
    flash_program_block(block_address, pBuff, hChainLifeCycle[handle])   '..program block with fork cycle
    hChainBlockAddr[handle] := block_address          '..remember the block so that it can be activated on close
  else                          'else, this is a body block
    flash_program_block(block_address, pBuff, %011)         '..program body block with new cycle
    flash_activate_block(block_address, %011)           '..activate block
    field[IDToBlock][block_id] := block_address            '..set IDToBlock
    field[BlockState][block_address] := B_BODY        '..change block state from sTEMP to sBODY


PRI rewrite_block(handle) | pBuff, block_id, block_address, oldBlockAddress

  pBuff := buffer_pointer(handle)             'get block buffer pointer
  block_id := long[pBuff].[19..8]             'get block ID

  block_address := next_block_address()                'get a new block (may alter IDToBlock)
  flash_program_updated_block(block_address, pBuff)          'program updated block

  oldBlockAddress := field[IDToBlock][block_id]\block_address     'get the old block and update IDToBlock to new block
  flash_cancel_block(oldBlockAddress)                 'cancel the old block

  field[BlockState][block_address] := field[BlockState][oldBlockAddress]\B_FREE  'copy old block state to new and free old


PRI froncate_file(headBlockID, SizeLimit) | Size, block_address, block_id, block_offset, signature, Mode

  Size := count_file_bytes_id(headBlockID)                    'get size of file

  if Size > SizeLimit                           'if file is oversize..

    block_address := next_block_address()                      'get a new block now (may alter tmpBlockBuffer and IDToBlock)

    flash_read_block_id(headBlockID, @tmpBlockBuffer, $000, $087)           'read head block, minus data area
    bytefill(@tmpBlockBuffer + $088, $FF, $FFC - $088)           'clear data area

    block_id, block_offset, _ := locate_file_byte(headBlockID, Size - SizeLimit)     'find block with start of data (might be head block)
    flash_read_block_id(block_id, @signature, $000, $003)              'get data block header

    if block_offset >= $088                         'if data can tuck into head block..
      tmpBlockBuffer.[0] := signature.[0]                   '..copy more/last bit from data block
      tmpBlockBuffer.long.[31..20] := signature.[31..20]            '..copy NextID/EndPtr from data block
      tmpBlockBuffer.long[1].[11..0] := block_offset - $088          '..set data offset to point within head block
      flash_read_block_id(block_id, @tmpBlockBuffer + block_offset, block_offset, $FFB)      '..overlay data bytes into head block buffer
      Mode := 1                             '..delete old head block through data block
    else                                'if data can't tuck into head block..
      tmpBlockBuffer.long.[31..20] := signature.[19..8]             '..link head block to data block
      tmpBlockBuffer.long[1].[11..0] := $FFC - $088 + block_offset - $004    '..set data offset to point within linked data block
      Mode := 2                             '..delete old head block to before data block

    flash_program_updated_block(block_address, @tmpBlockBuffer)               'program updated block

    delete_chain_from_id(headBlockID, signature.[19..8], Mode, True)       'delete old head block through or before data block, keep first block ID valid

    field[IDToBlock][headBlockID] := block_address                'point IDToBlock to new head block
    field[BlockState][block_address] := B_HEAD                'change state of new head block from sTEMP to sHEAD


PRI truncate_file(headBlockID, SizeLimit) | block_address, block_id, block_offset

  if count_file_bytes_id(headBlockID) > SizeLimit                 'if file is oversize..

    block_address := next_block_address()                      'get a new block now (may alter tmpBlockBuffer and IDToBlock)

    block_id, block_offset, _ := locate_file_byte(headBlockID, SizeLimit)        'find block with new last byte (might be head block)
    flash_read_block_id(block_id, @tmpBlockBuffer, $000, block_offset - 1)           'read block, minus excess data area
    bytefill(@tmpBlockBuffer + block_offset, $FF, $FFC - block_offset)       'clear excess data area
    tmpBlockBuffer.[0] := 0                          'make into last block
    tmpBlockBuffer.long.[31..20] := block_offset                 'set EndPtr
    flash_program_updated_block(block_address, @tmpBlockBuffer)               'program updated last block

    delete_chain_from_id(block_id, 0, 0, True)                   'delete old block through end of file, keep first block ID valid

    field[IDToBlock][block_id] := block_address                    'point IDToBlock to new last block
    field[BlockState][block_address] := tmpBlockBuffer.[1] ? B_BODY : B_HEAD    'change state of new last block from sTEMP to sHEAD/sBODY



PRI get_file_head_signature(p_filename) : foundSignature | tmpFilenameCRC, block_address, signature[2], bIsOldFmt

' Look up file by name and return the block state bits of the files' head block (or 0 if file not found)
'
' @param p_filename - address of a zstring containing the filename
' @returns foundSignature - the block state bits of the head block (or 0 if file not found)

' Local Variables:
' @local tmpFilenameCRC - a temp integer holding a CRC19 filename CRC
' @local block_address - the block offset within the file system
' @local signature[2] - a temp buffer for the block's signature and filename CRC
' @local bIsOldFmt - a temp boolean indicating we have an old format header block (filename CRC is CRC32)

  tmpFilenameCRC := filename_crc(p_filename)             'get CRC of filename

  repeat BLOCKS with block_address              'scan head blocks for filename
    if field[BlockState][block_address] == B_HEAD        'if this is a head block..
      flash_read_block_addr(block_address, @signature, $000, $007)         '..read first two longs of block
      if signature[1].[31..12] == tmpFilenameCRC          'if the filename CRC matches..
        ' have new format file head
        flash_read_block_addr(block_address, @tmpBlockBuffer, $008, $087)        '..read whole filename for comparison
        if strcomp(p_filename, @tmpBlockBuffer)       'if filename matches..
          return signature                     '..return first long of block (always non-zero or logically TRUE)
      else
        ' see if old format (crc32 vs crc19)
        bIsOldFmt := is_old_format_file_head(block_address, @tmpBlockBuffer)
        if bIsOldFmt
          if strcomp(p_filename, @tmpBlockBuffer)       'if filename matches..
            return signature                     '..return first long of block (always non-zero or logically TRUE)


PRI is_old_format_file_head(block_address, pBlockBuffer): oldFormatStatus | fnmCrc32, possOldCRC
  ' return T/F where T means we have an Old-Format crc32 file head block
  '  NOTE: leaves filename in [pBlockBuffer]
  flash_read_block_addr(block_address, @possOldCRC, $004, $007)        '..read whole filename for comparison
  flash_read_block_addr(block_address, pBlockBuffer, $008, $087)        '..read whole filename for comparison
  ' this is the prior version 32-bit crc for filenames
  fnmCrc32 := getcrc(pBlockBuffer, $AD0424F3 rev 31, strsize(pBlockBuffer)+1)   'compute CRC of filename
  oldFormatStatus := possOldCRC == fnmCrc32


PRI is_file_open(p_filename, mode_bits) : result | handle

' Return true if named file is open
'
' @param p_filename - address of a zstring containing the filename
' @param mode_bits - some combiantion of H_READ, H_WRITE, and H_REPLACE
' @returns status - T/F where T means the file is open

' Local Variables:
' @local handle - temporary handle to check for availability

  repeat handle from 0 to MAX_FILES_OPEN - 1                                    'for each handle is already open?
    if hStatus[handle] & mode_bits
      if strcomp(@hFilename + handle * FILENAME_SIZE, p_filename)
        return true
{
      else
        debug("is_open() no filename match ", zstr_(p_filename), " vs ", zstr_(@hFilename + handle * FILENAME_SIZE))
    else
      debug("is_open() no mode match ", uhex_byte(hStatus[handle], mode_bits))
'}

PRI new_handle(p_filename) : handle | possible_handle

' Calculate and return next available handle
'
' @returns handle - the next available handle, or
' .. E_NO_HANDLE if no handle is available

' Local Variables:
' @local possible_handle - temporary handle to check for availability

  handle := E_NO_HANDLE                                                         'if no handle is available... return this
  repeat possible_handle from 0 to MAX_FILES_OPEN - 1                           'find first free handle
    ifnot hStatus[possible_handle]                                              'if handle not in use
      handle := possible_handle                                                 '..select as handle to use
      fsFreeHndlCt--
      quit                                                                      '..exit loop, we have our answer

  'debug("new_handle() = ", sdec(handle))
  if handle < 0                                                                 'if error, set error code
    LONG[@errorCode][cogid()] := handle
  else
    'record the filename for this handle
    ' NOTE this buffer is $00-filled while in our blocks they are $FF-filled
    bytefill(@hFilename + handle * FILENAME_SIZE, 0, FILENAME_SIZE)               ' empty filename buffer
    strcopy(@hFilename + handle * FILENAME_SIZE, p_filename, FILENAME_SIZE - 1)   ' copy new filename into buffer


PRI filename_crc(p_filename) : filenameCRC

' Return the CRC19 value calculated for the filename zstring
'
' @param p_filename - address of the filename zstring
' @returns filenameCRC - the calculated CRC value

  filenameCRC := getcrc(p_filename, $B5827 rev 19, strsize(p_filename))   'compute CRC of filename


PRI offset_head_block(start_block_address, offset_in_blocks) : head_block_address | signature, nextBlockId

' locate the address of the block offset into the chain
'  (of offset_in_blocks == 0 just return address of start_block_address)
'
' @param start_block_address - the block address of the first block in the chain
' @param offset_in_blocks - the number of blocks to skip head block is first after skipped blocks
' @returns head_block_address - return the block address of the proposed head block

' Local Variables:
' @local signature - the block state bits of the block being checked
' @local nextBlockId - the id next possible head block

' hrmf error conditions, (1) not a valid block, or (2) found a tail block
'  both of these are unexpected, so we'll ???

  'debug("offset_head_block(", uhex_word(start_block_address), ", ", sdec(offset_in_blocks), ")")

  head_block_address := start_block_address
  if offset_in_blocks > 0
    repeat
        flash_read_block_addr(head_block_address, @signature, $000, $003)             'read the block into the buffer
        ifnot signature.[0]                                                     ' if last block, exit loop
            quit
        nextBlockId := signature.[31..20]                                       '..no, get ID of next block
        head_block_address := field[IDToBlock][nextBlockId]                     'get address of block
        'debug("  -- ", uhex_word(head_block_address), "( id#", udec_(nextBlockId), " )")
        if --offset_in_blocks <= 0                                              'count this, abort loop if have answer
            quit

  'debug("offset_head_block() = ", uhex_word(head_block_address))


PRI check_block_read_only(thisBlockAddress): cancel_count | otherBlockAddress, thisCycleBits, otherCycleBits, thisBlockID

' If there is more than one block with this blocks ID, cancel the older block
'
' @param thisBlockAddress - the block offset within the file system for "this" block

' Local Variables:
' @local otherBlockAddress -the block offset within the file system for the "other" block
' @local thisCycleBits - the lifecycle bits of "this" block
' @local otherCycleBits - the lifecycle bits of the "other" block
' @local thisBlockID - the blockID of "this" block

  flash_read_block_addr(thisBlockAddress, @thisCycleBits, $000, $000)           'read first byte of block

  ifnot lookdown(thisCycleBits.[7..5]: %011, %101, %110)                        'is block canceled or inactive?
    return                                                                      '..if so, block status remains B_FREE, done

  flash_read_block_addr(thisBlockAddress, @tmpBlockBuffer, $000, $FFF)          'read entire block

  if LONG[@tmpBlockBuffer + $FFC] <> block_crc(@tmpBlockBuffer)                 'is CRC bad?
    cancel_count++                                     '..if so, indicate we would modify a block
    return                                                                      '..block status remains B_FREE, done

  thisBlockID := tmpBlockBuffer.LONG.[19..8]                                    'this block is good, get its ID

  ifnot field[IDValid][thisBlockID]~~                                           'set ID flag and if it wasn't already set.. (after test, bit := 1)
    field[IDToBlock][thisBlockID] := thisBlockAddress                           '..set IDToBlock to this block
    field[BlockState][thisBlockAddress] := B_TEMP                               '..set B_TEMP status for this block
    return                                                                      '..done

  otherBlockAddress := field[IDToBlock][thisBlockID]                            'ID flag was already set, get other block with same ID

  flash_read_block_addr(otherBlockAddress, @otherCycleBits, $000, $000)         'read first byte of other block

  if lookdown(thisCycleBits.[7..5] << 3 | otherCycleBits.[7..5]: %011_110, %101_011, %110_101)  'if this block is newer..
    field[IDToBlock][thisBlockID] := thisBlockAddress                           '..set IDToBlock to this block
    field[BlockState][thisBlockAddress] := B_TEMP                               '..set B_TEMP status for this block
    field[BlockState][otherBlockAddress] := B_FREE                              '..set B_FREE status for other block
    cancel_count++                                                              '..would cancel other block
  else
    cancel_count++                                                              'else, would cancel this block, block status remains B_FREE


PRI check_block_fix_dupe_id(thisBlockAddress) | otherBlockAddress, thisCycleBits, otherCycleBits, thisBlockID

' If there is more than one block with this blocks ID, cancel the older block
'
' @param thisBlockAddress - the block offset within the file system for "this" block

' Local Variables:
' @local otherBlockAddress -the block offset within the file system for the "other" block
' @local thisCycleBits - the lifecycle bits of "this" block
' @local otherCycleBits - the lifecycle bits of the "other" block
' @local thisBlockID - the blockID of "this" block

  flash_read_block_addr(thisBlockAddress, @thisCycleBits, $000, $000)           'read first byte of block

  ifnot lookdown(thisCycleBits.[7..5]: %011, %101, %110)                        'is block canceled or inactive?
    return                                                                      '..if so, block status remains B_FREE, done

  flash_read_block_addr(thisBlockAddress, @tmpBlockBuffer, $000, $FFF)          'read entire block

  if LONG[@tmpBlockBuffer + $FFC] <> block_crc(@tmpBlockBuffer)                 'is CRC bad?
    flash_cancel_block(thisBlockAddress)                                        '..if so, cancel block to inhibit future CRC checks
    return                                                                      '..block status remains B_FREE, done

  thisBlockID := tmpBlockBuffer.LONG.[19..8]                                    'this block is good, get its ID

  ifnot field[IDValid][thisBlockID]~~                                           'set ID flag and if it wasn't already set.. (after test, bit := 1)
    field[IDToBlock][thisBlockID] := thisBlockAddress                           '..set IDToBlock to this block
    field[BlockState][thisBlockAddress] := B_TEMP                               '..set B_TEMP status for this block
    return                                                                      '..done

  otherBlockAddress := field[IDToBlock][thisBlockID]                            'ID flag was already set, get other block with same ID

  flash_read_block_addr(otherBlockAddress, @otherCycleBits, $000, $000)         'read first byte of other block

  if lookdown(thisCycleBits.[7..5] << 3 | otherCycleBits.[7..5]: %011_110, %101_011, %110_101)  'if this block is newer..
    field[IDToBlock][thisBlockID] := thisBlockAddress                           '..set IDToBlock to this block
    field[BlockState][thisBlockAddress] := B_TEMP                               '..set B_TEMP status for this block
    field[BlockState][otherBlockAddress] := B_FREE                              '..set B_FREE status for other block
    flash_cancel_block(otherBlockAddress)                                       '..cancel other block
  else
    flash_cancel_block(thisBlockAddress)                                        'else, cancel this block, block status remains B_FREE


PRI count_file_bytes(block_address) : bytes_used, bytes_free, block_count | signature

' Return information about a file: blocks allocated, bytes used, bytes free
'
' @param block_address - the offset within the file system of the first block of the file
' @returns bytes_used - the number of bytes written to file
' @returns bytes_free - the number of bytes allocated but not yet written (in the last block)
' @returns block_count - the number of blocks allocation to this file

' Local Variables:
' @local signature - the block state bits of the block being counted

  if block_address <> NOT_VALID
    repeat                                                                        'trace blocks to count file bytes
        flash_read_block_addr(block_address, @signature, $000, $003)                     'read the first long of the head/body block
        block_count++
        case signature.[1..0]
            %00:                                                                      'head/last
                bytes_used := signature.[31..20] - $088
                bytes_free := $FFC - signature.[31..20]
                return
            %01:                                                                      'head/more
                bytes_used := $FFC - $088
            %10:                                                                      'body/last
                bytes_used += signature.[31..20] - $004
                bytes_free := $FFC - signature.[31..20]
                return
            %11:                                                                      'body/more
                bytes_used += $FFC - $004
        block_address := field[IDToBlock][signature.[31..20]]                       'get next block to count


PRI count_file_bytes_id(block_id) : byteCount

  _, _, byteCount := locate_file_byte(block_id, $FFFFFF)    'locate end-of-file by using impossibly large location (16MB)


PRI locate_file_byte(block_id, fileOfs) : rID, rBlockOfs, rLocation | dataOffset, signature, currOfs, srtOfs, endOfs, fnmCrc32, bIsOldFmt

' locate position (file_offset) within file list of blocks
'
' @param block_id - the block id of the file head
' @param fileOfs - the byte offset from the beginning of the file
' @returns rID - the block id of the block containing the desired location
' @returns rBlockOfs - the offset into the block containing the desired location
' @returns rLocation - the location within the entire file

' Local Variables:
' @local dataOffset - temp integer containing the initial data offset
' @local signature - temp long containing the block signature bits
' @local currOfs - temp integer containing offset as we work are way thru the file
' @local srtOfs - start of data in block
' @local endOfs - end of data in block
' @local fnmCrc32 - old CRC32 value filename CRC
' @local bIsOldFmt - temp boolean T/F where T means this is old style file head with crc32 NOT dataOffset

  fileOfs := fileOfs #> 0 <# $FFFFFF          'limit offset into file from 0 to 16MB

  ' we are in HEAD block see if we are old format CRC32 block
  bIsOldFmt := is_old_format_file_head(field[IDToBlock][block_id], @tmpBlockBuffer)
  if not bIsOldFmt
    ' have new format file head
    flash_read_block_id(block_id, @dataOffset, $004, $005)        'read the data offset in the head block
    currOfs -= dataOffset.[11..0]                 'subtract it from the initial position of zero

  repeat                        'trace blocks to count file bytes
    flash_read_block_id(block_id, @signature, $000, $003)      'read block header
    srtOfs := signature.[1] ? $004 : $088         'body or head?
    endOfs := signature.[0] ? $FFC : signature.[31..20]      'more or last?
    'debug("* size ", udec(block_id, Bot, Top, currOfs))
    if fileOfs >= currOfs and fileOfs < currOfs + endOfs - srtOfs   'if location is within block..
      'debug("  size ", udec(block_id, Location - currOfs + Bot, Location))
      return block_id, fileOfs - currOfs + srtOfs, fileOfs     '..return block block ID, offset into block, and target location
    currOfs += endOfs - srtOfs                    'not within block, advance position to next block
    ifnot signature.[0]                    'if last block..
      'debug("  size ", udec(block_id, Top, currOfs))
      return block_id, endOfs, currOfs               '..return block ID, offset into block, and end-of-file location
    block_id := signature.[31..20]               'get next block ID


PRI trace_file_set_flags(block_address, set) : valid | signature, block_id

' Trace file chain marking (or clearing) block states until end of file is reached (or an error in block sequence is found)
'
' @param block_address - the block offset within the file system for the block to trace
' @param set - true to set block states to B_HEAD/B_BODY, false to set block states to B_TEMP
' @returns valid - true if file is valid, false if file is invalid

' Local Variables:
' @local signature - block state bits of block being checked
' @local block_id - the blockID of the block being checked
  valid := false
  'if set
  '    debug("tfsf() - ENTRY set")
  'else
  '    debug("tfsf() - ENTRY clear")
  flash_read_block_addr(block_address, @signature, $000, $003)                       'read first long of initial block
  field[BlockState][block_address] := set ? B_HEAD : B_TEMP                     'set first block state to (set-pass: B_HEAD or clear-pass: B_TEMP)

  repeat BLOCKS                                                                 'limit repeat to BLOCKS in order to return false on endless loop
    ifnot signature.[0]                                                         'if last block, file is complete, return true
      'debug("tfsf() - OK complete file")
      return true
    block_id := signature.[31..20]                                              'get "next" ID from this full block
    ifnot field[IDValid][block_id]                                              'if ID invalid (bit == 0), error!, return false
      'debug("tfsf() - BAD next ID is bad")
      return
    block_address := field[IDToBlock][block_id]                                 'get address of block having this ID
    flash_read_block_addr(block_address, @signature, $000, $003)                     'read first long of "next" block
    ifnot signature.[1]                                                         'if "next" is head block, error!, return false
      'debug("tfsf() - BAD head within file")
      return
    field[BlockState][block_address] := set ? B_BODY : B_TEMP                   'set block state to (set-pass: B_BODY or clear-pass: B_TEMP)
  'debug("tfsf() - EXIT at end: out of blocks?!")


PRI filename_pointer(handle) : p_filename

' Return pointer to filename for this handle
'
' @param handle - a handle to an open file
' @returns p_filename - address of zstr filename associated with this handle

  return @hFilename + handle << FILENAME_SIZE_EXP   'get filename pointer by handle


PRI buffer_pointer(handle) : p_buffer

' Return a pointer to the block buffer for this handle
'
' @param handle - a handle to an open file
' @returns p_buffer -  the address of the 4KB buffer associated with this handle

  return @hBlockBuff + handle << BLOCK_SIZE_EXP




DAT ' data for final commit operation

blocksInCommitChain LONG    0
bytesInOrigFile     LONG    0
blocksInOrigFile    LONG    0
hdBlockId           LONG    0
handleCircular      LONG    0
keepBlocks          LONG    0
bytesInTailBlock    LONG    0
bytesLinear         LONG    0


PRI ensure_handle_mode(handle, mode_bits) : status

' Determine if handle is open with dedired mode
'
' @param handle - handle to a file that might be open for read or read/write
' @param mode_bits - some combiantion of H_READ, H_WRITE, and H_REPLACE
' @returns status - 0 (SUCCESS) if successful,
' .. E_BAD_HANDLE if the handle is not valid,
' .. E_FILE_MODE if the file is not open in desired mode,

  if handle < 0 or handle > MAX_FILES_OPEN - 1
    status := E_BAD_HANDLE
  elseif hStatus[handle] & mode_bits
    status :=  SUCCESS
  else
    status :=  E_FILE_MODE



PRI delete_chain_from_id(block_id, EndID, Mode, KeepFirstIDValid) | block_address, signature
' remove selecte part of a file chain
'
' @param block_id - starting block id
' @param EndID - ending block id
' @param Mode - do we delete through end or up to EndID (or including EndID)
' @param KeepFirstIDValid - T/F where T means don't invalidate first block

' Local Variables:
' @local block_address - temporary block address
' @local signature - temporary block signature

' Mode  Deletes to...
'---------------------------------
' 0 last block (EndID ignored)
' 1 block whose ThisID = EndID
' 2 block whose NextID = EndID

  repeat                        'trace block chain and cancel IDs, block states, and blocks
    ifnot KeepFirstIDValid~             'keep first block block ID valid?
      field[IDValid][block_id]~               'clear block ID valid flag
    block_address := field[IDToBlock][block_id]           'translate block ID to block
    field[BlockState][block_address] := B_FREE           'set block state to sFREE
    flash_cancel_block(block_address)                  'cancel block
    flash_read_block_addr(block_address, @signature, $000, $003)       'read block header
    block_id := signature.[31..20]               'get block ID of next block
  while lookupz(Mode: signature.[0],       ... 'mode 0: delete to last block
              signature.[19..8] <> EndID,  ... 'mode 1: delete to ThisID = EndID
              block_id <> EndID)          'mode 2: delete to NextID = EndID


PRI next_active_cycle(cycleIn) : cycleOut

' Calculate and return the next active lifecycle pattern in (3 -> 5 -> 6 -> 3 -> 5 -> 6 -> 3... pattern)
'
' @param cycleIn - current lifecycle pattern
' @returns cycleOut - next lifecycle pattern in sequence

  cycleOut := (cycleIn * %001_001) >> 1 & %111          'get next lifecycle pattern


PRI block_crc(p_block_buffer) : crc
' Calculate and return the CRC for this pointed to block
'
' @param p_block_buffer - the address of the 4KB buffer for the file associated with this handle
' @returns crc - the calculated CRC for the block

  return getcrc(p_block_buffer, $AD0424F3 rev 31, BLOCK_SIZE - 4)  'compute CRC of a buffered block


PRI size_in_blocks(size_in_bytes) : block_count | remainingSize, overflowBodyCount

' Return number of blocks for given file size
'
' @param size_in_bytes - the number of bytes in the file
' @returns block_count - the number of blocks that would be needed to contain the file

' Local Variables:
' @local remainingSize - temporary variable to hold the number of bytes remaining after the head block
' @local overflowBodyCount - temporary variable to hold the number of bytes that will be in the tail block

    block_count := 1
    if size_in_bytes > BYTES_IN_HEAD_BLOCK
        remainingSize := size_in_bytes - BYTES_IN_HEAD_BLOCK
        block_count += remainingSize / BYTES_IN_BODY_BLOCK
        overflowBodyCount := remainingSize +// BYTES_IN_BODY_BLOCK
        if overflowBodyCount > 0
            block_count++
    'debug("size_in_blocks()  # bytes: ", udec_(size_in_bytes), ", blocks: ", udec_(block_count))


PRI blocks_free() : count | block_address

' Return the count of available blocks
'
' @returns count - the number of filesystem blocks that are not in use

' Local Variables:
' @local block_address - the block offset within the file system

  repeat block_address from 0 to BLOCKS - 1                                     ' count free blocks
    ifnot field[BlockState][block_address]                                  'if the block is B_FREE
        count++


PRI next_available_block_id() : block_id | possible_block_id

' Get a next available block ID
'
' @returns block_id - the next ID that is not in use (or E_DRIVE_FULL if no blockID's are available)

' Local Variables:
' @local possible_block_id - prospective blockID to check for availability

  block_id := E_DRIVE_FULL                              ' preset error
  repeat BLOCKS with possible_block_id                  ' pick the first free block ID
    ifnot field[IDValid][possible_block_id]~~           ' set IDValid, was IDValid previously clear? (after test, bit := 1)
        block_id := possible_block_id                   ' if IDValid was clear, return new ID
        quit

  if block_id < 0                                       ' if error, set error code
    LONG[@errorCode][cogid()] := block_id


PRI available_blocks() : bool | blk8Idx

' Return true if there are any available blocks
'
' @returns bool - true/false where true means blocks are available for write

' Local Variables:
' @local blk8Idx - index into the blocks allocated array

    'debug("available_blocks() ENTRY")
    bool := false
    ' TODO: if field[IDValids] ever has extra bits at end this code won't work!
    repeat blk8Idx from 0 to FLAGS_SIZE - 1
        if BYTE[@IDValids][blk8Idx] <> $FF
            bool := true
            quit
    'debug("available_blocks() EXIT")


PRI next_block_address() : block_address | blockFreeCount, freeBlockAddress, freeIndex, next_cycle_bits

' Return the address of the next block to which we should write
'
' @returns block_address - E_DRIVE_FULL if no free block is available, otherwise the address of the next block to use

' Local Variables:
' @local blockFreeCount - the count of free blocks
' @local freeBlockAddress - the offset within the file system of the free block
' @local freeIndex - a counter of free blocks
' @local next_cycle_bits - the next lifecycle bits to use for the new block

  ifnot blockFreeCount := blocks_free()                                         'if no free block exists, abort with error
        return (LONG[@errorCode][cogid()] := E_DRIVE_FULL)

  repeat                                                                        'randomly pick an B_FREE/B_HEAD/B_BODY (not an B_TEMP) block
        block_address := abs getrnd() // BLOCKS                                 '(random block selection results in +-5% wear leveling)
  until field[BlockState][block_address] <> B_TEMP

  ifnot field[BlockState][block_address]  == B_FREE                             'if the block is B_FREE, change its state to B_TEMP and exit
        field[BlockState][block_address] := B_TEMP
        return

  ' now we are using head or body so we have to move it!
  freeIndex := abs getrnd() // blockFreeCount                                   'randomly pick an B_FREE block to move the B_HEAD/B_BODY block to
  repeat BLOCKS with freeBlockAddress                                           'block is sHEAD/sBODY, must relocate it to an sFREE block
        ifnot field[BlockState][freeBlockAddress]                               'if the block is B_FREE
          ifnot freeIndex--
            quit

  ' evict this block!
  flash_read_block_addr(block_address, @tmpBlockBuffer, $000, $FFF)             'read the B_HEAD/B_BODY block
  next_cycle_bits := next_active_cycle(tmpBlockBuffer.[7..5])                   'advance its lifecycle
  flash_program_block(freeBlockAddress, @tmpBlockBuffer, next_cycle_bits)       'program the B_FREE block with the B_HEAD/B_BODY data
  flash_activate_block(freeBlockAddress, next_cycle_bits)                       'activate the B_FREE block, now superior to the original block
  flash_cancel_block(block_address)                                             'cancel the original block to complete the move

  field[IDToBlock][tmpBlockBuffer.LONG.[19..8]] := freeBlockAddress             'update IDToBlock table
  field[BlockState][freeBlockAddress] := field[BlockState][block_address]\B_TEMP  'update blocks' states, new block is B_TEMP


PRI setup_semaphore() : status

' first called allocates lock if avail, subsequent just wait for allocation to complete
'
' @returns status - returns E_NO_LOCK_AVAIL if can't acquire semaphore, otherwise SUCCESS

    if fsLock == -1
        'debug("setupSemaphore() ENTRY")
        ifnot can_acquire_lock()
            ' i was NOT first so I just wait
            'debug("! didn't win, waiting...")
            repeat
                if fsLock <> -1                                                 ' I'm not allocating, just wait until is allocated
                    quit
            'debug("! done waiting")
        else
            'debug("! DID WIN, installing lock")
            ' i was the first to mount this thing
            fsLock := locknew()                                                 'I'm allocating... reserve a lock for driver use
            'debug("! ", sdec(fsLock))
            if(fsLock < 0)                                                      'if lock allocation failed
                'debug("EEE failed to allocate lock")
                status := (LONG[@errorCode][cogid()] := E_NO_LOCK_AVAIL)        '..return error
    'else
    '   debug("setupLock() abort, already set up")

PRI can_acquire_lock() : bItsMe | myCogId, tmpCogId, lowestValue, lowestID

' determine if first or subsequent caller
'
' @returns bItsMe - T/F where True means is first caller and therefore should acquire lock

' Local Variables:
' @local myCogId - hold codID of caller
' @local tmpCogId - tmep cogID for iteration
' @local lowestValue - lowest tic count
' @local lowestID - cogID with lowest tic count

    lowestValue := $7fff_ffff   ' max signed long value
    bItsMe := false
    if fsLock == -1
        myCogId := cogid()                                                      ' get our cog ID
        LONG[@fsCogCts][myCogId] := getct()                                     ' set our cog timer value
        waitms(10)                                                              'let any other cogs get in here too
        repeat tmpCogId from 0 to 8-1                                           ' now scan to see if we win!
            ' determine cog id of earliest cog that tried to start the filesystem
            if LONG[@fsCogCts][tmpCogId] < lowestValue
                lowestValue := LONG[@fsCogCts][tmpCogId]
                lowestID := tmpCogId
        ' if we were earliest, we get to allocate the lock and mount
        'debug("acquire_lock_and_mount() ", udec(lowestValue, lowestID, myCogId))
        bItsMe := lowestID == myCogId ? true : false


CON ' --- Flash Operations ---

PRI flash_read_block_id(block_id, p_buffer, firstByte, lastByte)

' Return byte(s) read from physical block into memory at p_buffer
'
' @param block_id - the ID of block within the file system
' @param p_buffer - memory location in which to place the data
' @param firstByte - address of first byte to read
' @param lastByte - address of last byte to read

  flash_read_block_addr(field[IDToBlock][block_id], p_buffer, firstByte, lastByte)


PRI flash_read_block_addr(block_address, p_buffer, firstByte, lastByte)

' Return byte(s) read from physical block into memory at p_buffer
'
' @param block_address - the block offset within the file system
' @param p_buffer - memory location in which to place the data
' @param firstByte - address of first byte to read
' @param lastByte - address of last byte to read

  'debug("* rb(", uhex_word_(block_address), ", ", uhex_word_(firstByte), ", ", uhex_word_(lastByte),")")
  flash_command($03 | (FIRST_BLOCK + block_address) << 20 | firstByte << 8, 4)  'read 4KB block
  flash_receive(p_buffer, lastByte - firstByte + 1)                        'receive block data


PRI flash_program_updated_block(block_address, pBuff) | nextCycleBits
' Write block in memory at block_address to physical block with updated life-cycle bits
'
' @param block_address - the block offset within the file system
' @param pBuff - memory location from which to get the data

' Local Variables:
' @local nextCycleBits - updated lifeCycle bit-pattern to place into block

  nextCycleBits := next_active_cycle(long[pBuff].[7..5])         'get next cycle
  flash_program_block(block_address, pBuff, nextCycleBits)           'program new block to replace old block
  flash_activate_block(block_address, nextCycleBits)             'activate new block


PRI flash_program_block(block_address, p_buffer, cycle_bits) | pageIndex

' Write block in memory at block_address to physical block
'
' @param block_address - the block offset within the file system
' @param p_buffer - memory location from which to get the data
' @param cycle_bits - lifeCycle bit-pattern to place into block

' Local Variables:
' @local pageIndex - index [0-15] of 256-Byte page within 4KB block

  flash_command($06, 1)                                                         'enable write
  flash_command($20 | (FIRST_BLOCK + block_address) << 20, 4)                   'erase 4KB block

  BYTE[p_buffer].[7..5] := cycle_bits                                           'install lifecycle for CRC computation
  LONG[p_buffer + $FFC] := block_crc(p_buffer)                                  'compute and install CRC
  BYTE[p_buffer].[7..5]~~                                                       'remove lifecycle (:= %111), block will be inactive until activated

  flash_wait()                                                                  'wait for erasure to complete (~45ms)

  repeat 16 with pageIndex                                                      'program 16 pages within 4KB block
    flash_command($06, 1)                                                                'enable write
    flash_command($02 | (FIRST_BLOCK + block_address) << 20 | pageIndex << 16, 4)        'program
    flash_send(p_buffer + pageIndex << 8, 256)                                           'send 256 bytes
    flash_wait()                                                                                                             'wait for programming to complete (~400us)


PRI flash_activate_block(block_address, cycle_bits)

' Write new activation pattern into block
'
' @param block_address - the block offset within the file system
' @param cycle_bits - lifeCycle bit-pattern to place into block

  flash_program_bit(block_address, cycle_bits << 5 | %00011111)                       'clear one cycle bit to activate block


PRI flash_cancel_block(block_address)

' Clear the block's cycle bits to cancel it
'
' @param block_address - the block offset within the file system

  'debug("* cancel block ", uhex_word(block_address))
  flash_program_bit(block_address, %00011111)                                         'clear all cycle bits to cancel block


PRI flash_program_bit(block_address, bit_pattern)

' Write new bit_pattern into 1st byte of block (this contains the life-cycle bits) this is our most atomic operation
'
' @param block_address - the block offset within the file system
' @param bit_pattern - the value to be placed in first byte of block

  flash_command($06, 1)                                                         'enable write
  flash_command($02 | (FIRST_BLOCK + block_address) << 20, 4)                   'program
  flash_send(@bit_pattern, 1)                                                   'send byte with bit pattern
  flash_wait()                                                                  'wait for programming to complete


PRI flash_wait()| statusBits

' Wait for FLASH Chip to become ready

' Local Variables:
' @local statusBits - status register bits read from FLASH Chip

  repeat
    flash_command($05, 1)                               ' read status register
    flash_receive(@statusBits, 1)
  while statusBits.[0]                                  ' loop until BUSY bit clear

{$flexspin
' flexspin stores local variables in registers, rather than HUB, so for flash commands we need HUB space for temporary storage
VAR
   LONG m_command                             ' HUB storage for flash_command use
}

PRI flash_command(command, count)

' Send flash command to FLASH Chip via SPI
'
' @param command - the command for the chip to execute
' @param count - number of bytes to send: must be between 1 and 4
'
' uses the member variable m_command as temporary storage

              org

              fltl      #SF_MISO                        '2!     DO input

              fltl      #SF_SCLK                        '2!     reset CK smart pin
              wrpin     ##%001000000_01_00101_0,#SF_SCLK '2      set CK for transition output, inverted - SPI mode 3
              wrpin     ##%001000000_00_00000_0,#SF_CS  '2      set CK for transition output, inverted - SPI mode 3
              wxpin     #4,#SF_SCLK                     '2      set timebase to 4 clocks per transition

              drvl      #SF_CS                          '2!     CS high
              waitx     #14                             '2+14   CS deselect is 50ns at 350 MHz (50 / 2.777ns = 18)
              drvh      #SF_CS                          '2!     CS low

              movbyts   command,#%%1230                 'reverse order of post-command address bytes for sending

              end
{$flexspin
#ifdef __FLEXSPIN__
  ' in flexspin we have to copy the register to HUB explicitly (otherwise @command will force command
  ' into HUB, which will conflict with using `command` in the inline assembly code)
  m_command := command                      'copy command from register to HUB memory
  flash_send(@m_command, count)             'send command
#else
}
  flash_send(@command, count)
{$flexspin #endif}

PRI flash_send(p_buffer, count) | tx_byte

' Write bytes to the FLASH Chip via SPI
'
' @param p_buffer - memory location from which to get the data
' @param byteCount - number of bytes to send

' Local Variables:
' @local tx_byte - the byte value being sent over SPI

              org

              rdfast    #0,p_buffer                     'start fast read

.byte         rfbyte    tx_byte                         '2  read byte to send
              shl       tx_byte,#24 + 1         wc      '2  msb-justify bits and get D7 into c

              rep       @.r,#1                          '2  protect from interrupts
              fltl      #SF_SCLK                        '2! reset smart pin CK
              drvl      #SF_SCLK                        '2! start smart pin CK, starts base period
              drvc      #SF_MOSI                        '2! output D7
              wypin     #16,#SF_SCLK                    '2* begin 16 clock transitions
              rep       @.r,#7                          '2  repeat to output D6..D0
              shl       tx_byte,#1              wc      '2    get data bit
              drvc      #SF_MOSI                        '2!   output data bit
              waitx     #2                              '2+2  delay makes 8 clocks/bit
.r
              djnz      count,#.byte                    '4|2 loop if another byte to send

              drvl      #SF_MOSI                        '2! DI low

              end


PRI flash_receive(p_buffer, count) | rx_byte

' Read bytes from the FLASH Chip via SPI
'
' @param p_buffer - memory location into which to put the data
' @param count - number of bytes to receive

' Local Variables:
' @local rx_byte - gather bits received into this byte

              org

              wrfast    #0,p_buffer                     'start fast write

.byte         rep       @.r,#1                          '2   protect from interrupts
              fltl      #SF_SCLK                        '2!     reset smart pin CK
              drvl      #SF_SCLK                        '2!     start smart pin CK, starts base period
              wypin     #16,#SF_SCLK                    '2*     begin 16 clock transitions
              waitx     #7                              '2+3    align TESTP's to before 2nd clock fall (DC..350MHz+)
              rep       @.r,#8                          '2      repeat to input D7..D0
              waitx     #2                              '2+2      delay makes 8 clocks/bit
              testp     #SF_MISO                wc      '2        input data bit
              rcl       rx_byte,#1                      '2        save data bit
.r
              wfbyte    rx_byte                         '2   write received byte
              djnz      count,#.byte                    '4|2 loop if another byte to receive

              drvl      #SF_CS                          '2!  CS high, terminates command
              fltl      #SF_SCLK                        '2!  reset smart pin forcing dir to be correct

              end


'{   ' REMOVE BEFORE FLIGHT: uncomment this line before commit to git, and release!!!

' ----------------------------------------------------------------------------------------------
'   these methods are for regression testing only - they are not used in production code

CON { constants exposed for regression testing }

     MAX_FILE_LEN_IN_BLOCKS = 16 ' not real, just our limit for passing data back to UT's

DAT { regression testing buffers and such }

   blockForUser     BYTE    0[4096]
   signatures       LONG    0[MAX_FILE_LEN_IN_BLOCKS]


CON { methods supporting regression testing }


PUB TEST_count_file_bytes(p_filename) : bytes_used, bytes_free, block_count | signature

'' TEST METHOD: return information about a file: blocks allocated, bytes used, bytes free
''  forwarding access to internal method: count_file_bytes()
''
'' @param p_filename - address of a zstring containing the filename
'' @returns bytes_used - the number of bytes written to file, E_FILE_NOT_FOUND if the file doesn't exist
'' @returns bytes_free - the number of bytes allocated but not yet written (in the last block)
'' @returns block_count - the number of blocks allocation to this file

' Local Variables:
' @local signature - the block state bits of the block being counted
  'debug("TEST_count_file_bytes() ENTRY")

  if fsMounted == false
    return (LONG[@errorCode][cogid()] := E_NOT_MOUNTED), 0, 0

  repeat while locktry(fsLock) == 0                                           ' lock for exlusive use

  LONG[@errorCode][cogid()] := SUCCESS
  if signature := get_file_head_signature(p_filename)                           'does file exist?
    'debug("* have signature")
    bytes_used, bytes_free, block_count := count_file_bytes(field[IDToBlock][signature.[19..8]])
  else
    bytes_used := (LONG[@errorCode][cogid()] := E_FILE_NOT_FOUND)
  'debug("TEST_count_file_bytes() EXIT")

  lockrel(fsLock)                                                             ' release the lock, we're done with it


PUB TEST_getHead4kBlock(p_filename) : p_buffer | signature

'' TEST METHOD: Return the named file's head block
''
'' @param p_filename - address of a zstring containing the filename
'' @returns p_buffer - address of a 4KB buffer containing the head block

' Local Variables:
' @local signature - temporary storage for a block signature

    repeat while locktry(fsLock) == 0                                           ' lock for exlusive use

    p_buffer := @blockForUser
    ifnot signature := get_file_head_signature(p_filename)                      'if file doesn't exist...
        return (LONG[@errorCode][cogid()] := E_FILE_NOT_FOUND)
    flash_read_block_addr(field[IDToBlock][signature.[19..8]], @blockForUser, $000, $FFF)   'read head block into buffer

    lockrel(fsLock)                                                             ' release the lock, we're done with it


PUB TEST_getTail4kBlock(p_filename) : p_buffer | signature, block_address

'' TEST METHOD: Return the named file's head block
''
'' @param p_filename - address of a zstring containing the filename
'' @returns p_buffer - address of a 4KB buffer containing the head block

' Local Variables:
' @local signature - temporary storage for a block signature
    repeat while locktry(fsLock) == 0                                           ' lock for exlusive use

    p_buffer := @blockForUser
    ifnot signature := get_file_head_signature(p_filename)                      'if file doesn't exist...
        return (LONG[@errorCode][cogid()] := E_FILE_NOT_FOUND)
     ' locate tail
    block_address := field[IDToBlock][signature.[19..8]]                        'get this block address
    if signature.[0]                                                            ' if not last block, exit loop
        repeat
            ifnot signature.[0]                                                 ' if last block, exit loop
                quit
            block_address := field[IDToBlock][signature.[31..20]]               'get next block address
            flash_read_block_addr(block_address, @signature, $000, $003)             'read the first long of the head/body block

    flash_read_block_addr(block_address, @blockForUser, $000, $FFF)                  'read head block into buffer
    debug("returning: id=", udec_word_(signature.[19..8]), " addr=", uhex_word(block_address))

    lockrel(fsLock)                                                             ' release the lock, we're done with it


PUB TEST_getFileBlockSignatures(p_filename) : p_sigLong, sigCount | signature, block_address

'' TEST METHOD: return the named file's list block signatures for blocks allocated to the file
''
'' @param p_filename - address of a zstring containing the filename
'' @returns p_sigLong - address of a long array containing the block signatures
'' @returns sigCount - the number of signatures in the array

' Local Variables:
' @local signature - temporary storage for a block signature
' @local block_address - the block offset within the file system

    repeat while locktry(fsLock) == 0                                           ' lock for exlusive use

    p_sigLong := @signatures
    ifnot signature := get_file_head_signature(p_filename)                      'if file doesn't exist...
        return 0, 0                                                             '  return 0, 0
    repeat
        LONG[@signatures][sigCount++] := signature                              ' place this signature in list
        ifnot signature.[0]                                                     ' if last block, exit loop
            quit
        if sigCount >= MAX_FILE_LEN_IN_BLOCKS - 1                               ' if filled table, exit loop
            quit
        block_address := field[IDToBlock][signature.[31..20]]                   'get next block address
        flash_read_block_addr(block_address, @signature, $000, $003)                 'read the first long of the head/body block

    lockrel(fsLock)                                                             ' release the lock, we're done with it


PUB TEST_getCommitBlockSignatures(handle) : p_sigLong, sigCount  | signature, block_address, lastSignature, lastBlockId

'' TEST METHOD: Return pending-commit chain signatures
''
'' @param handle - a handle to an open file
'' @returns p_sigLong - address of a long array containing the block signatures
'' @returns sigCount - the number of signatures in the array

' Local Variables:
' @local signature - temporary storage for a block signature
' @local block_address - the block offset within the file system

    if fsMounted == false
        LONG[@errorCode][cogid()] := E_NOT_MOUNTED
        return 0, 0
    elseif handle < 0 or handle > MAX_FILES_OPEN - 1
        LONG[@errorCode][cogid()] := E_BAD_HANDLE
        return 0, 0

    repeat while locktry(fsLock) == 0                                           ' lock for exlusive use

    'debug("TEST_getCommitBlockSignatures() ENTRY")
    p_sigLong := @signatures
    if hChainBlockAddr[handle] == 0
        'debug("TEST_getCommitBlockSignatures() NO head block")
        ' no commit chain (must be single block write)
        ' in this case return signature from in-memory buffer[handle]
        signature := LONG[buffer_pointer(handle)]
        ifnot signature.[0]                                                     ' if is tail block
            signature.[31..20] := hEndPtr[handle]
        lastSignature := 0
    else
        'debug("TEST_getCommitBlockSignatures() head block")
        ' NOTE: hChainBlockAddr[handle] ' has block address of head of commit chain
        lastSignature := LONG[buffer_pointer(handle)]
        ifnot lastSignature.[0]  ' if is tail block
            lastSignature.[31..20] := hEndPtr[handle]
        lastBlockId := lastSignature.[19..8]
        flash_read_block_addr(hChainBlockAddr[handle], @signature, $000, $003)       'if so, read first long of block to get ID

    repeat
        LONG[@signatures][sigCount++] := signature                              ' place this signature in list
        ifnot signature.[0]                                                     ' if last block, exit loop
            quit
        if sigCount >= MAX_FILE_LEN_IN_BLOCKS - 1                               ' if filled table, exit loop
            quit
        if signature.[0] == 1 and signature.[31..20] == lastBlockId             ' if more block pointing to last in memory block
            LONG[@signatures][sigCount++] := lastSignature                      ' place final buffer signature in list
            quit
        block_address := field[IDToBlock][signature.[31..20]]                   'get next block address
        flash_read_block_addr(block_address, @signature, $000, $003)                 'read the first long of the head/body block

    lockrel(fsLock)                                                             ' release the lock, we're done with it


PUB TEST_getBlockAddressForId(blockID, possHandle) : block_address

'' TEST METHOD: Return block address associated with block ID
''
'' @param blockID - the ID of the block
'' @returns block_address - the address the ID currently maps to, or 0 if block ID is not in use

  repeat while locktry(fsLock) == 0                                             ' lock for exlusive use

  ifnot field[IDValid][blockID]
    return 0

  if possHandle >= 0 and hChainBlockID[possHandle] == blockID
    block_address := hChainBlockAddr[possHandle]
  else
    block_address := field[IDToBlock][blockID]

  lockrel(fsLock)                                                               ' release the lock, we're done with it


PUB TEST_filename_for_handle(handle) : pStr

'' TEST METHOD: return pointer to filename associated with handle
''
'' @param handle - a handle to an open file
'' @returns pStr - pointer to filename string or 0 in which case error() contains:
'' .. E_NOT_MOUNTED if the file system is NOT mounted
'' .. E_BAD_HANDLE if the handle is not valid

  if fsMounted == false
    LONG[@errorCode][cogid()] := E_NOT_MOUNTED
    return 0
  elseif handle < 0 or handle > MAX_FILES_OPEN - 1
    LONG[@errorCode][cogid()] := E_BAD_HANDLE
    return 0

  pStr := @hFilename + handle * FILENAME_SIZE


' ----------------------------------------------------------------------------------------------
'}

CON ' --- Technical Details ---

{
head/last block
------------------------------------------------------------------------------------------------
000..003        long {EndPtr[11:0], ThisID[11:0], %vvv11100}    'vvv = lifecycle, 00 = head/last
004..007        long {Filename crc32}                           'crc32 of filename + terminator
008..087        byte filename[127+1]                            'filename + terminator
088..FFB        byte data[3956]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB


head/more block
------------------------------------------------------------------------------------------------
000..003        long {NextID[11:0], ThisID[11:0], %vvv11101}    'vvv = lifecycle, 01 = head/more
004..007        long {Filename crc32}                           'crc32 of filename + terminator
008..087        byte filename[127+1]                            'filename + terminator
088..FFB        byte data[3956]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB


body/last block
------------------------------------------------------------------------------------------------
000..003        long {EndPtr[11:0], ThisID[11:0], %vvv11110}    'vvv = lifecycle, 10 = body/last
004..FFB        byte data[4088]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB


body/more block
------------------------------------------------------------------------------------------------
000..003        long {NextID[11:0], ThisID[11:0], %vvv11111}    'vvv = lifecycle, 11 = body/more
004..FFB        byte data[4088]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB



vvv lifecycle rules
- single-zero ring counter state sequence is 011..101..110..repeat
- the block with the greater state is the valid block between two blocks with identical IDs
- this allows for make-before-break block replacement that can be recovered after unexpected power loss
-------------------------------------------------------------------------------------------------------
111                     inactive        no zeroes
011/101/110             active          one zero
001/010/100/000         canceled        two or three zeroes

011 > 110               new > old
101 > 011               new > old
110 > 101               new > old

}


CON { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2023 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
