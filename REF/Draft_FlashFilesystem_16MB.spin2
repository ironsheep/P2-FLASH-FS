'****************************************************************************************************************
'*                                                                                                              *
'*  P2 Flash File System                                                                                        *
'*                                                                                                              *
'*  - on-board W25Q128 flash chip becomes 16MB SSD (minus 512KB for boot area)                                  *
'*  - automatic wear leveling is achieved via random block picking and moving                                   *
'*  - if power fails during file rewriting or renaming, the old file or name is still intact                    *
'*                                                                                                              *
'****************************************************************************************************************
'*  v1.0  2023-08-14  Initial release.                                                                          *
'*  v1.1  2023-08-18  Optimized SPI to 8 clocks/bit, or 40MHz SPI_CK at 320MHz. SPI_CS now rests high.          *
'*  v1.2  2023-08-25  Adds open_append(), cleans up byte counting, adjusts get new handle to set fname.         *
'*  v2.0  2023-08-23  draft renovated file with new internal documentation.                                     *
'*  v2.1  2023-09-26  Added file froncation, truncation, and modification. Filenames extended to 127+1 bytes.   *
'*                    SPI code can now run from all cogs.                                                       *
'****************************************************************************************************************

CON 'default flash pin parameters
    SPI_CS          = 61        'flash chip select                            [output]
    SPI_CK          = 60        'flash clock        [output]
    SPI_DI          = 59        'flash data in      [output]
    SPI_DO          = 58        'flash data out     [input]

CON 'default file system parameters
    FIRST_BLOCK     = $080      'block $080 is after the initial 512KB boot space
    LAST_BLOCK      = $FFF      'block $FFF is the end of the 16MB flash
    MAX_FILES_OPEN      = 2     'MAX_FILES_OPEN * 4KB allocated in VARs, two files allows for copying

CON 'internal constants
    BLOCK_SIZE      = $1000     'blocks are 4KB, since flash erasure granularity is 4KB
    BLOCK_SIZE_EXP      = encod BLOCK_SIZE

    BLOCKS          = LAST_BLOCK - FIRST_BLOCK + 1  'number of blocks in the file system

    FILENAME_SIZE       = $80       'filenames are up to 127 characters, plus a zero terminator
    FILENAME_SIZE_EXP   = encod FILENAME_SIZE

    IDToBlocks_SIZE     = (BLOCKS * 12 + 15) / 16   '12-bit fields within words
	IDValids_SIZE		= (BLOCKS * 1 + 7) / 8		'1-bit fields within bytes
    BlockStates_SIZE    = (BLOCKS * 2 + 7) / 8      '2-bit fields within bytes

    'Block states
    sFREE           = %00       'sFREE indicates block is unused
    sTEMP           = %01       'sTEMP used during mount and to later signal immovable work-in-progress blocks
    sHEAD           = %10       'sHEAD is the first block of a file and contains the filename and initial data
    sBODY           = %11       'sBODY blocks trail the head block and contain data

    'handle states
    sREAD           = %0001     'file is being read
    sWRITE          = %0010     'file is being written
    sFORK           = %0100     'file is being written and forked at some block (rewrite/append)
    sMODIFY         = %1000     'file is being modified

    ' Error return codes
    #-1[-1], eInvalidHandle, eNoHandle, eFileNotFound, eFlashFull, eFileWriting, eFileReading, eFileOpen, eFileExists, eAtEndOfFile, eBadBlocksRemoved, eNotAllowed

DAT ' driver state tracking tables

' physically: 3/4 of a word (12 bits) for every valid block ID, 12 bits per ID
' logically: a "BLOCKS"-sized array of 12-bit variables, 1 for ea. block ID - indexed by block ID
' contains blockAddress in ea. 12 bit field
IDToBlocks    WORD      0[IdToBlocks_SIZE]                                      'ID-to-block translation table
IDToBlock     LONG      0                                                       '(field pointer to 12-bit variables)

' physically: 1 byte for every 8 valid block IDs, 1 bit per block ID
' logically: a "BLOCKS"-sized array of single bit variables, 1 for ea. block ID - indexed by block ID
' contains [0,1] in ea. 1 bit field, where 1 means ID is valid
IDValids      BYTE      0[IDValids_SIZE]                                           'ID-valid flags
IDValid       LONG      0                                                       '(field pointer to 1-bit variables)

' physically: 1 byte for every 4 valid block IDs, 2 bits per block ID
' logically: a "BLOCKS"-sized array of 2-bit variables, 1 for ea. block ID - indexed by block ID
' contains a Block-State value in ea. 2 bit field [sFREE, sTEMP, sHEAD, sBODY]
BlockStates   BYTE      0[BlockStates_SIZE]                                          'block states
BlockState    LONG      0                                                       '(field pointer to 2-bit variables)

tmpBlockBuffer BYTE     0[BLOCK_SIZE]                                           'buffer used for copying/building blocks

' handle-related variables and buffers
'   handle is index into each of the arrays below

hStatus                 BYTE    0[MAX_FILES_OPEN]                                         'handle: status [sREAD, sWRITE, sREWRITE]
hHeadBlockID            WORD    0[MAX_FILES_OPEN]                                         'handle: head block ID
hChainBlockID           WORD    0[MAX_FILES_OPEN]                                         'handle: fork block ID
hChainBlockAddr         WORD    0[MAX_FILES_OPEN]                                         'handle: fork blockAddress
hChainLifeCycle         BYTE    0[MAX_FILES_OPEN]                                         'handle: fork block lifecycle
hCircularLength         LONG    0[MAX_FILES_OPEN]                                         '
hModified               BYTE    0[MAX_FILES_OPEN]                                         '
hEndPtr                 WORD    0[MAX_FILES_OPEN]                                         'handle: pointer to next byte in block
hSeekFileOffset         LONG    0[MAX_FILES_OPEN]                                         '
hFilename               BYTE    0[MAX_FILES_OPEN * FILENAME_SIZE]                         'handle: 127+1 byte buffer for filename
hBlockBuff              BYTE    0[MAX_FILES_OPEN * BLOCK_SIZE]                            'handle: 4KB buffer for file data


CON ' --- Public Methods ---

'******************
'* Public Methods *
'******************

PUB format() : status | block_address, cycle_bits

'' Format file system and (re)mount it
''
'' @returns status - ebadBlocksRemoved if bad blocks were found and fixed (SHOULD NOT HAPPEN ON FORMAT), otherwise 0 for success

' Local Variables:
' @local block_address - the block offset within the file system
' @local cycle_bits - lifeCycle bit-pattern to place into block

  repeat BLOCKS with block_address                  'cancel all active blocks
    flash_read_block_addr(block_address, @cycle_bits, $000, $000)
    if lookdown(cycle_bits.[7..5] : %011, %101, %110)
      cancel_block(block_address)

  return mount()                       '(re)mount flash


PUB mount() : status | block_address, signature, BYTE blockTypeBits

'' Mount the filesystem so it is ready to use after scanning all blocks and initilizing internal tables and buffers
''
'' @returns status - eBadBlocksRemoved if BAD blocks were found adn fixed, otherwise 0 for success

' Local Variables:
' @local block_address - the block offset within the file system
' @local signature - block state bits of block being checked

  BlockState := ^@BlockStates.[1..0]            'set field pointers
  IDValid    := ^@IDValids.[0]
  IDToBlock  := ^@IDToBlocks.[11..0]

  bytefill(@BlockStates, 0, BlockStates_SIZE)       'clear block states to sFREE
  bytefill(@IDValids, 0, IDValids_SIZE)         'clear ID flags
  bytefill(@hStatus, 0, MAX_FILES_OPEN)         'clear handles

  repeat BLOCKS with block_address              'check each block and fix any duplicate IDs
    check_block_fix_dupe_id(block_address)       '(recovers from incomplete block switchover due to power loss)

  repeat BLOCKS with block_address              'trace head blocks and cancel any broken files
    if field[BlockState][block_address] == sTEMP        'is this a valid block?
      flash_read_block_addr(block_address, @blockTypeBits, $000, $000)     'yes, read first byte of block
      ifnot blockTypeBits.[1]                  'is this also a head block?
        ifnot trace_file_set_flags(block_address, true)     'yes, trace file, set block states to sHEAD/sBODY
          trace_file_set_flags(block_address, false)        'if error, retrace file, return block states to sTEMP
        'else
        '  debug("* good file", udec(block_address))
  repeat BLOCKS with block_address              'cancel sTEMP blocks that didn't become sHEAD/sBODY blocks
    if field[BlockState][block_address] == sTEMP        'if this an sTEMP block..
      flash_read_block_addr(block_address, @signature, $000, $003)     '..read first long of block to get ID
      field[IDValid][signature.[19..8]]~           '..cancel ID flag
      field[BlockState][block_address] := sFREE         '..return block state to sFREE
      cancel_block(block_address)                '..cancel block to inhibit future CRC checks
      status := eBadBlocksRemoved


PUB unmount() | handle

'' Unmount file system by closing all open handles
''

' Local Variables:
' @local handle - tmporary handle variable

  repeat MAX_FILES_OPEN with handle
    close(handle)  ' ignores not-open handle


PUB OpenRead(pFilename) : handle | signature
'' Open a file for reading, returns handle
''
'' Subsequent calls are allowed to:
''   SeekRel(), Seek(), Tell()
''   rd_byte(), rd_word(), rd_long(), read(), rd_str()
''   close() - releases handle
''
'' @param pFilename -
'' @returns handle -

' Local Variables:
' @local signature -

  if is_file_open(pFilename, sWRITE)   'if file is open for writing, abort
    return eFileWriting

  ifnot signature := get_file_head_signature(pFilename)          'if file doesn't exist, return with error
    return eFileNotFound

  handle := new_handle(pFilename)            'get new handle, aborts if no handle available
  hStatus[handle] := sREAD              'set handle status to READ
  hHeadBlockID[handle] := signature.[19..8]         'get head ID for use by Seek()
  SeekAbs(handle, 0)                   'seek to start of file


PUB OpenWrite(pFilename) : handle | signature

'' Open a file for writing or rewriting, returns handle
''
'' Subsequent calls are allowed to:
''   Tell()
''   wr_byte(), wr_word(), wr_long(), write(), wr_str()
''   flush()
''   close() - releases handle
''
'' @param pFilename - pointer to a zstring containing the filename
'' @returns handle - efileWriting if file is being written, eFileOpen if file is open, or 0 if successful

' Local Variables:
' @local signature - the block state bits of the block being checked

  if is_file_open(pFilename, sREAD | sWRITE)  'if file already open, abort
    return eFileOpen

  handle := new_handle(pFilename)            'get new handle, abort if no handle available

  if signature := get_file_head_signature(pFilename)         'if file already exists, rewrite it
    start_write(handle, sWRITE | sFORK, signature.[19..8], next_active_cycle(signature.[7..5]))
  else                          'else, write it
    start_write(handle, sWRITE, next_available_block_id(), %011)
    hModified[handle]~~                 'force first block to be written in case no data


PUB OpenAppend(pFilename) : handle

'' Open a file for appending or writing, returns handle
''
'' Subsequent calls are allowed to:
''   Tell()
''   wr_byte(), wr_word(), wr_long(), write(), wr_str()
''   flush()
''   close() - releases handle

  return OpenAppendFroncate(pFilename, 0)


PUB OpenAppendFroncate(pFilename, SizeLimit) : handle | signature

'' Open a file for appending or writing with a froncating file size limit, returns handle
''
'' Subsequent calls are allowed to:
''   Tell()
''   wr_byte(), wr_word(), wr_long(), write(), wr_str()
''   flush()
''   close() - releases handle

  if is_file_open(pFilename, sREAD | sWRITE)  'if file already open, abort
    return eFileOpen

  handle := new_handle(pFilename)            'get new handle, abort if no handle available

  hCircularLength[handle] := SizeLimit           'set size limit if non-zero

  if signature := get_file_head_signature(pFilename)         'if file already exists, append it
    start_modify(handle, sWRITE | sFORK, signature.[19..8], $FFFFFF)
  else                          'else, write it
    start_write(handle, sWRITE, next_available_block_id(), %011)
    hModified[handle]~~                 'force first block to be written in case no data


PUB OpenModify(pFilename) : handle | signature

'' Open an existing file for reading and writing within current file boundaries, returns handle
''
'' Subsequent calls are allowed to:
''   SeekRel(), Seek(), Tell()
''   rd_byte(), rd_word(), rd_long(), read(), rd_str()
''   wr_byte(), wr_word(), wr_long(), write(), wr_str()
''   flush()
''   close() - releases handle

  if is_file_open(pFilename, sREAD | sWRITE)  'if file is already open, abort
    return eFileOpen

  ifnot signature := get_file_head_signature(pFilename)          'if file doesn't exist, abort
    return eFileNotFound

  handle := new_handle(pFilename)            'get new handle, abort if no handle available

  start_modify(handle, sWRITE | sMODIFY, signature.[19..8], 0)  'go to start of file


PUB SeekRel(handle, relative_offset) : status

'' Go to offset relative to current location in file opened for reading or modifying
'' if relative_offset >= size of file, ByteRead() will return -1, ByteWrite() will be ignored

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  return SeekAbs(handle, hSeekFileOffset[handle] + relative_offset)


PUB SeekAbs(handle, file_offset) : status | block_id, pBuff

'' Go to location in file opened for reading or modifying
'' if Location >= size of file, ByteRead() will return -1, ByteWrite() will be ignored

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  pBuff := buffer_pointer(handle)             'get block buffer pointer

  case hStatus[handle]

    sREAD, sWRITE | sMODIFY:                'read/modify mode?
      block_id, hEndPtr[handle], hSeekFileOffset[handle] := locate_file_byte(hHeadBlockID[handle], file_offset) 'locate byte in file
      if hStatus[handle] & sMODIFY          'if modify mode..
        if block_id <> long[pBuff].[19..8]            '..and if different block block ID
          if hModified[handle]~             '..and if block was modified (post-clears)
            rewrite_block(handle)            '..then rewrite block (might move a block)

    other:                      'other mode?
      return eNotAllowed                 'seek not allowed, abort

  flash_read_block_id(block_id, pBuff, $000, $FFF)          'read new block into buffer


PUB Tell(handle) : Location

'' Return current location in file

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  return hSeekFileOffset[handle]


PUB rd_str(handle, pBuff, MaxLength, EndChr) : ChrCount | DataByte

'' Read a string from a file opened for reading/modifying
'' - pBuff must point to a buffer which will receive the string plus a zero terminator
'' - MaxLength is the maximum number of characters to read into the buffer, not including the zero terminator
'' - EndChr is the character which will signify the end of the input string (ie $00/$09/$0D/$0A/$20)
'' - ChrCount returns the number of characters read, not including the zero terminator

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  repeat while MaxLength--              'while within maximum length..
    if (DataByte := rd_byte(handle)) < 0       '..get next byte, check for end of file
      quit                      '..quit if end of file
    if DataByte == EndChr               '..check for end character
      quit                      '..quit if end character
    byte[pBuff][ChrCount++] := DataByte         '..store byte and increment length

  byte[pBuff][ChrCount] := 0                'zero-terminate string


PUB read(handle, pBuff, count) : bytes_read | DataByte

'' Read bytes from a file opened for reading/modifying
'' - pBuff must point to a buffer which will receive the bytes
'' - MaxLength is the maximum number of bytes to read into the buffer
'' - byteCount returns the number of bytes read, in case the end of file was reached

  if handle < 0 or handle > MAX_FILES_OPEN - 1
    return eInvalidHandle

  repeat while count--              'while within maximum length..
    if (DataByte := rd_byte(handle)) < 0       '..get next byte, check for end of file
      quit                      '..quit if end of file
    byte[pBuff][bytes_read++] := DataByte        '..store byte and increment length


PUB rd_long(handle) : DataLong

'' Read the next long from a file opened for reading/modifying

  if handle < 0 or handle > MAX_FILES_OPEN - 1
    return eInvalidHandle

  DataLong.Word[0] := rd_word(handle)
  DataLong.Word[1] := rd_word(handle)


PUB rd_word(handle) : DataWord

'' Read the next word from a file opened for reading/modifying

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  DataWord.Byte[0] := rd_byte(handle)
  DataWord.Byte[1] := rd_byte(handle)


PUB rd_byte(handle) : DataByte | pBuff, signature

'' Read the next byte from a file opened for reading/modifying
'' - returns -1 if at end of file, cannot advance, or
''           eNotAllowed is not a legal operation for the open file

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  pBuff := buffer_pointer(handle)             'get block buffer pointer
  signature := long[pBuff]                 'get header long

  case hStatus[handle]

    sREAD, sWRITE | sMODIFY:                'read/modify mode?
      ifnot signature.[0]                  'if last block..
        if hEndPtr[handle] == signature.[31..20]     '..if end of data..
          return -1                 '..return -1
      else                      'if not last block..
        if hEndPtr[handle] == $FFC            '..if end of data..
          if hStatus[handle] & sMODIFY          '..and if modify mode..
            if hModified[handle]~           '..and if block was modified (post-clears)..
              rewrite_block(handle)          '..then rewrite block (might move a block)
          flash_read_block_id(signature.[31..20], pBuff, $000, $FFF) '..read next body block
          hEndPtr[handle] := $004         '..point to start of data in body block

    other:                      'other mode?
      return eNotAllowed                 'read not allowed, abort

  hSeekFileOffset[handle]++                   'increment location
  return byte[pBuff][hEndPtr[handle]++]       'return data byte and increment block pointer


PUB wr_str(handle, pStr, MaxLength) : status | Chr

'' Write a string to a file opened for writing/appending/modifying
'' - pStr must point to a zero-terminated string
'' - MaxLength is the maximum number of characters to write
'' - The zero terminator will not be written to the file

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  repeat MaxLength
    ifnot (Chr := byte[pStr++])
      quit
    wr_byte(handle, Chr)


PUB write(handle, pBytes, count) : bytes_written

'' Write bytes to a file opened for writing/appending/modifying
'' - pBytes must point to the bytes
'' - Length must contain the number of bytes to be written

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  repeat count
    wr_byte(handle, byte[pBytes++])


PUB wr_long(handle, DataLong) : status

'' Write a long to a file opened for writing/appending/modifying

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  wr_word(handle, DataLong.word[0])
  wr_word(handle, DataLong.word[1])


PUB wr_word(handle, DataWord) : status

'' Write a word to a file opened for writing/appending/modifying

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  wr_byte(handle, DataWord.byte[0])
  wr_byte(handle, DataWord.byte[1])


PUB wr_byte(handle, DataByte) : status | pBuff, NextID

'' Write a byte to a file opened for writing/appending/modifying

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  pBuff := buffer_pointer(handle)             'get block buffer pointer

  case hStatus[handle]

    sWRITE, sWRITE | sFORK:             'write/rewrite/append mode?
      if hEndPtr[handle] == $FFC          'if current block full..
        long[pBuff].[0]~~               '..make more block
        NextID := next_available_block_id()               '..get next ID to link to
        write_block(handle, NextID)          '..write current block with NextID link
        bytefill(pBuff, $FF, BLOCK_SIZE)        '..erase block buffer to build new body block
        long[pBuff].[0]~                '..make last block
        long[pBuff].[19..8] := NextID           '..set ID
        hEndPtr[handle] := $004           '..point to start of data in new block

    sWRITE | sMODIFY:                   'modify mode?
      ifnot long[pBuff].[0]             'if last block..
        if hEndPtr[handle] == long[pBuff].[31..20]    '..and if end of data
          return                    '..then return without writing
      else                      'if not last block..
        if hEndPtr[handle] == $FFC            '..and if block full
          if hModified[handle]              '..and if block was modified
            rewrite_block(handle)            '..then rewrite block (might move a block)
          flash_read_block_id(long[pBuff].[31..20], pBuff, $000, $FFF)    '..read next block
          hEndPtr[handle] := $004         '..point to start of data in next block

    other:                      'other mode?
      return eNotAllowed                 'write not allowed, abort

  hSeekFileOffset[handle]++                   'increment location
  hModified[handle]~~                   'set modified flag
  byte[pBuff][hEndPtr[handle]++] := DataByte      'write byte into block buffer, post-increment pointer


PUB flush(handle) : status

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

'' Flush write buffer, completes any write operation, but leaves file open

  case hStatus[handle]

    sWRITE, sWRITE | sFORK:             'write/rewrite/append mode?
      close(handle)                 'close file
      start_modify(handle, sWRITE | sFORK, hHeadBlockID[handle], hCircularLength[handle])  'reopen file in append mode

    sWRITE | sMODIFY:                   'modify mode?
      if hModified[handle]~             'if block was modified (post-clear)..
        rewrite_block(handle)                '..rewrite block

    other:                      'other mode?
      return eNotAllowed                 'flush not allowed, abort


PUB close(handle) : status | FileMode, SizeLimit, headBlockID, forkBlockID, forkBlockAddress, forkState

'' Close an open file, completes any write operation, frees handle

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return eInvalidHandle

  case FileMode := hStatus[handle]~           'get handle and post-clear it

    sWRITE, sWRITE | sFORK:             'write/rewrite/append mode?
      write_block(handle, hEndPtr[handle])     'write last block with EndPtr

      SizeLimit := hCircularLength[handle]           'get size limit
      headBlockID := hHeadBlockID[handle]             'get head ID
      forkBlockID := hChainBlockID[handle]             'get fork ID
      forkBlockAddress := hChainBlockAddr[handle]           'get fork block
      forkState := forkBlockID == headBlockID ? sHEAD : sBODY 'get fork block state

      activate_block(forkBlockAddress, hChainLifeCycle[handle])  'replace old head block if rewrite or old last block if append

      if Status & sFORK                 'if rewrite/append..
        DeleteChainFromID(forkBlockID, 0, 0, True)       '..delete old fork block through end of file, keeping first ID valid

      field[BlockState][forkBlockAddress] := forkState     'change new fork block status from sTEMP to sHEAD/sBODY
      field[IDToBlock][forkBlockID] := forkBlockAddress     'update IDToBlock to point to new fork block

      if SizeLimit                  'if size limit non-zero..
        FroncateFile(headBlockID, SizeLimit)         '..froncate file to size limit

    sWRITE | sMODIFY:                   'modify mode?
      if hModified[handle]              'if block was modified..
        rewrite_block(handle)                '..rewrite block


PUB MakeFile(pFilename, Size) : status | headBlockID, ID, block_address, NotFirst, DataStart, Last, Pos, NextID_EndPtr

'' Make a file of a certain size filled with $FF bytes - use OpenModify() to read and write contents

  if get_file_head_signature(pFilename)                   'if file exists, abort
    return eFileExists

  if is_file_open(pFilename, sREAD | sWRITE)      'if file open, abort
    return eFileOpen

  ID := headBlockID := next_available_block_id()                   'get initial ID

  repeat
    block_address := next_block_address()                     'get a new block now (may alter tmpBlockBuffer and IDToBlock)
    ifnot NotFirst                      'if first block..
      build_head_block(@tmpBlockBuffer, pFilename, 0)          '..build head block in buffer
      DataStart := $088                     '..set data start for head block
    else                            'if not first block..
      bytefill(@tmpBlockBuffer, $FF, BLOCK_SIZE)         '..clear buffer for body block
      DataStart := $004                     '..set data start for body block
    if Last := Size <= (Pos += $FFC - DataStart)        'if last block.. (update position and check if last block)
      NextID_EndPtr := Size - Pos + $FFC            '..get EndPtr
    else                            'if not last block..
      NextID_EndPtr := next_available_block_id()                  '..get NextID
    tmpBlockBuffer.[0] := !Last                  'set more/last bit
    tmpBlockBuffer.long.[19..8] := ID                'set ThisID
    tmpBlockBuffer.long.[31..20] := NextID_EndPtr            'set NextID or EndPtr
    flash_program_block(block_address, @tmpBlockBuffer, %011)           'program block
    if NotFirst                         'if not head block..
      activate_block(block_address, %011)                '..activate body block
    field[IDToBlock][ID] := block_address               'set IDToBlock
    field[BlockState][block_address] := NotFirst~~ ? sBODY : sHEAD  'set block state to head/body, set NotFirst
    ID := NextID_EndPtr                     'switch to next ID
  until Last                            'loop until last block done

  activate_block(field[IDToBlock][headBlockID], %011)         'now activate head block to activate file


PUB Froncate(pFilename, SizeLimit) : status | signature

'' Froncate a file - limits file size, measured from end of file, by trimming the front of the file

  ifnot signature := get_file_head_signature(pFilename)              'if file doesn't exist, abort
    return eFileNotFound

  if is_file_open(pFilename, sREAD | sWRITE)      'if file open, abort
    return eFileOpen

  FroncateFile(signature.[19..8], SizeLimit)           'froncate file


PUB Truncate(pFilename, SizeLimit) : status | signature

'' Truncate a file - limits file size, measured from start of file, by trimming the end of the file

  ifnot signature := get_file_head_signature(pFilename)              'if file doesn't exist, abort
    return eFileNotFound

  if is_file_open(pFilename, sREAD | sWRITE)      'if file open, abort
    return eFileOpen

  TruncateFile(signature.[19..8], SizeLimit)           'truncate file


PUB delete(pFilename) : status | signature

'' Delete a file

  ifnot signature := get_file_head_signature(pFilename)              'if file doesn't exist, abort
    return eFileNotFound

  if is_file_open(pFilename, sREAD | sWRITE)      'if file open, abort
    return eFileOpen

  DeleteChainFromID(signature.[19..8], 0, 0, False)        'cancel and free all blocks in file, don't keep first ID valid


PUB rename(pOldFilename, pNewFilename) : status | signature, block_id, block_address, oldBlockAddress

'' Rename a file
''
'' @param pOldFilename -
'' @param pNewFilename -
'' @returns status - either eFileNotFound is the old file doesn't exist, eFileOpen is the old file is current open, or eFileExists if the new file already exists, otherwise 0 for SUCCESS

' Local Variables:
' @local signature -
' @local block_id -
' @local block_address -
' @local oldBlockAddress -


  ifnot signature := get_file_head_signature(pOldFilename)           'if old file doesn't exist, abort
    return eFileNotFound

  if is_file_open(pOldFilename, sREAD | sWRITE)   'if old file open, abort
    return eFileOpen

  if get_file_head_signature(pNewFilename)                    'if new file exists, abort
    return eFileExists

  if is_file_open(pNewFilename, sREAD | sWRITE) 'if new file open, abort
    return eFileExists

  block_address := next_block_address()                    'get a new block (may alter tmpBlockBuffer and IDToBlock)

  block_id := signature.[19..8]                      'get head block ID
  oldBlockAddress := field[IDToBlock][block_id]              'get head block of file to rename

  flash_read_block_addr(oldBlockAddress, @tmpBlockBuffer, $000, $FFF)           'read head block of file to rename
  tmpBlockBuffer.long[1].[31..12] := getFilenameCRC(pNewFilename)   'install new filename CRC
  bytefill(@tmpBlockBuffer + $008, $FF, FILENAME_SIZE)       'clear filename space to prevent old trailing chrs
  strcopy(@tmpBlockBuffer + $008, pNewFilename, FILENAME_SIZE - 1)   'copy new filename into filename space
  ProgramUpdatedBlock(block_address, @tmpBlockBuffer)         'program updated block
  cancel_block(oldBlockAddress)                     'cancel old block

  field[IDToBlock][block_id] := block_address              'update IDToBlock
  field[BlockState][block_address] := sHEAD              'make new block HEAD
  field[BlockState][oldBlockAddress] := sFREE              'make old block FREE


PUB exists(pFilename) : DoesExist

'' Check if a file exists

  return get_file_head_signature(pFilename) <> 0              'return true/false


PUB file_size(pFilename) : byteCount | signature

'' Get the size of a file

  if signature := get_file_head_signature(pFilename)             'does file exist?
    return CountFileBytes(signature.[19..8])           'yes, get file size


PUB directory(pID, pFilename, pSize) | block_id

'' Get the next file's filename and size, in bytes, via the current block ID
'' - Initialize block ID to 0, then block ID will be advanced by each call to this method
'' - When filename returns empty, there are no more files
  'debug("* directory()", udec(LONG[pID]))

  byte[pFilename]~                      'reset filename

  repeat while long[pID] < BLOCKS               'scan any remaining block ID's for file heads

    block_id := long[pID]++                       'get current block ID and post-increment it

    if field[IDValid][block_id]                   'is this block ID valid?
      'debug("* is valid block ", udec(block_id))
      if field[BlockState][field[IDToBlock][block_id]] == sHEAD   'yes, is this a HEAD block?
        'debug("* is head ", udec(block_id))
        flash_read_block_id(block_id, pFilename, $008, $087)        'yes, read filename
        long[pSize] := CountFileBytes(block_id)           'get file size
        return


PUB stats() : UsedBlocks, FreeBlocks, FileCount | block_address

'' Get stats on used blocks, free blocks, and number of files
  'debug("* stats()")

  repeat BLOCKS with block_address
    case field[BlockState][block_address]
      sFREE: FreeBlocks++
      sTEMP: UsedBlocks++
      sHEAD: UsedBlocks++
             FileCount++
      sBODY: UsedBlocks++


CON ' --- Private Methods ---

PRI check_block_fix_dupe_id(thisBlockAddress) | otherBlockAddress, thisCycleBits, otherCycleBits, thisBlockID

  flash_read_block_addr(thisBlockAddress, @thisCycleBits, $000, $000)                  'read first byte of block

  ifnot lookdown(thisCycleBits.[7..5]: %011, %101, %110)                'if block is canceled or inactive..
    return                              '..block status remains sFREE, done

  flash_read_block_addr(thisBlockAddress, @tmpBlockBuffer, $000, $FFF)              'read entire block

  if long[@tmpBlockBuffer + $FFC] <> block_crc(@tmpBlockBuffer)            'if CRC is bad..
    cancel_block(thisBlockAddress)                      '..cancel block to inhibit future CRC checks
    return                              '..block status remains sFREE, done

  thisBlockID := tmpBlockBuffer.long.[19..8]                      'this block is good, get its block ID

  ifnot field[IDValid][thisBlockID]~~                        'set block ID flag and if it wasn't already set..
    'debug("* valid block ", udec(block_id, block_address))
    field[IDToBlock][thisBlockID] := thisBlockAddress                   '..set IDToBlock to this block
    field[BlockState][thisBlockAddress] := sTEMP               '..set sTEMP status for this block
    return                              '..done

  otherBlockAddress := field[IDToBlock][thisBlockID]                    'block ID flag was already set, get other block with same block ID

  flash_read_block_addr(otherBlockAddress, @otherCycleBits, $000, $000)                 'read first byte of other block

  if lookdown(thisCycleBits.[7..5] << 3 | otherCycleBits.[7..5]: %011_110, %101_011, %110_101)   'if this block is newer..
    field[IDToBlock][thisBlockID] := thisBlockAddress                   '..set IDToBlock to this block
    field[BlockState][thisBlockAddress] := sTEMP               '..set sTEMP status for this block
    field[BlockState][otherBlockAddress] := sFREE              '..set sFREE status for other block
    cancel_block(otherBlockAddress)                     '..cancel other block
  else
    cancel_block(thisBlockAddress)                      'else, cancel this block, block status remains sFREE


PRI trace_file_set_flags(block_address, Set) : valid | signature, block_id
  'debug("* trace file ", udec(block_address), sdec(Set))
  flash_read_block_addr(block_address, @signature, $000, $003)         'read first long of first block
  field[BlockState][block_address] := Set ? sHEAD : sTEMP   'set first block state to sHEAD or sTEMP

  repeat BLOCKS                     'limit repeat to BLOCKS in order to return false on endless loop
    ifnot signature.[0]                    'if last block, file is complete, return true
      return true
    block_id := signature.[31..20]               'get next block ID
    ifnot field[IDValid][block_id]                'if block ID invalid, error, return false
      return
    block_address := field[IDToBlock][block_id]           'translate block ID to next block
    flash_read_block_addr(block_address, @signature, $000, $003)       'read first long of next block
    ifnot signature.[1]                    'if head block, error, return false
      return
    field[BlockState][block_address] := Set ? sBODY : sTEMP 'set block state to sBODY or sTEMP


PRI start_write(handle, fileMode, headBlockID, HeadCycle)

  build_head_block(buffer_pointer(handle), FilenamePtr(handle), headBlockID) 'build head block in buffer

  hStatus[handle] := fileMode             'set status
  hHeadBlockID[handle] := headBlockID             'set head block ID
  hChainBlockID[handle] := headBlockID             'set fork block ID to head block ID
  hChainLifeCycle[handle] := HeadCycle           'set fork cycle to head cycle
  hEndPtr[handle] := $088             'point to first byte in head block


PRI build_head_block(pBuff, pFilename, headBlockID)

  bytefill(pBuff, $FF, BLOCK_SIZE)          'erase block buffer to build new head block
  long[pBuff].[1..0] := %00             'set head/last
  long[pBuff].[19..8] := headBlockID             'set head block ID
  long[pBuff][1].[11..0] := $000            'clear data offset
  long[pBuff][1].[31..12] := getFilenameCRC(pFilename) 'set filename CRC
  strcopy(pBuff + $008, pFilename, FILENAME_SIZE - 1)   'set filename


PRI start_modify(handle, fileMode, headBlockID, Location) | block_id, pBuff

  block_id, hEndPtr[handle], hSeekFileOffset[handle] := locate_file_byte(headBlockID, Location)  'locate block and block pointer by Location

  pBuff := buffer_pointer(handle)             'get block buffer pointer
  flash_read_block_id(block_id, pBuff, $000, $FFF)          'read located block into buffer

  hStatus[handle] := fileMode             'set status
  hHeadBlockID[handle] := headBlockID             'set head block ID
  hChainBlockID[handle] := block_id                 'set fork block ID to located block ID
  hChainLifeCycle[handle] := next_active_cycle(long[pBuff].[7..5])   'set fork cycle to next cycle of located block


PRI write_block(handle, NextID_EndPtr) | pBuff, block_id, block_address

  pBuff := buffer_pointer(handle)             'get block buffer pointer
  long[pBuff].[31..20] := NextID_EndPtr         'set NextID/EndPtr
  block_id := long[pBuff].[19..8]             'get block ID of block

  block_address := next_block_address()                'get a new block (may alter IDToBlock)

  if block_id == hChainBlockID[handle]              'if this is the fork block
    flash_program_block(block_address, pBuff, hChainLifeCycle[handle])   '..program block with fork cycle
    hChainBlockAddr[handle] := block_address          '..remember the block so that it can be activated on close
  else                          'else, this is a body block
    flash_program_block(block_address, pBuff, %011)         '..program body block with new cycle
    activate_block(block_address, %011)           '..activate block
    field[IDToBlock][block_id] := block_address            '..set IDToBlock
    field[BlockState][block_address] := sBODY        '..change block state from sTEMP to sBODY


PRI rewrite_block(handle) | pBuff, block_id, block_address, oldBlockAddress

  pBuff := buffer_pointer(handle)             'get block buffer pointer
  block_id := long[pBuff].[19..8]             'get block ID

  block_address := next_block_address()                'get a new block (may alter IDToBlock)
  ProgramUpdatedBlock(block_address, pBuff)          'program updated block

  oldBlockAddress := field[IDToBlock][block_id]\block_address     'get the old block and update IDToBlock to new block
  cancel_block(oldBlockAddress)                 'cancel the old block

  field[BlockState][block_address] := field[BlockState][oldBlockAddress]\sFREE  'copy old block state to new and free old


PRI FroncateFile(headBlockID, SizeLimit) | Size, block_address, block_id, block_offset, signature, Mode

  Size := CountFileBytes(headBlockID)                    'get size of file

  if Size > SizeLimit                           'if file is oversize..

    block_address := next_block_address()                      'get a new block now (may alter tmpBlockBuffer and IDToBlock)

    flash_read_block_id(headBlockID, @tmpBlockBuffer, $000, $087)           'read head block, minus data area
    bytefill(@tmpBlockBuffer + $088, $FF, $FFC - $088)           'clear data area

    block_id, block_offset, _ := locate_file_byte(headBlockID, Size - SizeLimit)     'find block with start of data (might be head block)
    flash_read_block_id(block_id, @signature, $000, $003)              'get data block header

    if block_offset >= $088                         'if data can tuck into head block..
      tmpBlockBuffer.[0] := signature.[0]                   '..copy more/last bit from data block
      tmpBlockBuffer.long.[31..20] := signature.[31..20]            '..copy NextID/EndPtr from data block
      tmpBlockBuffer.long[1].[11..0] := block_offset - $088          '..set data offset to point within head block
      flash_read_block_id(block_id, @tmpBlockBuffer + block_offset, block_offset, $FFB)      '..overlay data bytes into head block buffer
      Mode := 1                             '..delete old head block through data block
    else                                'if data can't tuck into head block..
      tmpBlockBuffer.long.[31..20] := signature.[19..8]             '..link head block to data block
      tmpBlockBuffer.long[1].[11..0] := $FFC - $088 + block_offset - $004    '..set data offset to point within linked data block
      Mode := 2                             '..delete old head block to before data block

    ProgramUpdatedBlock(block_address, @tmpBlockBuffer)               'program updated block

    DeleteChainFromID(headBlockID, signature.[19..8], Mode, True)       'delete old head block through or before data block, keep first block ID valid

    field[IDToBlock][headBlockID] := block_address                'point IDToBlock to new head block
    field[BlockState][block_address] := sHEAD                'change state of new head block from sTEMP to sHEAD


PRI TruncateFile(headBlockID, SizeLimit) | block_address, block_id, block_offset

  if CountFileBytes(headBlockID) > SizeLimit                 'if file is oversize..

    block_address := next_block_address()                      'get a new block now (may alter tmpBlockBuffer and IDToBlock)

    block_id, block_offset, _ := locate_file_byte(headBlockID, SizeLimit)        'find block with new last byte (might be head block)
    flash_read_block_id(block_id, @tmpBlockBuffer, $000, block_offset - 1)           'read block, minus excess data area
    bytefill(@tmpBlockBuffer + block_offset, $FF, $FFC - block_offset)       'clear excess data area
    tmpBlockBuffer.[0] := 0                          'make into last block
    tmpBlockBuffer.long.[31..20] := block_offset                 'set EndPtr
    ProgramUpdatedBlock(block_address, @tmpBlockBuffer)               'program updated last block

    DeleteChainFromID(block_id, 0, 0, True)                   'delete old block through end of file, keep first block ID valid

    field[IDToBlock][block_id] := block_address                    'point IDToBlock to new last block
    field[BlockState][block_address] := tmpBlockBuffer.[1] ? sBODY : sHEAD    'change state of new last block from sTEMP to sHEAD/sBODY


PRI ProgramUpdatedBlock(block_address, pBuff) | nextCycleBits

  nextCycleBits := next_active_cycle(long[pBuff].[7..5])         'get next cycle
  flash_program_block(block_address, pBuff, nextCycleBits)           'program new block to replace old block
  activate_block(block_address, nextCycleBits)             'activate new block


PRI get_file_head_signature(pFilename) : Found_Header | tmpFilenameCRC, block_address, signature[2], bIsOldFmt

  tmpFilenameCRC := getFilenameCRC(pFilename)             'get CRC of filename

  repeat BLOCKS with block_address              'scan head blocks for filename
    if field[BlockState][block_address] == sHEAD        'if this is a head block..
      flash_read_block_addr(block_address, @signature, $000, $007)         '..read first two longs of block
      if signature[1].[31..12] == tmpFilenameCRC          'if the filename CRC matches..
        ' have new format file head
        flash_read_block_addr(block_address, @tmpBlockBuffer, $008, $087)        '..read whole filename for comparison
        if strcomp(pFilename, @tmpBlockBuffer)       'if filename matches..
          return signature                     '..return first long of block (always non-zero or logically TRUE)
      else
        ' see if old format (crc32 vs crc19)
        bIsOldFmt := is_old_format_file_head(block_address, @tmpBlockBuffer)
        if bIsOldFmt
          if strcomp(pFilename, @tmpBlockBuffer)       'if filename matches..
            return signature                     '..return first long of block (always non-zero or logically TRUE)

PRI CountFileBytes(block_id) : byteCount

  _, _, byteCount := locate_file_byte(block_id, $FFFFFF)    'locate end-of-file by using impossibly large location (16MB)


PRI locate_file_byte(block_id, fileOfs) : rID, rBlockOfs, rLocation | dataOffset, signature, currOfs, srtOfs, endOfs, fnmCrc32, bIsOldFmt

  fileOfs := fileOfs #> 0 <# $FFFFFF          'limit offset into file from 0 to 16MB

  ' we are in HEAD block see if we are old format CRC32 block
  bIsOldFmt := is_old_format_file_head(field[IDToBlock][block_id], @tmpBlockBuffer)
  if not bIsOldFmt
    ' have new format file head
    flash_read_block_id(block_id, @dataOffset, $004, $005)        'read the data offset in the head block
    currOfs -= dataOffset.[11..0]                 'subtract it from the initial position of zero

  repeat                        'trace blocks to count file bytes
    flash_read_block_id(block_id, @signature, $000, $003)      'read block header
    srtOfs := signature.[1] ? $004 : $088         'body or head?
    endOfs := signature.[0] ? $FFC : signature.[31..20]      'more or last?
    'debug("* size ", udec(block_id, Bot, Top, Pos))
    if fileOfs >= currOfs and fileOfs < currOfs + endOfs - srtOfs   'if location is within block..
      'debug("  size ", udec(block_id, Location - Pos + Bot, Location))
      return block_id, fileOfs - currOfs + srtOfs, fileOfs     '..return block block ID, offset into block, and target location
    currOfs += endOfs - srtOfs                    'not within block, advance position to next block
    ifnot signature.[0]                    'if last block..
      'debug("  size ", udec(block_id, Top, Pos))
      return block_id, endOfs, currOfs               '..return block ID, offset into block, and end-of-file location
    block_id := signature.[31..20]               'get next block ID

PRI is_old_format_file_head(block_address, pBlockBuffer): oldFormatStatus | fnmCrc32, possOldCRC
  ' return T/F where T means we have an Old-Format crc32 file head block
  '  NOTE: leaves filename in [pBlockBuffer]
  flash_read_block_addr(block_address, @possOldCRC, $004, $007)        '..read whole filename for comparison
  flash_read_block_addr(block_address, pBlockBuffer, $008, $087)        '..read whole filename for comparison
  ' this is the prior version 32-bit crc for filenames
  fnmCrc32 := getcrc(pBlockBuffer, $AD0424F3 rev 31, strsize(pBlockBuffer)+1)   'compute CRC of filename
  oldFormatStatus := possOldCRC == fnmCrc32


PRI DeleteChainFromID(block_id, EndID, Mode, KeepFirstIDValid) | block_address, signature

' Mode  Deletes to...
'---------------------------------
' 0 last block (EndID ignored)
' 1 block whose ThisID = EndID
' 2 block whose NextID = EndID

  repeat                        'trace block chain and cancel IDs, block states, and blocks
    ifnot KeepFirstIDValid~             'keep first block block ID valid?
      field[IDValid][block_id]~               'clear block ID valid flag
    block_address := field[IDToBlock][block_id]           'translate block ID to block
    field[BlockState][block_address] := sFREE           'set block state to sFREE
    cancel_block(block_address)                  'cancel block
    flash_read_block_addr(block_address, @signature, $000, $003)       'read block header
    block_id := signature.[31..20]               'get block ID of next block
  while lookupz(Mode: signature.[0],       ... 'mode 0: delete to last block
              signature.[19..8] <> EndID,  ... 'mode 1: delete to ThisID = EndID
              block_id <> EndID)          'mode 2: delete to NextID = EndID


PRI is_file_open(pFilename, openModeBits) : sattus | handle

 ' Return true if named file is open
'
' @param pFilename - pointer to zstring containing the filename
' @param openModeBits - some combiantion of sREAD, sWRITE, sREWRITE
' @returns status - T/F where T means the file is open

' Local Variables:
' @local handle - tmporary handle to check for availability

 repeat MAX_FILES_OPEN with handle         'scan through handles
    if hStatus[handle] & openModeBits          'if handle is open..
      if strcomp(FilenamePtr(handle), pFilename)    '..if filename is same..
        return true


PRI next_block_address() : block_address | tmpBlockAddress, BlockFreeCount, NthFree, freeBlockAddress, nextCycleBits

' Get a new block and set it to sTEMP
' - may have to move an existing head/body block, overwriting tmpBlockBuffer and changing IDToBlock

  repeat                        'randomly pick an sFREE/sHEAD/sBODY (not an sTEMP) block
    block_address := abs getrnd() // BLOCKS         '(random block selection results in +-5% wear leveling)
  until field[BlockState][block_address] <> sTEMP

  if field[BlockState][block_address] == sFREE          'if block is sFREE, change it to sTEMP and return it
    field[BlockState][block_address] := sTEMP
    return

  repeat BLOCKS with tmpBlockAddress                  'block is sHEAD/sBODY, must relocate it to an sFREE block
    if field[BlockState][tmpBlockAddress] == sFREE            'count sFREE blocks
      BlockFreeCount++

  ifnot BlockFreeCount                  'if no sFREE block, abort
    return eFlashFull

  NthFree := abs getrnd() // BlockFreeCount     'randomly pick an sFREE block to relocate the sHEAD/sBODY block to
  repeat BLOCKS with freeBlockAddress              'scan blocks until the Nth sFREE block is located
    if field[BlockState][freeBlockAddress] == sFREE
      ifnot NthFree--
        quit

  flash_read_block_addr(block_address, @tmpBlockBuffer, $000, $FFF)      'read the sHEAD/sBODY block contents
  nextCycleBits := next_active_cycle(tmpBlockBuffer.[7..5])           'advance the block lifecycle
  flash_program_block(freeBlockAddress, @tmpBlockBuffer, nextCycleBits)     'program the sHEAD/sBODY block contents into the sFREE block
  activate_block(freeBlockAddress, nextCycleBits)            'activate the block, making it the now-superior sHEAD/sBODY block
  cancel_block(block_address)                    'cancel the original sHEAD/sBODY block to complete the relocation

  field[IDToBlock][tmpBlockBuffer.long.[19..8]] := freeBlockAddress         'reflect relocation in IDToBlock and BlockState
  field[BlockState][freeBlockAddress] := field[BlockState][block_address]\sTEMP    'block is now free and set to sTEMP, return it


PRI new_handle(pFilename) : handle

  repeat MAX_FILES_OPEN with handle                 'scan through handles
    ifnot hStatus[handle]                       'if handle is free..
      hCircularLength[handle]~                       '..reset size limit
      hModified[handle]~                        '..reset modified flag
      strcopy(FilenamePtr(handle), pFilename, FILENAME_SIZE - 1)    '..record filename
      return handle                               '..return new handle

  return eNoHandle                           'no handle is available, abort


PRI next_available_block_id() : block_id

' Get a next available block ID
'
' @returns block ID - the next block ID that is not in use (or eFlashFull if no block ID's are available)

  repeat BLOCKS with block_id                 'pick the first free block ID
    ifnot field[IDValid][block_id]~~              'set IDValid flag, if it was previously clear..
      return block_id                       '..got the new id, return it

  return eFlashFull                  'no block ID is free, abort


PRI next_active_cycle(CycleIn) : CycleOut

' Calculate and return the next active lifecycle pattern in (3 -> 5 -> 6 -> 3 -> 5 -> 6 -> 3... pattern)
'
' @param CycleIn - current lifecycle pattern
' @returns CycleOut - next lifecycle pattern in sequence


  CycleOut := CycleIn.[0] << 2 | CycleIn.[2..1]     'get next lifecycle pattern


PRI FilenamePtr(handle) : pFilename

  return @hFilename + handle << FILENAME_SIZE_EXP   'get filename pointer by handle


PRI buffer_pointer(handle) : pBuff

' Return a pointer to the block buffer for this handle
'
' @param handle - the handle to the file
' @returns ptr -  the address of the 4KB buffer for the file associated with this handle

  return @hBlockBuff + handle << BLOCK_SIZE_EXP     'get block buffer pointer by handle


PRI getFilenameCRC(pFilename) : filenameCRC

  filenameCRC := getcrc(pFilename, $B5827 rev 19, strsize(pFilename))   'compute CRC of filename


PRI block_crc(pBuff) : blockCRC

' Calculate and return the CRC for this pointed to block
'
' @param ptr - the address of the 4KB buffer for the file associated with this handle
' @returns CRC - the calculated CRC for the block

  return getcrc(pBuff, $AD0424F3 rev 31, BLOCK_SIZE - 4)    'compute CRC of block


CON ' --- Flash Operations ---

PRI flash_read_block_id(block_id, pBuff, firstByte, lastByte)

  flash_read_block_addr(field[IDToBlock][block_id], pBuff, firstByte, lastByte)


PRI flash_read_block_addr(block_address, pBuff, firstByte, lastByte)

  flash_command($03 | (FIRST_BLOCK + block_address) << 20 | firstByte << 8, 4)   'read 4KB block
  flash_receive(pBuff, lastByte - firstByte + 1)           'receive block data


PRI flash_program_block(block_address, pBuff, cycle_bits) | Page

  flash_command($06, 1)                  'enable write
  flash_command($20 | (FIRST_BLOCK + block_address) << 20, 4)    'erase 4KB block

  byte[pBuff].[7..5] := cycle_bits         'install lifecycle for CRC computation
  long[pBuff + $FFC] := block_crc(pBuff) 'compute and install CRC
  byte[pBuff].[7..5]~~                'block will be inactive until activated

  flash_wait()                       'wait for erasure to complete (~45ms)

  repeat 16 with Page                   'program 16 pages within 4KB block
    flash_command($06, 1)                        'enable write
    flash_command($02 | (FIRST_BLOCK + block_address) << 20 | Page << 16, 4) 'program
    flash_send(pBuff + Page << 8, 256)             'send 256 bytes
    flash_wait()                             'wait for programming to complete (~400us)


PRI activate_block(block_address, cycle_bits)

  program_bit(block_address, cycle_bits << 5 | %00011111)     'clear one cycle bit to activate block


PRI cancel_block(block_address)

  program_bit(block_address, %00011111)              'clear all cycle bits to cancel block


PRI program_bit(block_address, bit_pattern)

  flash_command($06, 1)                  'enable write
  flash_command($02 | (FIRST_BLOCK + block_address) << 20, 4)    'program
  flash_send(@bit_pattern, 1)             'send byte with bit pattern
  flash_wait()                       'wait for programming to complete


PRI flash_wait() | statusBits

  repeat
    flash_command($05, 1)                'read STATUS register
    flash_receive(@statusBits, 1)
  while statusBits.[0]                  'loop until BUSY bit clear


PRI flash_command(command, count)

    org

    fltl    #SPI_DO             '2! DO input

    fltl    #SPI_CK             '2! reset CK smart pin, drives high
    wrpin   ##%001000000_01_00101_0,#SPI_CK '2  set CK for transition output, inverted - SPI mode 3
    wxpin   #4,#SPI_CK          '2  set timebase to 4 clocks per transition

    wrpin   ##%001000000_00_00000_0,#SPI_CS '2  set CS for inverted output, allows other cogs to DRVL
    drvl    #SPI_CS             '2! CS high
    waitx   #14             '2+14   CS deselect is 50ns at 350 MHz (50 / 2.777ns = 18)
    drvh    #SPI_CS             '2! CS low, one cog at a time can DRVH, while others can DRVL

    movbyts command,#%%1230         'reverse order of post-command address bytes for sending

    end

  flash_send(@command, count)        'send command


PRI flash_send(pBuff, count) | Data

    org

    rdfast  #0,pBuff          'start fast read

.byte   rfbyte  Data                '2  read byte to send
    shl Data,#24 + 1    wc      '2  msb-justify bits and get D7 into c

    rep @.r,#1              '2  protect from interrupts
    fltl    #SPI_CK             '2! reset smart pin CK
    drvl    #SPI_CK             '2! start smart pin CK, starts base period
    drvc    #SPI_DI             '2! output D7
    wypin   #16,#SPI_CK         '2* begin 16 clock transitions
    rep @.r,#7              '2  repeat to output D6..D0
    shl Data,#1     wc      '2  get data bit
    drvc    #SPI_DI             '2! output data bit
    waitx   #2              '2+2    delay makes 8 clocks/bit
.r
    djnz    count,#.byte        '4|2    loop if another byte to send

    drvl    #SPI_DI             '2! DI low

    end


PRI flash_receive(pBuff, count) | Data

    org

    wrfast  #0,pBuff          'start fast write

.byte   rep @.r,#1              '2  protect from interrupts
    fltl    #SPI_CK             '2! reset smart pin CK
    drvl    #SPI_CK             '2! start smart pin CK, starts base period
    wypin   #16,#SPI_CK         '2* begin 16 clock transitions
    waitx   #7              '2+7    align TESTP to before 2nd clock fall (DC..350MHz+)
    rep @.r,#8              '2  repeat to input D7..D0
    waitx   #2              '2+2    delay makes 8 clocks/bit
    testp   #SPI_DO     wc      '2  input data bit
    rcl Data,#1             '2  save data bit
.r
    wfbyte  Data                '2  write received byte
    djnz    count,#.byte        '4|2    loop if another byte to receive

    drvl    #SPI_CS             '2! CS high, terminates command, another cog can later DRVH
    fltl    #SPI_CK             '2! reset CK smart pin, drives high, another cog can later DRVL

    end


CON ' --- operation Notes ---
{

head/last block
------------------------------------------------------------------------------------------------
000..003    long {EndPtr[11:0], ThisID[11:0], %vvv11100}    'vvv = lifecycle, 00 = head/last
004..007    long {FilenameCRC19[19:0], DataOffset[11:0]}    'crc of filename and data offset
008..087    byte Filename[127+1]                'filename z-string
088..FFB    byte Data[3956]                 'data
FFC..FFF    long CRC32                  'crc32 of 000..FFB


head/more block
------------------------------------------------------------------------------------------------
000..003    long {NextID[11:0], ThisID[11:0], %vvv11101}    'vvv = lifecycle, 01 = head/more
004..007    long {FilenameCRC19[19:0], DataOffset[11:0]}    'crc of filename and data offset
008..087    byte Filename[127+1]                'filename z-string
088..FFB    byte Data[3956]                 'data
FFC..FFF    long CRC32                  'crc32 of 000..FFB


body/last block
------------------------------------------------------------------------------------------------
000..003    long {EndPtr[11:0], ThisID[11:0], %vvv11110}    'vvv = lifecycle, 10 = body/last
004..FFB    byte Data[4088]                 'data
FFC..FFF    long CRC32                  'crc32 of 000..FFB


body/more block
------------------------------------------------------------------------------------------------
000..003    long {NextID[11:0], ThisID[11:0], %vvv11111}    'vvv = lifecycle, 11 = body/more
004..FFB    byte Data[4088]                 'data
FFC..FFF    long CRC32                  'crc32 of 000..FFB



vvv lifecycle rules
- single-zero ring counter state sequence is 011..101..110..repeat (akin to "rock, paper, scissors")
- the block with the greater state is the valid block between two blocks with identical IDs
- this allows for make-before-break block replacement that can be recovered after unexpected power loss
-------------------------------------------------------------------------------------------------------
111         inactive    no zeroes
011/101/110     active      one zero        rock, paper, scissors
001/010/100/000     canceled    two or three zeroes

011 > 110       new > old   rock > scissors
101 > 011       new > old   paper > rock
110 > 101       new > old   scissors > paper

}
