'' =================================================================================================
''
''   File....... flash_fs.spin2
''   Purpose.... This object is the full flash file system driver for the P2
''               it manages all but the first 512KB of the flash chip (where the boot image is stored)
''               it provides a standard file system interface to the flash chip
''   Author..... Chip Gracey
''   Conrtributions..... Jon McPhalen, Stephen M Moraco
''               -- see below for terms of use
''   E-mail.....stephen@ironsheep.biz
''   Started.... AUG 2023
''   Updated.... 28 AUG 2023
''
'' =================================================================================================


con { version }

  LIB_VERSION = 120                                             ' 1.2.0

  #true,  ON, OFF
  #false, NO, YES


con { fixed io pins }

  PGM_RX   = 63  { I }                                          ' programming / debug
  PGM_TX   = 62  { O }

  SF_CS    = 61  { O }                                          ' flash chip select
  SF_SCLK  = 60  { O }                                          ' flash clock
  SF_MOSI  = 59  { O }                                          ' flash data in
  SF_MISO  = 58  { I }                                          ' flash data out

  LED2     = 57  { O }                                          ' Eval and Edge LEDs
  LED1     = 56  { O }


con { PUBLIC driver constants }

  ' Return Codes

  OKAY             = 0                                          ' No error / Success
  SUCCESS          = OKAY                                       ' No error / Success

  E_BAD_HANDLE     = -1                                         ' Error: Handle in invalid
  E_NO_HANDLE      = -2                                         ' Error: Out of available handles
  E_FILE_NOT_FOUND = -3                                         ' Error: File not present
  E_DRIVE_FULL     = -4                                         ' Error: Out of space on flash chip
  E_FILE_WRITING   = -5                                         ' Error: File is open for writing
  E_FILE_READING   = -6                                         ' Error: File is open for reading
  E_FILE_OPEN      = -7                                         ' Error: File is open
  E_FILE_EXISTS    = -8                                         ' Error: the File exists
  E_END_OF_FILE    = -9                                         ' Error: no more data avaiable, at end of file
  E_FILE_MODE      = -10                                        ' Error: file not opened in desired mode
  E_FILE_SEEK      = -11                                        ' Error: Attempted seek past end of file
  E_BAD_BLOCKS_REMOVED = -12                                    ' Error: Block bit failure detetected, bad blocks removed
  E_NO_LOCK_AVAIL  = -13                                        ' Error: Unable to obtain a LOCK for driver use
  E_TRUNCATED_STRING = -14                                      ' Error: Buffer full, before reaching string terminator
  E_INCOMPLETE_STRING = -15                                     ' Error: End of file reached before string terminator
  E_SHORT_TRANSER = -16                                         ' Error: Too few bytes read or written


con { PRIVATE driver constants }

  ' optionally customizable

  FIRST_BLOCK      = $080                                       ' Physical address of first block in this flash file system
  LAST_BLOCK       = $FFF                                       ' Physical address of last block in this flash file system
  MAX_FILES_OPEN   = 2                                          ' Maximum number of files that can be open at one time


  ' NOT customizable! below here

  BLOCKS           = LAST_BLOCK - FIRST_BLOCK+1                 ' Number of blocks in flash allocated to this file system

  BLOCK_SIZE       = $1000                                      ' Size in bytes: 4KB block (4096 bytes)
  BLOCK_SIZE_EXP   = encod BLOCK_SIZE

  FILENAME_SIZE    = $040-$004                                  ' File name string length: 59 characters plus 0 terminator

  ID_TO_BLOCKS_SZ  = (BLOCKS * 12 + 15) / 16                    ' 12-bit fields in WORD array (rounded to full WORD)
  FLAGS_SIZE       = (BLOCKS * 1 + 7) / 8                       ' 1-bit fields in BYTE array (rounded to full BYTE)
  STATES_SIZE      = (BLOCKS * 2 + 7) / 8                       ' 2-bit fields in BYTE array (rounded to full BYTE)


  B_FREE           = %00                                        ' Block is not in use (free)
  B_TEMP           = %01                                        ' Block is being put to use
  B_HEAD           = %10                                        ' Block is head of a file (contains filename)
  B_BODY           = %11                                        ' BLock is body of file (any blocks after head)

  H_READ           = %001                                       ' Existing file is being read
  H_WRITE          = %010                                       ' New file is being written
  H_REWRITE        = %100                                       ' Existing file is being overwritten
  H_READ_MODIFY_WRITE = H_READ | H_WRITE                        ' Existing file is File is open for random access read/write using seek()


  H_READ_WRITE     = H_READ | H_WRITE | H_REWRITE               ' (Any) File is open for reading and/or writing
  H_WRITE_ONLY     = H_WRITE | H_REWRITE                        ' File is open for writing or overwriting
  H_READ_ONLY      = H_READ                                     ' Existing File is open for reading only

  NOT_ENABLED      = -1                                         ' this feature is NOT enabled (e.g., seeking)

dat { pre-initialized: driver state tracking tables }

' physically: 3/4 of a word (12 bits) for every valid block ID, 12 bits per ID
' logically: a "BLOCKS"-sized array of 12-bit variables, 1 for ea. block ID - indexed by block ID
' contains block_address in ea. 12 bit field
IDToBlocks    WORD      0[ID_TO_BLOCKS_SZ]                                      'ID-to-block translation table
IDToBlock     LONG      0                                                       '(field pointer to 12-bit variables)

' physically: 1 byte for every 8 valid block IDs, 1 bit per block ID
' logically: a "BLOCKS"-sized array of single bit variables, 1 for ea. block ID - indexed by block ID
' contains [0,1] in ea. 1 bit field, where 1 means ID is valid
IDValids      BYTE      0[FLAGS_SIZE]                                           'ID-valid flags
IDValid       LONG      0                                                       '(field pointer to 1-bit variables)

' physically: 1 byte for every 4 valid block IDs, 2 bits per block ID
' logically: a "BLOCKS"-sized array of 2-bit variables, 1 for ea. block ID - indexed by block ID
' contains a Block-State value in ea. 2 bit field [B_FREE, B_TEMP, B_HEAD, B_BODY]
BlockStates   BYTE      0[STATES_SIZE]                                          'block states
BlockState    LONG      0                                                       '(field pointer to 2-bit variables)

tmpBlockBuffer BYTE     0[BLOCK_SIZE]                                           'buffer used for copying blocks

' handle-related variables and buffers
'   handle is index into each of the arrays below

hStatus       BYTE    0[MAX_FILES_OPEN]                                         'handle: status [H_READ, H_WRITE, H_REWRITE]
hHeadID       WORD    0[MAX_FILES_OPEN]                                         'handle: head blockID
hHeadBlock    WORD    0[MAX_FILES_OPEN]                                         'handle: head block_address
hHeadCycle    BYTE    0[MAX_FILES_OPEN]                                         'handle: head block lifecycle
hBlockPtr     WORD    0[MAX_FILES_OPEN]                                         'handle: pointer to next byte in block
hDirtyBuff    BYTE    false[MAX_FILES_OPEN]                                     'handle: 4KB buffer for file data
hBlockBuff    BYTE    0[MAX_FILES_OPEN * BLOCK_SIZE]                            'handle: 4KB buffer for file data
hFilename     BYTE    0[MAX_FILES_OPEN * FILENAME_SIZE]                         'handle: 59+1 byte buffer for filename
hSeekPtr      LONG    NOT_ENABLED[MAX_FILES_OPEN]                               'handle: seek address within entire file

errorCode     LONG    0                                                         'most recent error code
fs_lock       LONG    -1                                                        'flash lock semaphore for driver use
fs_mounted    LONG    false                                                     ' T/F where T means the filesystem is mounted

fs_cog_cts    LONG    $7fff_ffff[8]                                             'cog counts: one for each cog that is attempting to start the filesystem

pub null()

'' This is not an application
''  (invoke format() or mount() to use the flash file system)


pub version() : result

'' Returns flash file system library version as integer
'' -- e.g., version 120 is 1.2.0 (major, minor, bugfix)

  return LIB_VERSION


pub serial_number() : snHi, snLo

'' Returns 64-bit unique id of flash chip
''
'' @returns snHi - high 32 bits of 64-bit unique id of flash chip
'' @returns snLo - low 32 bits of 64-bit unique id of flash chip

  flash_command($4B, 1)
  flash_send($00, 4)
  flash_receive(@snHi, 8)

  ' UID values are stored Big Endian
  ' -- swap ends to correct LE reads from flash

  org
                        movbyts   snHi, #%%0123
                        movbyts   snLo, #%%0123
  end

pub mount() : status | block_address, cycleBits, signature

'' Mount the filesystem so it is ready to use after scanning all blocks and initilizing internal tables and buffers
''
'' @returns status - E_BAD_BLOCKS_REMOVED if BAD blocks were found and fixed,
'' .. E_NO_LOCK_AVAIL if all 16 LOCKs are in use, otherwise 0 for success

' Local Variables:
' @local block_address - the block offset within the file system
' @local cycleBits - lifeCycle bit-pattern to place into block
' @local signature - block state bits of block being checked


    if fs_lock == -1
        if acquire_lock_and_mount() == false
            ' i was NOT first so I just wait
            repeat while fs_mounted == false or fs_lock == -1                   ' I'm not allocating, just wait until is allocated
        else
            ' i was the first to mount this thing
            fs_lock := locknew()                                                'reserve a lock for driver use
            if(fs_lock < 0)                                                     'if lock allocation failed
                fs_mounted := false                                             ' clear "mounted" inidcation
                return (errorCode := E_NO_LOCK_AVAIL)                           '..abort with error

    debug("* mount()")
    errorCode := SUCCESS                                                        ' preset to success

    'debug("- have lock, trying...")
    repeat while locktry(fs_lock) == 0                                  ' try to get the lock
    'debug("- locked")
    fs_mounted := true                                                  ' set "mounted" inidcation

    'debug("- mounting...")
    bytefill(@hStatus, 0, MAX_FILES_OPEN)                                         'clear handles
    bytefill(@IDValids, 0, Flags_SIZE)                                            'clear ID flags
    bytefill(@BlockStates, 0, States_SIZE)                                        'clear block states to B_FREE

    IDToBlock  := ^@IDToBlocks.[11..0]                                            'set field pointers
    IDValid    := ^@IDValids.[0]
    BlockState := ^@BlockStates.[1..0]

    'debug("- fixing power-out leftovers...")
    repeat block_address from 0 to BLOCKS - 1                                     'check each block and fix any duplicate IDs
        check_block_fix_dupe_id(block_address)                                      '(recovers from incomplete block switchover due to power loss)

    'debug("- locating files...")
    repeat block_address from 0 to BLOCKS - 1                                     'trace head blocks and cancel any broken files
        if field[BlockState][block_address] == B_TEMP                               'is this a valid block?
            flash_read_block(block_address, @cycleBits, $000, $000)                   'yes, read first byte of block
            ifnot cycleBits.[1]                                                       'is this also a head block?
                ifnot trace_file_set_flags(block_address, true)                         'yes, trace file, set block states to B_HEAD/B_BODY
                trace_file_set_flags(block_address, false)                            'if error, retrace file, return block states to B_TEMP

    'debug("- clearing dead blocks...")
    repeat block_address from 0 to BLOCKS - 1                                     'cancel B_TEMP blocks that didn't become B_HEAD/B_BODY blocks
        if field[BlockState][block_address] == B_TEMP                               'is this an B_TEMP block?
            flash_read_block(block_address, @signature, $000, $003)                   'if so, read first long of block to get ID
            field[IDValid][signature.[19..8]]~                                        '..cancel ID flag
            field[BlockState][block_address] := B_FREE                                '..return block state to B_FREE
            cancel_block(block_address)                                               '..cancel block to inhibit future CRC checks
            'debug(" -- found dead block...")
            status :=  (errorCode := E_BAD_BLOCKS_REMOVED)

    'debug("- mount done")

    lockrel(fs_lock)              ' release the lock, we're done with it
    'debug("- lock released")


pub unmount() | handle

'' Prepare for shutdown / power-off by closing any open files
''

' Local Variables:
' @local handle - temporary handle to check for open files
  debug("* unmount()")
  repeat handle from 0 to MAX_FILES_OPEN - 1              ' for each handle
    if hStatus[handle]                                    ' if handle is open...
        close(handle)                                     ' ..close it!


pub format() : status | block_address, cycleBits

'' Format the file system blocks and (re)mount it
''
'' @returns status - E_BAD_BLOCKS_REMOVED if BAD blocks were found and fixed,
'' .. E_NO_LOCK_AVAIL if all 16 LOCKs are in use, otherwise 0 for success

' Local Variables:
' @local block_address - the block offset within the file system
' @local cycleBits - lifeCycle bit-pattern to place into block

  'debug("* format()")
  ' ensure we have a lock first!  Abort if we can't get one

    if fs_lock == -1
        if acquire_lock_and_mount() == false
            ' i was NOT first so I just wait
            repeat while fs_mounted == false or fs_lock == -1                   ' I'm not allocating, just wait until is allocated
        else
            ' i was the first to mount this thing
            fs_lock := locknew()                                                'reserve a lock for driver use
            if(fs_lock < 0)                                                     'if lock allocation failed
                fs_mounted := false                                             ' clear "mounted" inidcation
                return (errorCode := E_NO_LOCK_AVAIL)                           '..abort with error

    debug("* format()")

    'debug("- have lock, trying...")
    repeat while locktry(fs_lock) == 0                                            ' try to get the lock

    'debug("- formatting...")
    repeat block_address from 0 to BLOCKS - 1                                     'cancel all active blocks
        flash_read_block(block_address, @cycleBits, $000, $000)
        'if block_address // 128 == 0
        '  debug(" -- block ", uhex_word_(block_address),", cycle...", ubin_byte(cycleBits))
        if lookdown(cycleBits.[7..5] : %011, %101, %110)
            'debug(" -- clearing...")
            cancel_block(block_address)

    'debug("- formatting done")
    fs_mounted := false                                                           ' clear "mounted" indcation so it will mount the scan structures

    lockrel(fs_lock)                                                              ' release the lock, we're done with it
    'debug("- lock released")
    return Mount()                                                                '(re)mount flash


pub error() : result

'' Returns error code from most recent operation
''
'' @returns result - latest error code (0 for no error)

  return errorCode


pub open(p_filename, mode) : handle

'' Open file in mode; return handle (0..n) if successful
''
'' @param p_filename - address of a zstring containing the filename
'' @param mode - the mode in which to open the file:
'' -- mode "r", "R" to read from an existing file
'' -- mode "w", "W" to write to a new file (overwrites existing file)
'' -- mode "a", "A" to append to the end of an existing file
'' -- mode "rw", "RW" to read from or / write to anywhere within an existing file
'' @returns handle - E_FILE_MODE if mode letter is invalid,
'' .. E_FILE_OPEN if file is already open,
'' .. E_FILE_EXISTS if file exists,
'' .. E_FILE_NOT_FOUND if file does not exist,
'' .. E_NO_HANDLE if no handle is available, otherwise the next available handle

  if is_file_open(p_filename, H_READ_WRITE)  'if file is already open, abort
    return (errorCode := E_FILE_OPEN)

  case mode
    "r", "R"   : return open_read(p_filename)
    "w", "W"   : return open_write(p_filename)
    "a", "A"   : return open_append(p_filename)
    "rw", "RW" : return open_modify(p_filename)
    other      : return (errorCode := E_FILE_MODE)

pub open_read(p_filename) : handle | signature

'' Open a file for reading, returning handle if success
''
'' @param p_filename - address of a zstring containing the filename
'' @returns handle - E_FILE_NOT_FOUND if file doesn't exist, E_FILE_WRITING if file is being written, or 0 if successful

' Local Variables:
' @local signature - the block state bits of the block being checked

  if is_file_open(p_filename, H_WRITE_ONLY)  'if file is being written, abort
    return (errorCode := E_FILE_WRITING)

  ifnot signature := get_file_head_signature(p_filename)                        'if file doesn't exist, abort
    return (errorCode := E_FILE_NOT_FOUND)

  handle := new_handle()                                                         'get new handle, aborts if no handle available
  if handle >= 0
    hStatus[handle] := H_READ                                                   'set handle status to READ
    flash_read_block(field[IDToBlock][signature.[19..8]], buffer_pointer(handle), $000, $FFF)   'read head block into buffer
    hBlockPtr[handle] := $040                                                   'point to first data byte in head block
    set_filename(handle, p_filename)                                            'set handle filename


pub open_write(p_filename) : handle | signature, ptr

'' Open a file for (re)writing
''
'' @param p_filename - address of a zstring containing the filename
'' @returns handle - efileWriting if file is being written, E_FILE_OPEN if file is open, or 0 if successful

' Local Variables:
' @local signature - the block state bits of the block being checked
' @local ptr - the address of the 4KB buffer for the file associated with this handle

  if is_file_open(p_filename, H_READ_WRITE)          'if file already open, abort
    return (errorCode := E_FILE_OPEN)

  handle := new_handle()                                                        'get new handle, aborts if no handle available
  if handle < 0                                                                 ' is error
    return (errorCode := handle)                                                ' yes, error is in handle, return it

  if signature := get_file_head_signature(p_filename)                           'does file already exist?
    hStatus[handle] := H_REWRITE                                                'yes, REWRITING
    hHeadID[handle] := signature.[19..8]                                        'yes, get block ID from head block
    hHeadCycle[handle] := next_active_cycle(signature.[7..5])                   'yes, get next lifecycle from head block
  else
    hStatus[handle] := H_WRITE                                                  'no, WRITING
    hHeadID[handle] := next_available_block_id()                                'no, get new ID
    hHeadCycle[handle] := %011                                                  'no, set new lifecycle

  ptr := buffer_pointer(handle)                                                 'get buffer pointer

  bytefill(ptr, $FF, BLOCK_SIZE)                                                'erase block buffer
  LONG[ptr].[1..0] := %00                                                       'set head/last
  LONG[ptr].[19..8] := hHeadID[handle]                                          'set ID
  strcopy(ptr + $004, p_filename, FILENAME_SIZE - 1)                            'set filename

  hBlockPtr[handle] := $040                                                     'point to start of data in head block

  set_filename(handle, p_filename)                                              'set handle filename
  hDirtyBuff[handle] := true                                                   ' mark the buffer as dirty (is modified)


pub open_append(p_filename) : handle | signature

'' open for append not yet implemented!
''
'' @param p_filename - address of a zstring containing the filename
'' @returns handle - handle to open file if successful,
'' .. E_FILE_NOT_FOUND if file doesn't exist,
'' .. E_FILE_OPEN if file is already open,
'' .. or E_NO_HANDLE if no handle is available

' Local Variables:
' @local signature - the block state bits of the block being checked

  if is_file_open(p_filename, H_READ_WRITE)                                     ' if file already open, abort
    return (errorCode := E_FILE_OPEN)

  if not exists(p_filename)                                                     ' if file doesn't exist, abort
    return (errorCode := E_FILE_NOT_FOUND)

  handle := new_handle()                                                        'get new handle, aborts if no handle available
  if handle < 0                                                                 ' is error
    return (errorCode := handle)                                                ' yes, error is in handle, return it

  ' open for write but place file pointer at end of file
  signature := get_file_head_signature(p_filename)                              'does file already exist?
  hStatus[handle] := H_REWRITE                                                  'yes, REWRITING
  hHeadID[handle] := signature.[19..8]                                          'yes, get block ID from head block
  hHeadCycle[handle] := signature.[7..5]                                        'yes, get current lifecycle from head block

  seek_to_block(handle, file_size(p_filename))                                  ' set file pointer to end of file, loading last block into buffer


pub open_modify(p_filename) : handle | signature

'' open for modify not yet implemented!
''
'' @param p_filename - address of a zstring containing the filename
'' @returns handle - handle to open file if successful,
'' .. E_FILE_NOT_FOUND if file doesn't exist,
'' .. E_FILE_OPEN if file is already open,
'' .. or E_NO_HANDLE if no handle is available

' Local Variables:
' @local signature - the block state bits of the block being checked

  if is_file_open(p_filename, H_READ_WRITE)                                     ' if file already open, abort
    return (errorCode := E_FILE_OPEN)

  if not exists(p_filename)                                                     ' if file doesn't exist, abort
    return (errorCode := E_FILE_NOT_FOUND)

  handle := new_handle()                                                        'get new handle, aborts if no handle available
  if handle < 0                                                                 ' is error
    return (errorCode := handle)                                                ' yes, error is in handle, return it

  ' open for write but leave file pointer at head of file
  signature := get_file_head_signature(p_filename)                              'does file already exist?
  hStatus[handle] := H_READ_MODIFY_WRITE                                        'yes, READing and WRITINGing of existing file
  hHeadID[handle] := signature.[19..8]                                          'yes, get block ID from head block
  hHeadCycle[handle] := next_active_cycle(signature.[7..5])                     'yes, get next lifecycle from head block
  hSeekPtr[handle] := 0                                                         'yes, see seek pointer to head of file


pub rename(p_old_filename, p_new_filename) : status | signature, new_block_address, old_block_address, next_cycle_bits

'' Rename a a file named p_old_filename to p_new_filename
''
'' @param p_old_filename - address of a zstring containing the existing filename
'' @param p_new_filename - address of a zstring containing the new filename
'' @returns status - E_FILE_NOT_FOUND if old file doesn't exist,
'' .. E_FILE_OPEN if old file is open,
'' .. E_FILE_EXISTS if new file exists,
'' .. otherwise 0 (SUCCESS) if successful

' Local Variables:
' @local signature - block state bits of block being renamed
' @local new_block_address - the block offset within the file system for the new block
' @local old_block_address - the block offset within the file system for the old block
' @local next_cycle_bits - active lifecycle bits for new block indicating block is newer than block containing the old filename

  ifnot signature := get_file_head_signature(p_old_filename)                    'if old file doesn't exist, abort
        return (errorCode := E_FILE_NOT_FOUND)

  if is_File_Open(p_old_filename, H_READ_WRITE)                                 'if old file is open, abort
        return (errorCode := E_FILE_OPEN)

  if get_file_head_signature(p_new_filename)                                    'if new file exists, abort
        return  (errorCode := E_FILE_EXISTS)

  if is_File_Open(p_new_filename, H_READ_WRITE)                                 'if new file is open, abort
        return  (errorCode := E_FILE_EXISTS)

  ' a file rename consists of replacing the current head block of the file with a new head block containing the new filename
  ' then cancelling the old head block

  new_block_address := next_block_address()                                     'get a new block to use for renaming (may move head block)
  old_block_address := field[IDToBlock][signature.[19..8]]                      'get head block of file to rename (AddressOfNextBlock may have changed lookup)

  flash_read_block(old_block_address, @tmpBlockBuffer, $000, $FFF)              'read head block of file to rename
  bytefill(@tmpBlockBuffer + $004, 0, FILENAME_SIZE)                            'clear filename space to prevent old trailing chrs
  strcopy(@tmpBlockBuffer + $004, p_new_filename, FILENAME_SIZE - 1)            'copy new filename into filename space
  next_cycle_bits := next_active_cycle(tmpBlockBuffer.[7..5])                   'get next lifecycle
  program_block(new_block_address, @tmpBlockBuffer, next_cycle_bits)            'program first block of renamed file
  activate_block(new_block_address, next_cycle_bits)                            'activate new block
  cancel_block(old_block_address)                                               'cancel old block

  field[IDToBlock][signature.[19..8]] := new_block_address                      'update IDToBlock
  field[BlockState][new_block_address] := B_HEAD                                'make new block HEAD
  field[BlockState][old_block_address] := B_FREE                                'make old block FREE


pub delete(p_filename) : status | signature

'' Delete a named file
''
'' @param p_filename - address of a zstring containing the filename
'' @returns status - E_FILE_NOT_FOUND if file doesn't exist, E_FILE_OPEN if file is open, or 0 if successful

' Local Variables:
' @local signature - block state bits of block being removed

  ifnot signature := get_file_head_signature(p_filename)                        'if file doesn't exist, abort
        return  (errorCode := E_FILE_NOT_FOUND)

  if is_file_open(p_filename, H_READ_WRITE)                                     'if file open in any mode, abort
        return  (errorCode := E_FILE_OPEN)

  ' a file delete consists of cancelling all blocks in the file chain

  delete_chain_at_block_id(signature.[19..8])


pub exists(p_filename) : result

'' Determine if named file is present in the file system
''
'' @param p_filename - address of a zstring containing the filename
'' @returns result - True/False where True means the file exists

  return get_file_head_signature(p_filename) ? true : false


pub file_size(p_filename) : size_in_bytes | signature

'' Return size of file in bytes
''
'' @param p_filename - address of a zstring containing the filename
'' @returns size_in_bytes - either the count of bytes contained in the file or E_FILE_NOT_FOUND if the file doesn't exist

' Local Variables:
' @local signature - block state bits of block being checked

  errorCode := SUCCESS
  if signature := get_file_head_signature(p_filename)                           'does file exist?
    size_in_bytes, _, _ := count_file_bytes(field[IDToBlock][signature.[19..8]])
  else
    size_in_bytes := (errorCode := E_FILE_NOT_FOUND)


pub file_size_unused(p_filename) : size_in_bytes_unused | signature

'' Return the number of bytes not yet written to in the last allocated block
''
'' @param p_filename - address of a zstring containing the filename
'' @returns size_in_bytes_unused - either the count of unwritten bytes of the file or E_FILE_NOT_FOUND if the file doesn't exist

' Local Variables:
' @local signature - block state bits of block being checked

  errorCode := SUCCESS
  if signature := get_file_head_signature(p_filename)                           'does file exist?
    _, size_in_bytes_unused, _ := count_file_bytes(field[IDToBlock][signature.[19..8]])
  else
    size_in_bytes_unused := (errorCode := E_FILE_NOT_FOUND)

  'debug("file_size_unused(", zstr_(p_filename), ") = (", sdec_(size_in_bytes_unused), ")")

pub close(handle) : status

'' Close an open file, completes file (re)write, frees handle
''
'' @param handle - a handle to an open file
'' @returns status - either E_BAD_HANDLE if the handle is not valid, otherwise 0 for success

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return (errorCode := E_BAD_HANDLE)

  case hStatus[handle]~                                                         'get handle and post-clear
    H_READ:                                                                     'READ?
      {okay, nothing to do}
    H_WRITE, H_REWRITE:                                                         'WRITE/REWRITE?
      ' we are always in the last block, so finish it
      LONG[buffer_pointer(handle)].[31..20] := hBlockPtr[handle]                'cap last block and write it
      write_block(handle)

      activate_block(hHeadBlock[handle], hHeadCycle[handle])                    'activate head block, replaces file if rewrite

      if hStatus[handle] == H_REWRITE                                           'if file rewrite, delete old file to clean up
        delete_chain_at_block_id(hHeadID[handle])
        field[IDValid][hHeadID[handle]]~~                                       'set IDValid again, since it was cleared during file deletion

      field[IDToBlock][hHeadID[handle]] := hHeadBlock[handle]                   'set IDToBlock
      field[BlockState][hHeadBlock[handle]] := B_HEAD                           'change head block status from B_TEMP to B_HEAD
      hDirtyBuff[handle] := false                                               'mark the buffer as clean (not modified)
    H_READ_MODIFY_WRITE:                                                        'READ-MODIFY-WRITE?
      ' flush the current block possibly replacing an older block with the new block
      flush(handle)
    other:
      return (errorCode := E_BAD_HANDLE)

  errorCode := SUCCESS
  hSeekPtr[handle] := NOT_ENABLED                                               ' Ensure seek mode is disabled for this handle


pub seek(handle, position) : result | load_status, file_length

'' Postion seek file pointer to position within the file or at the end of the file
'' -- use 0 for position to seek to the start of the file
'' -- use "size of file" to seek to the end of the file for append
''
'' @param handle - handle to a file that is open for read or read or read-modify-write
'' @param position - location within the file to which to position the file pointer
'' @returns result - E_FILE_SEEK if the position is not within the file,
'' ..E_FILE_MODE if the file is not open in a mode allowing seeking
'' ..E_NOT_FOUND if the file is not on the filesystem
'' ..E_BAD_HANDLE if the handle is not valid, otherwise 0 for success

' Local Variables:
' @local load_status - temporary variable to hold the status returned from seek_to_block()
  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return (errorCode := E_BAD_HANDLE)

  case hStatus[handle]                                                          'get handle
    H_READ:                                                                     'READ?
      {okay, direct access allowed}
    H_READ_MODIFY_WRITE:                                                        'READ and WRITE?
      {okay, direct access allowed}
    other:
      return (errorCode := E_FILE_MODE)                                         ' no, abort with error (open mode does not support seeking)

  file_length := file_size(@hFilename + handle * FILENAME_SIZE)
  if file_length < 0
    return (errorCode := file_length)                                           ' error, return the error code instead of a SUCCESS status

  'debug("seek(", udec_(position), "), FSize=(", udec_(file_length), ")")
  if position >= 0 and position <= file_length                                  ' is position within file?
    load_status := seek_to_block(handle, position)                              ' yes, load buffer, setting file pointer to value within the buffer
    if(load_status < 0)                                                         ' did seek_to_block return an error?
      return load_status                                                        ' yes, return the error code
    else
      return SUCCESS                                                            ' no, return SUCCESS
  else
    return (errorCode := E_FILE_SEEK)                                           ' no, abort with error


pub write(handle, p_buffer, count) : result | checkValue, byteIndex, wr_value, wr_status

'' Write count bytes from p_buffer to the file associated with handle
''
'' @param handle - the handle to the file to which to write byte(s)
'' @param p_buffer - the address of the buffer containing the users' data to write
'' @param count - the number of bytes to write to the file
'' @returns result - E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_MODE if the file is not open for writing,
'' .. otherwise 0 to indicate SUCCESS

' Local Variables:
' @local checkValue - a temporary variable to hold the status returned from checking the handle
' @local byteIndex - the index into the users' buffer for the next byte to write
' @local wr_value - the next value to be written to the file
' @local wr_status - the status returned from the wr_byte() function

  errorCode := SUCCESS          ' preset no error occurred from this operation
  'debug("write(", udec(handle), uhex_long(p_buffer), udec(count) ,")")

  if (checkValue := ensure_handle_mode(handle, H_WRITE | H_REWRITE)) < 0        ' is handle valid and open for writing?
     return (errorCode := checkValue)                                           ' no, return error code

  'debug("write() [",zstr_(p_buffer),"](",udec_(count),")")
  repeat byteIndex from 0 to count - 1                                          ' for the max length of the buffer
    wr_value := BYTE[p_buffer][byteIndex]
    if (wr_status := wr_byte(handle, wr_value)) < 0                               ' write a byte to the file
      return (errorCode := wr_status)                                           ' an error occured, return the error code

  errorCode := SUCCESS          ' no error occurred from this operation, clear possibly older outstanding error code


pub wr_byte(handle, byteValue) : result | ptr, nextBlockID, checkValue

'' Write a byte to a file that is open for write or rewrite
''
'' @param handle - handle to a file that is open for write or rewrite
'' @param byteValue - value to write to the file
'' @returns result - E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_MODE if the file is not open for writing,
'' .. otherwise 0 to indicate SUCCESS

' Local Variables:
' @local ptr - the address of the 4KB buffer for the file associated with this handle
' @local nextBlockID - block ID of the next block to write to the file

  if (checkValue := ensure_handle_mode(handle, H_WRITE | H_REWRITE)) < 0        ' is handle valid and open for writing?
     return (errorCode := checkValue)                                           ' no, return error code

  if hSeekPtr[handle] <> NOT_ENABLED                                ' if seek pointer is in use...
    return seek_wr_byte(handle, byteValue)                          ' ..use it to write the next byte

  ptr := buffer_pointer(handle)                                     'get buffer pointer

  if hBlockPtr[handle] == $FFC                                      'current block full?
    ' if block is already full, then write it as a 'more' block, and get a new block as tail and link this block to the new tail
    nextBlockID := next_available_block_id()                        'get next ID to link to
    if nextBlockID < 0                                              'is an error: no more blocks available?
        return nextBlockID                                          '  return the error code instead of a SUCCESS status

    LONG[ptr].[0]~~                                                 'change block type from 'last' to 'more'
    LONG[ptr].[31..20] := nextBlockID                               'make current block point to next block

    write_block(handle)                                             'write current block

    bytefill(ptr, $FF, BLOCK_SIZE)                                  'make block buffer look erased (fill w/$ff's)
    LONG[ptr].[1..0] := %10                                         'set block type to body/last
    LONG[ptr].[19..8] := nextBlockID                                'set block ID

    hBlockPtr[handle] := $004                                       'point to start of data in new block

  'debug("wr_byte() [",uhex_byte_(byteValue),"]")
  BYTE[ptr][hBlockPtr[handle]++] := byteValue                       'write byte into block buffer, post-increment pointer


pub wr_word(handle, word_value) : result

'' Write WORD (16-bits) to file associated with handle
'' -- order is Little Endian
''
'' @param handle - the handle of the file to which to write the WORD
'' @param word_value - the 16 bit WORD to write to the file
'' @returns result - E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_MODE if the file is not open for writing,
'' .. otherwise 0 to indicate SUCCESS

  return write(handle, @word_value, 2)


pub wr_long(handle, long_value) : result

'' Write LONG (32-bits) to file associated with handle
'' -- order is Little Endian
''
'' @param handle - the handle of the file to which to write the LONG
'' @param long_value - the 32 bit LONG to write to the file
'' @returns result - E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_MODE if the file is not open for writing,
'' .. otherwise 0 to indicate SUCCESS

  return write(handle, @long_value, 4)


pub wr_str(handle, p_str) : result

'' Write string (including the terminator) from p_str to file associate with handle
''
'' @param handle - the handle of the file to which to write the zString
'' @param p_str - the address of the zString to write to the file
'' @returns result - E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_MODE if the file is not open for writing,
'' .. otherwise 0 to indicate SUCCESS

  'debug("write_str() [",zstr_(p_str),"](",udec_(strsize(p_str)+1),")")
  return write(handle, p_str, strsize(p_str)+1)                 ' include string terminator


pub read(handle, p_buffer, count) : bytes_read | byteIndex, readValue, checkValue

'' Read count bytes from file associated with handle to p_buffer or to end of file which ever comes first
'' -- returns count of bytes read (negative result indicates error)
''
'' @param handle - the handle to the file from which to read bytes
'' @param p_buffer - address of the buffer into which to place the data read
'' @param count - the maximum number of bytes to place into the buffer
'' @returns bytes_read - the number of bytes read. If number doesn't match expected, then check error() for reason:
'' ..E_BAD_HANDLE if the handle is not valied,
'' ..E_FILE_WRITING if the file is not open for reading,
'' ..E_END_OF_FILE if attempted read beyond written data,

' Local Variables:
' @local byteIndex - the index into the users' buffer for the next byte to be read
' @local readValue - a temporary variable to hold the byte read from the file (or the returned error code)
' @local checkValue - a temporary variable to hold the status returned from checking the handle

  errorCode := SUCCESS
  if (checkValue := ensure_handle_mode(handle, H_READ)) < 0                     ' is handle valid and open for reading?
     errorCode := checkValue                                                    ' no, set system error
     return 0                                                                   ' no, 0 bytes read

  repeat byteIndex from 0 to count - 1                                          ' for the max length of the buffer
    if (readValue := rd_byte(handle)) < 0                                       ' read a byte from the file
        errorCode := readValue                                                  ' another error occured, set system error
        return byteIndex                                                        ' return bytes read so far
    else
      BYTE[p_buffer][byteIndex] := readValue                                    ' no error, place byte in the users buffer
  bytes_read := byteIndex + 1                                                   ' return bytes read so far
  'debug("read(", udec_(count),") = (", sdec_(bytes_read),")")


pub rd_byte(handle) : value | ptr, signature, checkValue

'' Read next byte from file associated with handle
''  -- negative value indicates error or end of file
''
'' @param handle - the handle to the file from which to read a byte
'' @returns byteValue - E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for reading,
'' .. E_END_OF_FILE if no more data,
'' .. otherwise, the next byte [0-255] from the file

' Local Variables:
' @local ptr - the address of the 4KB buffer for the file associated with this handle
' @local signature - the block state bits of the block being checked
' @local checkValue - a temporary variable to hold the status returned from checking the handle

  if (checkValue := ensure_handle_mode(handle, H_READ)) < 0                     ' is handle valid and open for reading?
     return (errorCode := checkValue)                                           ' no, return error code

  if hSeekPtr[handle] <> NOT_ENABLED                                            ' if seek pointer is in use...
    return seek_rd_byte(handle)                                                 ' ..use it to read the next byte

  ptr := buffer_pointer(handle)                                                 ' get buffer pointer
  signature := LONG[ptr]                                                        ' get first long

  ifnot signature.[0]                                                           ' if last block and no more data, return error code
    if hBlockPtr[handle] == LONG[ptr].[31..20]
      return  (errorCode := E_END_OF_FILE)
  else
    if hBlockPtr[handle] == $FFC                                                ' else, if no more data then read next body block
      flash_read_block(field[IDToBlock][signature.[31..20]], ptr, $000, $FFF)
      hBlockPtr[handle] := $004                                                 ' point to start of data in body block

  value := BYTE[ptr][hBlockPtr[handle]++]                                       ' get data byte to return and increment pointer
  'debug("rd_byte() [",uhex_byte_(value),"]")


pub rd_word(handle) : value | status, readCount

'' Read next WORD from file associated with the handle
''
'' @param handle - the handle to the file from which to read a byte
'' @returns result - the number of bytes read. If number doesn't match expected, then check error() for reason:
'' .. E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_WRITING if the file is not open for reading,
'' .. E_END_OF_FILE if attempted read beyond written data,
'' .. the WORD value read from the file

  if (readCount := read(handle, @value, 2)) <> 2
    return errorCode


pub rd_long(handle) : value | status, readCount

'' Read next LONG from file associated with the handle
''
'' @param handle - the handle to the file from which to read a byte
'' @returns value - E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_WRITING if the file is not open for reading,
'' .. E_END_OF_FILE if attempted read beyond written data,
'' .. the LONG value read from the file

  if (readCount := read(handle, @value, 4)) <> 4
    return errorCode


pub rd_str(handle, p_str, count) : result | byteIndex, readValue, checkValue

'' Read z-string from file at handle into buffer at p_str (count is max length of string + terminator)
''
'' @param handle - the handle to the file from which to read a byte
'' @param p_str - the address of the buffer into which to place the string
'' @param count - the maximum number of bytes to place into the buffer
'' @returns result - E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for reading,
'' .. otherwise, the length of the string placed into the buffer

' Local Variables:
' @local byteIndex - the index into the users' buffer for the next byte to be read
' @local readValue - a temporary variable to hold the byte read from the file (or the returned error code)
' @local checkValue - a temporary variable to hold the status returned from checking the handle

  bytefill(p_str, 0, count)                                                     ' clear the users buffer

  if (checkValue := ensure_handle_mode(handle, H_READ)) < 0                     ' is handle valid and open for reading?
     return (errorCode := checkValue)                                           ' no, return error code

  repeat byteIndex from 0 to count - 1                                          ' for the max length of the buffer
    if (readValue := rd_byte(handle)) < 0                                       ' read a byte from the file, have error?
      'debug("EEE: ", sdec(readValue))
      if readValue == E_END_OF_FILE                                             ' yes, if we've reached end of file return the number of bytes read
        if byteIndex == 0                                                       ' if we've not read any bytes
          return (errorCode := readValue)                                       ' ..abort with end of file
        else                                                                    ' else
            BYTE[p_str][byteIndex] := 0                                         ' place a 0 terminator in the users buffer
            return (errorCode := E_INCOMPLETE_STRING)                           ' return error saying file ended without string terminator
      else
        return readValue                                                        ' another error occured, return the error code
    else
     'debug("ok: ", uhex_byte(readValue))
     if byteIndex == count - 1 and readValue <> 0                              ' no error, if we've reached the end of the buffer and the byte read is not a 0 terminator
        BYTE[p_str][byteIndex] := 0                                             ' ..place a 0 terminator in the users buffer
        return (errorCode := E_TRUNCATED_STRING)                                ' ..abort with error
     else
        BYTE[p_str][byteIndex] := readValue                                     ' no error, place byte in the users buffer (could be terminator)
        if readValue == 0                                                       ' if this is a string terminator...
          return byteIndex                                                      ' ..return the number of bytes placed into the buffer


pub directory(p_block_id, p_filename, p_file_size) | blockID, block_address, signature

'' Get next file's filename and size in bytes via current blockID
''
'' @param p_block_id - the next block ID to check for a file head. (Initialize to 0, will be auto-advanced by each call to this method)
'' @param p_filename - the filename of the file found (or a zero length string if no more files)
'' @param p_file_size - the number of bytes in the file found (or 0 when no more files)

' Local Variables:
' @local blockID - the id of the block being checked
' @local block_address - the offset within the file system of the block being checked
' @local signature - temporary storage for the block state bits of the block being checked

  BYTE[p_filename][0] := 0                                                      'reset filename

  repeat while LONG[p_block_id] < BLOCKS                                        'scan any remaining blockID's for file heads
        blockID := LONG[p_block_id]++                                           'get current blockID and post-increment it
        if field[IDValid][blockID]                                              'block ID valid?
          block_address := field[IDToBlock][blockID]                            'yes, get block from block ID
          if field[BlockState][block_address] == B_HEAD                         'is this a HEAD block?
                flash_read_block(block_address, p_filename, $004, $03F)         'yes, read filename
                LONG[p_file_size], _, _ := count_file_bytes(block_address)            'get file size
                return


pub stats() : usedBlocks, freeBlocks, fileCount | blockAddress

'' Get fielsystem stats: used/free block counts and file count
''
'' @returns usedBlocks - the number of blocks in use
'' @returns freeBlocks - the number of free blocks
'' @returns fileCount - the number of files recorded in filesystem

' Local Variables:
' @local blockAddress - the block offset within the file system

  usedBlocks := 0
  freeBlocks := 0
  fileCount := 0

  repeat blockAddress from 0 to BLOCKS - 1
    case field[BlockState][blockAddress]
      B_FREE: freeBlocks++
      B_TEMP: usedBlocks++
      B_HEAD: usedBlocks++
              fileCount++
      B_BODY: usedBlocks++


pub string_for_error(error_code) : p_interpretation

'' Return a string describing the error code
''
'' @param error_code - the error code to translate
'' @returns p_interpretation - interpretation of the errcode

    case error_code
'---+---+---+---+---+---+---+---+-----------------------+-----------------------+
        SUCCESS:                p_interpretation := @"SUCCESS: No error"
        E_BAD_HANDLE:           p_interpretation := @"E_BAD_HANDLE: Handle in invalid"
        E_NO_HANDLE:            p_interpretation := @"E_NO_HANDLE: Out of available handles"
        E_FILE_NOT_FOUND:       p_interpretation := @"E_FILE_NOT_FOUND: File not present"
        E_DRIVE_FULL:           p_interpretation := @"E_DRIVE_FULL: Out of space on flash chip"
        E_FILE_WRITING:         p_interpretation := @"E_FILE_WRITING: File is open for writing"
        E_FILE_READING:         p_interpretation := @"E_FILE_READING: File is open for reading"
        E_FILE_OPEN:            p_interpretation := @"E_FILE_OPEN: File is open"
        E_FILE_EXISTS:          p_interpretation := @"E_FILE_EXISTS: the File exists"
        E_END_OF_FILE:          p_interpretation := @"E_END_OF_FILE: no more data avaiable, at end of file"
        E_FILE_MODE:            p_interpretation := @"E_FILE_MODE: file not opened in desired mode"
        E_FILE_SEEK:            p_interpretation := @"E_FILE_SEEK: Attempted seek past end of file"
        E_BAD_BLOCKS_REMOVED:   p_interpretation := @"E_BAD_BLOCKS_REMOVED: Block bit failure detetected, bad blocks removed"
        E_NO_LOCK_AVAIL:        p_interpretation := @"E_NO_LOCK_AVAIL: Unable to obtain a LOCK for driver use"
        E_TRUNCATED_STRING:     p_interpretation := @"E_TRUNCATED_STRING: Buffer full, before reaching string terminator"
        E_INCOMPLETE_STRING:    p_interpretation := @"E_INCOMPLETE_STRING: End of file reached before string terminator"
        E_SHORT_TRANSER:        p_interpretation := @"E_SHORT_TRANSER: Too few bytes read or written"
        other:                  p_interpretation := @"???: Unknown error code ???"

con { low-level support }


pri acquire_lock_and_mount() : bItsMe | myCogId, tmpCogId, lowestValue, lowestID
    lowestValue := $7fff_ffff   ' max signed long value
    if fs_lock == -1
        myCogId := cogid()                                                      ' get our cog ID
        LONG[@fs_cog_cts][myCogId] := getct()                                   ' set our cog timer value
        waitms(10)                                                              'let any other cogs get in here too
        repeat tmpCogId from 0 to 8-1                                           ' now scan to see if we win!
            ' determine cog id of earliest cog that tried to start the filesystem
            if LONG[@fs_cog_cts][tmpCogId] < lowestValue
                lowestValue := LONG[@fs_cog_cts][tmpCogId]
                lowestID := tmpCogId
        ' if we were earliest, we get to allocate the lock and mount
        debug("acquire_lock_and_mount() ", udec(lowestValue, lowestID, myCogId))
        if lowestID == myCogId
            ' i was first so I get to allocate lock
            bItsMe := true
        else
            ' i was NOT first so I just wait
            bItsMe := false

pri blocks_free() : count | block_address

' Return the count of available blocks
'
' @returns count - the number of filesystem blocks that are not in use

' Local Variables:
' @local block_address - the block offset within the file system

  repeat block_address from 0 to BLOCKS - 1             ' count free blocks
        ifnot field[BlockState][block_address]
          count++


pri new_handle() : handle | potentialHandle

' Calculate and return next available handle
'
' @returns handle - eNoHandle if no handle is available, otherwise the next available handle

' Local Variables:
' @local potentialHandle - temporary handle to check for availability

  handle := E_NO_HANDLE                                                         'if no handle is available... return this
  repeat potentialHandle from 0 to MAX_FILES_OPEN - 1                           'find first free handle
    ifnot hStatus[potentialHandle]                                              'if handle not in use
      handle := potentialHandle                                                 '..select as handle to use
      quit                                                                      '..exit loop, we have our answer

  if handle < 0                                                                 'if error, set error code
    errorCode := handle

pri next_available_block_id() : block_id | possible_block_id

' Get a next available block ID
'
' @returns block_id - the next ID that is not in use (or E_DRIVE_FULL if no blockID's are available)

' Local Variables:
' @local possible_block_id - prospective blockID to check for availability

  block_id := E_DRIVE_FULL                              ' preset error
  repeat possible_block_id from 0 to BLOCKS - 1         ' pick the first free ID
        ifnot field[IDValid][possible_block_id]~~       ' set IDValid, was IDValid previously clear?
          block_id := possible_block_id                 ' if IDValid was clear, return new ID
          quit

  if block_id < 0                                       ' if error, set error code
    errorCode := block_id


pri next_block_address() : block_address | blockFreeCount, freeBlockAddress, freeIndex, next_cycle_bits

' Return the address of the next block to which we should write
'
' @returns block_address - E_DRIVE_FULL if no free block is available, otherwise the address of the next block to use

' Local Variables:
' @local blockFreeCount - the count of free blocks
' @local freeBlockAddress - the offset within the file system of the free block
' @local freeIndex - a counter of free blocks
' @local next_cycle_bits - the next lifecycle bits to use for the new block

  ifnot blockFreeCount := blocks_free()                                          'if no free block exists, abort with error
        return (errorCode := E_DRIVE_FULL)

  repeat                                                                        'randomly pick an B_FREE/B_HEAD/B_BODY (not an B_TEMP) block
        block_address := abs getrnd() // BLOCKS                                 '(random block selection results in +-5% wear leveling)
  until field[BlockState][block_address] <> B_TEMP

  ifnot field[BlockState][block_address]                                        'if the block is B_FREE, change its state to B_TEMP and exit
        field[BlockState][block_address] := B_TEMP
        return

  ' now we are using head or body so we have to move it!
  freeIndex := abs getrnd() // blockFreeCount                                   'randomly pick an B_FREE block to move the B_HEAD/B_BODY block to
  repeat freeBlockAddress from 0 to BLOCKS - 1
        ifnot field[BlockState][freeBlockAddress]                               'if the block is B_FREE
          ifnot freeIndex--
                quit

  flash_read_block(block_address, @tmpBlockBuffer, $000, $FFF)                  'read the B_HEAD/B_BODY block
  next_cycle_bits := next_active_cycle(tmpBlockBuffer.[7..5])                   'advance its lifecycle
  program_block(freeBlockAddress, @tmpBlockBuffer, next_cycle_bits)             'program the B_FREE block with the B_HEAD/B_BODY data
  activate_block(freeBlockAddress, next_cycle_bits)                             'activate the B_FREE block, now superior to the original block
  cancel_block(block_address)                                                   'cancel the original block to complete the move

  field[IDToBlock][tmpBlockBuffer.LONG.[19..8]] := freeBlockAddress             'update IDToBlock table
  field[BlockState][freeBlockAddress] := field[BlockState][block_address]\B_TEMP  'update blocks' states, new block is B_TEMP


pri get_file_head_signature(p_filename) : foundSignature | block_address, BYTE header[FILENAME_SIZE]
' Look up file by name and return the block state bits of the files' head block (or 0 if file not found)
'
'' @param p_filename - address of a zstring containing the filename
' @returns foundSignature - the block state bits of the head block (or 0 if file not found)

' Local Variables:
' @local block_address - the block offset within the file system
' @local BYTE header[FILENAME_SIZE] - a temp buffer the block's filename is read into for compare

  repeat block_address from 0 to BLOCKS - 1                                     'scan head blocks for filename
        if field[BlockState][block_address] == B_HEAD                           'is this a head block?
          flash_read_block(block_address, @header, $000, $03F)                  'yes, read first 64 bytes of block
          if strcomp(p_filename, @header[$004])                                 'does the filename match?
                foundSignature := LONG[@header]                                 'yes, return first long of header (always non-zero or logically TRUE)
                quit                                                            ' end the repeat, we have our answer


pri is_file_open(p_filename, mode_bits) : result | handle

' Return true if named file is open
'
'' @param p_filename - address of a zstring containing the filename
' @param mode_bits - some combiantion of H_READ, H_WRITE, H_REWRITE
' @returns status - T/F where T means the file is open

' Local Variables:
' @local handle - tmporary handle to check for availability

  repeat handle from 0 to MAX_FILES_OPEN - 1                                    'for each handle is already open?
    if hStatus[handle] & mode_bits
      if strcomp(@hFilename + handle * FILENAME_SIZE, p_filename)
        return true


pri check_block_fix_dupe_id(thisBlockAddress) | otherBlockAddress, thisCycleBits, otherCycleBits, thisBlockID

' If there is more than one block with this blocks ID, cancel the older block
'
' @param thisBlockAddress - the block offset within the file system for "this" block

' Local Variables:
' @local otherBlockAddress -the block offset within the file system for the "other" block
' @local thisCycleBits - the lifecycle bits of "this" block
' @local otherCycleBits - the lifecycle bits of the "other" block
' @local thisBlockID - the blockID of "this" block

  flash_read_block(thisBlockAddress, @thisCycleBits, $000, $000)                'read first byte of block

  ifnot lookdown(thisCycleBits.[7..5]: %011, %101, %110)                        'is block canceled or inactive?
    return                                                                      '..if so, block status remains B_FREE, done

  flash_read_block(thisBlockAddress, @tmpBlockBuffer, $000, $FFF)               'read entire block

  if LONG[@tmpBlockBuffer + $FFC] <> block_crc(@tmpBlockBuffer)                 'is CRC bad?
    cancel_block(thisBlockAddress)                                              '..if so, cancel block to inhibit future CRC checks
    return                                                                      '..block status remains B_FREE, done

  thisBlockID := tmpBlockBuffer.LONG.[19..8]                                    'this block is good, get its ID

  ifnot field[IDValid][thisBlockID]~~                                           'set ID flag and if it wasn't already set..
    field[IDToBlock][thisBlockID] := thisBlockAddress                           '..set IDToBlock to this block
    field[BlockState][thisBlockAddress] := B_TEMP                               '..set B_TEMP status for this block
    return                                                                      '..done

  otherBlockAddress := field[IDToBlock][thisBlockID]                            'ID flag was already set, get other block with same ID

  flash_read_block(otherBlockAddress, @otherCycleBits, $000, $000)              'read first byte of other block

  if lookdown(thisCycleBits.[7..5] << 3 | otherCycleBits.[7..5]: %011_110, %101_011, %110_101)  'if this block is newer..
    field[IDToBlock][thisBlockID] := thisBlockAddress                           '..set IDToBlock to this block
    field[BlockState][thisBlockAddress] := B_TEMP                               '..set B_TEMP status for this block
    field[BlockState][otherBlockAddress] := B_FREE                              '..set B_FREE status for other block
    cancel_block(otherBlockAddress)                                             '..cancel other block
  else
    cancel_block(thisBlockAddress)                                              'else, cancel this block, block status remains B_FREE


pri count_file_bytes(block_address) : bytes_used, bytes_free, block_count | signature

' Return information about a file: blocks allocated, bytes used, bytes free
'
' @param block_address - the offset within the file system of the first block of the file
' @returns bytes_used - the number of bytes written to file
' @returns bytes_free - the number of bytes allocated but not yet written (in the last block)
' @returns block_count - the number of blocks allocation to this file

' Local Variables:
' @local signature - the block state bits of the block being counted

  repeat                                                                        'trace blocks to count file bytes
    flash_read_block(block_address, @signature, $000, $003)                     'read the first long of the head/body block
    block_count++
    case signature.[1..0]
      %00:                                                                      'head/last
        bytes_used := signature.[31..20] - $040
        bytes_free := $FFC - signature.[31..20]
        return
      %01:                                                                      'head/more
        bytes_used := $FFC - $040
      %10:                                                                      'body/last
        bytes_used += signature.[31..20] - $004
        bytes_free := $FFC - signature.[31..20]
        return
      %11:                                                                      'body/more
        bytes_used += $FFC - $004
    block_address := field[IDToBlock][signature.[31..20]]                       'get next block to count


pri locate_file_byte(head_block_address, file_offset) : block_address, end_ptr | signature, offsetToData, lastDataOffset, overallOffset

' locate position (file_offset) within file list of blocks
'
' @param head_block_address - the block address of the head block of the file
' @param file_offset - the byte offset from the beginning of the file
' @returns locn_block_address - the block containing the location
' @returns locn_end_ptr - the offset within the block to the location

' Local Variables:
' @local signature - the block state bits of the block being checked
' @local offsetToData - offset to first data byte in block
' @local lastDataOffset - offset just past last data byte in block
' @local overallOffset - calculated file offset from start of block chain

  block_address := head_block_address
  repeat                                                                                                'trace blocks to count file bytes
    flash_read_block(block_address, @signature, $000, $003)                                             'read the first long of the head/body block
    offsetToData := signature.[1] ? $004 : $040                                                         'body or head?
    lastDataOffset := signature.[0] ? $FFC : signature.[31..20]                                         'more or last?
    'debug("locate_file_byte(",uhex(head_block_address, file_offset), ")(",  udec(file_offset), ") ", udec(overallOffset, offsetToData, lastDataOffset))
    if file_offset >= overallOffset and file_offset < overallOffset + lastDataOffset - offsetToData     'if pointer is within block,
      end_ptr := file_offset - overallOffset + offsetToData                                             'if last block,
      'debug("locate_file_byte() WITHIN --> ", uhex(block_address, end_ptr))
      return                                   '..return block and block pointer
    ifnot signature.[0]
      end_ptr := lastDataOffset                                                                         'if last block,
      'debug("locate_file_byte() LAST --> ", uhex(block_address, end_ptr))
      return                                                                                            '..return block and end pointer
    overallOffset += lastDataOffset - offsetToData                                                      'advance position
    block_address := field[IDToBlock][signature.[31..20]]                                               'get next block


pri trace_file_set_flags(block_address, set) : valid | signature, block_id

' Trace file chain marking (or clearing) block states until end of file is reached (or an error in block sequence is found)
'
' @param block_address - the block offset within the file system for the block to trace
' @param set - true to set block states to B_HEAD/B_BODY, false to set block states to B_TEMP
' @returns valid - true if file is valid, false if file is invalid

' Local Variables:
' @local signature - block state bits of block being checked
' @local block_id - the blockID of the block being checked

  flash_read_block(block_address, @signature, $000, $003)                       'read first long of initial block
  field[BlockState][block_address] := set ? B_HEAD : B_TEMP                     'set first block state to B_HEAD or B_TEMP

  repeat BLOCKS                                                                 'limit repeat to BLOCKS in order to return false on endless loop
    ifnot signature.[0]                                                         'if last block, file is complete, return true
      return true
    block_id := signature.[31..20]                                               'get "next" ID from this full block
    ifnot field[IDValid][block_id]                                               'if ID invalid, error!, return false
      return
    block_address := field[IDToBlock][block_id]                                 'get address of block having this ID
    flash_read_block(block_address, @signature, $000, $003)                     'read first long of "next" block
    ifnot signature.[1]                                                         'if "next" is head block, error!, return false
      return
    field[BlockState][block_address] := set ? B_BODY : B_TEMP                   'set block state to B_BODY or B_TEMP


pri ensure_handle_mode(handle, mode_bits) : result

' Determine if handle is open with dedired mode
'
' @param handle - handle to a file that might be open for read or read/write
' @param mode_bits - some combiantion of H_READ, H_WRITE, H_REWRITE
' @returns status - E_BAD_HANDLE if the handle is not valid,
' .. E_FILE_MODE if the file is not open in desired mode,
' .. otherwise 0 for success

  if handle < 0 or handle > MAX_FILES_OPEN - 1
    result := E_BAD_HANDLE
  elseif hStatus[handle] & mode_bits
    result :=  SUCCESS
  else
    result :=  E_FILE_MODE


pri write_block(handle) | ptr, block_id, block_address

' Commit the handle's block buffer to file system
'
' @param handle - handle to a file that is open for write or rewrite

' Local Variables:
' @local ptr - the address of the 4KB buffer for the file associated with this handle
' @local block_id - the blockID of the block being written
' @local block_address - the offset within the file system of the block to write

  ptr := buffer_pointer(handle)                                                 'get buffer pointer
  block_id := LONG[ptr].[19..8]                                                 'get the block ID
  block_address := next_block_address()                                         'get the new block to write, sets block state to B_TEMP

  if block_id == hHeadID[handle]                                                'if this is the head block
        program_block(block_address, ptr, hHeadCycle[handle])                   '..program block with head cycle
        hHeadBlock[handle] := block_address                                     '..remember the block so that it can be activated on close
  else                                                                          'else, this is a body block
        program_block(block_address, ptr, %011)                                 '..program block with new cycle
        activate_block(block_address, %011)                                     '..activate block
        field[IDToBlock][block_id] := block_address                             '..set IDToBlock
        field[BlockState][block_address] := B_BODY                              '..change block state from B_TEMP to B_BODY
  hDirtyBuff[handle] := false                                                   ' marke the buffer as clean (not modified)


pri seek_to_block(handle, file_position) : status | block_address, end_ptr
' position to location within file by locating the buffer containing the byte at file_position, loading it then setting
' the file pointer (within buffer) to the location correspondng to the byte at file_position
'
' @param handle - handle to a file that is open for read or read/write
' @param file_position - file-relative postion to which to position the file pointer
' @returns status - otherwise 0 for success

    block_address, end_ptr := locate_file_byte(hHeadBlock[handle], file_position)
    hSeekPtr[handle] := end_ptr                                       'set file pointer to position within block
    flash_read_block(block_address, buffer_pointer(handle), $000, $FFF)         'read the block into the buffer


pri seek_wr_byte(handle, byteValue) : result | ptr, nextBlockID

' Write a byte to a file that is open for seeking read/write
''
' @param handle - handle to a file that is open for write or rewrite
' @param byteValue - value to write to the file
' @returns result - E_BAD_HANDLE if the handle is not valied,
' .. E_FILE_MODE if the file is not open for writing,
' .. otherwise 0 to indicate SUCCESS

' Local Variables:
' @local ptr - the address of the 4KB buffer for the file associated with this handle
' @local nextBlockID - block ID of the next block to write to the file

  ptr := buffer_pointer(handle)                                      'get buffer pointer

  if hSeekPtr[handle] == $FFC                                         'current block full?
    ' if at end of file
    ifnot LONG[ptr].[0]                                               ' if last block
      ' block is already full, then write it as a 'more' block, and get a new block as tail and link this block to the new tail
      nextBlockID := next_available_block_id()                        'get next ID to link to
      if nextBlockID < 0                                              'is an error: no more blocks available?
          return nextBlockID                                          '  return the error code instead of a SUCCESS status

      LONG[ptr].[0]~~                                                 'change block type from 'last' to 'more'
      LONG[ptr].[31..20] := nextBlockID                               'make current block point to next block

      write_block(handle)                                             'write current block

      bytefill(ptr, $FF, BLOCK_SIZE)                                  'make block buffer look erased (fill w/$ff's)
      LONG[ptr].[1..0] := %10                                         'set block type to body/last
      LONG[ptr].[19..8] := nextBlockID                                'set block ID

      hSeekPtr[handle] := $004                                        'point to start of data in new block
    else
      ' NOT at end of file but at end of block
      ' write the existing buffer to block, replacing original then load next block
      flush(handle)                                                   ' if block is dirty write it out (replacing existing)
      flash_read_block(field[IDToBlock][LONG[ptr].[31..20]], ptr, $000, $FFF)  ' load the next block in file
      hSeekPtr[handle] := $004                                        ' point to start of data in body block
  'debug("wr_byte() [",uhex_byte_(byteValue),"]")
  BYTE[ptr][hSeekPtr[handle]++] := byteValue                          'write byte into block buffer, post-increment pointer
  hDirtyBuff[handle] := true                                          'mark the buffer as dirty (modified)


pri seek_rd_byte(handle) : value | ptr, signature

' Read next byte from a file that is open for seeking read/write
'  -- negative value indicates error or end of file
'
' @param handle - the handle to the file from which to read a byte
' @returns byteValue - E_BAD_HANDLE if the handle is not valid,
' .. E_FILE_MODE if the file is not open for reading,
' .. E_END_OF_FILE if no more data,
' .. otherwise, the next byte [0-255] from the file

' Local Variables:
' @local ptr - the address of the 4KB buffer for the file associated with this handle
' @local signature - the block state bits of the block being checked

  ptr := buffer_pointer(handle)                                                 ' get buffer pointer
  signature := LONG[ptr]                                                        ' get first long

  ifnot signature.[0]                                                           ' if last block and no more data, return error code
    if hSeekPtr[handle] == $FFC
      return  (errorCode := E_END_OF_FILE)
  else
    if hSeekPtr[handle] == $FFC                                                 ' else, if no more data then read next body block
      flush(handle)                                                             ' if block is dirty write it out (replacing existing)
      flash_read_block(field[IDToBlock][signature.[31..20]], ptr, $000, $FFF)   ' load the next block in file
      hSeekPtr[handle] := $004                                                  ' point to start of data in body block

  value := BYTE[ptr][hSeekPtr[handle]++]                                        ' get data byte to return and increment pointer
  'debug("seek_rd_byte() [",uhex_byte_(value),"]")


pri flush(handle) : status | ptr, signature, new_block_address, old_block_address, next_cycle_bits

' If buffer is dirty write it to new block and cancel old block
'
' @param handle - a handle to an open file
' @returns status - E_BAD_HANDLE if the handle is not valid, otherwise 0 for SUCCESS

' Local Variables:
' @local ptr - the address of the 4KB buffer for the file associated with this handle
' @local signature - block state bits of block being renamed
' @local new_block_address - the block offset within the file system for the new block
' @local old_block_address - the block offset within the file system for the old block
' @local next_cycle_bits - active lifecycle bits for new block indicating block is newer than block containing the old filename

  if handle < 0 or handle > MAX_FILES_OPEN - 1
    return (errorCode := E_BAD_HANDLE)

  ptr := buffer_pointer(handle)                                                 ' get buffer pointer
  signature := LONG[ptr]                                                        ' get first long

  if hDirtyBuff[handle]                                                         ' if block is dirty write it out (replacing existing)
    ' block is already set up, update lifeCycle and write it, then cancel prior block
    ' write the new block, cancel the old block
    new_block_address := next_block_address()                                   'get a new block to use for renaming (may move head block)
    old_block_address := field[IDToBlock][signature.[19..8]]                    'get head block of file to deactivate

    next_cycle_bits := next_active_cycle(signature.[7..5])                      'get next lifecycle
    program_block(new_block_address, ptr, next_cycle_bits)                      'program updated block of file
    activate_block(new_block_address, next_cycle_bits)                          'activate new block
    cancel_block(old_block_address)                                             'cancel old block

    ' update in-memory file state
    field[IDToBlock][signature.[19..8]] := new_block_address                    'update IDToBlock table
    ' Update our block state
    case signature.[1..0]
      %00:                                                                      ' block is head/last
      %01:                                                                      ' block is head/more
        ' block is a head
        field[BlockState][new_block_address] := B_HEAD                          'make new block HEAD

      %10:                                                                      ' block is body/last
      %11:                                                                      ' block is body/more
        ' block is a body
        field[BlockState][new_block_address] := B_BODY                          'make new block BODY

    field[BlockState][old_block_address] := B_FREE                              'make old block FREE

    hDirtyBuff[handle] := false                                                 ' mark the buffer as clean (not modified)


pri buffer_pointer(handle) : p_buffer

' Return a pointer to the block buffer for this handle
'
' @param handle - the handle to the file
' @returns p_buffer -  the address of the 4KB buffer associated with this handle

  return @hBlockBuff + handle << BLOCK_SIZE_EXP


pri set_filename(handle, p_filename)

' Write filename into block buffer for this handle
'
' @param handle - the handle to the file
' @param p_filename - address of a zstring containing the filename

  bytefill(@hFilename + handle * FILENAME_SIZE, 0, FILENAME_SIZE)               ' empty filename buffer
  strcopy(@hFilename + handle * FILENAME_SIZE, p_filename, FILENAME_SIZE - 1)   ' copy new filename into buffer


pri delete_chain_at_block_id(block_id) | signature, block_address
' Delete blocks from file-chain starting at blockID
'   (this may be the entire file or last block of the file, etc.)
'
' @param blockID - block ID within a file chain from which to start deleting

' Local Variables:
' @local signature - block state bits of block being removed
' @local block_address - the block offset within the file system of block being removed

  repeat                                                                        'trace file and cancel IDs, block states, and blocks
        field[IDValid][block_id]~                                               'clear ID flag
        block_address := field[IDToBlock][block_id]                             'translate ID to block
        field[BlockState][block_address] := B_FREE                              'set block state to B_FREE
        cancel_block(block_address)                                             'cancel block
        flash_read_block(block_address, @signature, $000, $003)                 'read first long of block
        block_id := signature.[31..20]                                          'get ID of next block
  while signature.[0]                                                           'if not last block, loop


pri next_active_cycle(cycleIn) : cycleOut

' Calculate and return the next active lifecycle pattern in (3 -> 5 -> 6 -> 3 -> 5 -> 6 -> 3... pattern)
'
' @param cycleIn - current lifecycle pattern
' @returns cycleOut - next lifecycle pattern in sequence

  cycleOut := (cycleIn * %001_001) >> 1 & %111          'get next lifecycle pattern


pri block_crc(p_block_buffer) : crc
' Calculate and return the CRC for this pointed to block
'
' @param p_block_buffer - the address of the 4KB buffer for the file associated with this handle
' @returns crc - the calculated CRC for the block

  return getcrc(p_block_buffer, $AD0424F3 rev 31, BLOCK_SIZE - 4)  'compute CRC of a buffered block


con { flash operations }

pri flash_read_block(block_address, p_buffer, firstByte, lastByte)

' Return byte(s) read from physical block into memory at p_buffer
'
' @param block_address - the block offset within the file system
' @param p_buffer - memory location in which to place the data
' @param firstByte - address of first byte to read
' @param lastByte - address of last byte to read

  'debug("* rb(", uhex_word_(block_address), ", ", uhex_word_(firstByte), ", ", uhex_word_(lastByte),")")
  flash_command($03 | (FIRST_BLOCK + block_address) << 20 | firstByte << 8, 4)  'read 4KB block
  flash_receive(p_buffer, lastByte - firstByte + 1)                        'receive block data


pri program_block(block_address, p_buffer, cycle_bits) | pageIndex

' Write block in memory at buffAddress to physical block
'
' @param block_address - the block offset within the file system
' @param p_buffer - memory location from which to get the data
' @param cycle_bits - lifeCycle bit-pattern to place into block

' Local Variables:
' @local pageIndex - index [0-15] of 256-Byte page within 4KB block

  flash_command($06, 1)                                                         'enable write
  flash_command($20 | (FIRST_BLOCK + block_address) << 20, 4)                   'erase 4KB block

  BYTE[p_buffer].[7..5] := cycle_bits                                           'install lifecycle for CRC computation
  LONG[p_buffer + $FFC] := block_crc(p_buffer)                                  'compute and install CRC
  BYTE[p_buffer].[7..5]~~                                                       'remove CRC, block will be inactive until activated

  flash_wait()                                                                  'wait for erasure to complete (~45ms)

  repeat pageIndex from 0 to 15                                                 'program 16 pages within 4KB block
    flash_command($06, 1)                                                                'enable write
    flash_command($02 | (FIRST_BLOCK + block_address) << 20 | pageIndex << 16, 4)        'program
    flash_send(p_buffer + pageIndex << 8, 256)                                           'send 256 bytes
    flash_wait()                                                                                                             'wait for programming to complete (~400us)


pri activate_block(block_address, cycle_bits)

' Write new activation pattern into block
'
' @param block_address - the block offset within the file system
' @param cycle_bits - lifeCycle bit-pattern to place into block

  program_bit(block_address, cycle_bits << 5 | %00011111)                       'clear one cycle bit to activate block


pri cancel_block(block_address)

' Clear the block's cycle bits to cancel it
'
' @param block_address - the block offset within the file system

  'debug("* cancel block")
  program_bit(block_address, %00011111)                                         'clear all cycle bits to cancel block


pri program_bit(block_address, bit_pattern)

' Write new bit_pattern into 1st byte of block (this contains the life-cycle bits) this is our most atomic operation
'
' @param block_address - the block offset within the file system
' @param bit_pattern - the value to be placed in first byte of block

  flash_command($06, 1)                                                         'enable write
  flash_command($02 | (FIRST_BLOCK + block_address) << 20, 4)                   'program
  flash_send(@bit_pattern, 1)                                                   'send byte with bit pattern
  flash_wait()                                                                  'wait for programming to complete


pri flash_wait()| statusBits

' Wait for FLASH Chip to become ready
'

' Local Variables:
' @local statusBits - status register bits read from FLASH Chip

  repeat
    flash_command($05, 1)                                                       'read status register
    flash_receive(@statusBits, 1)
  while statusBits.[0]                                                          'loop until BUSY bit clear


pri flash_command(command, count)
' Send flash command to FLASH Chip via SPI
'
' @param command - the command for the chip to execute
' @param count - number of bytes to send

                org

                fltl    #SF_MISO                        '2!     DO input

                fltl    #SF_SCLK                        '2!     reset CK smart pin
                wrpin   #%01_00101_0,#SF_SCLK           '2              set CK for transition output, starts out low
                wxpin   #4,#SF_SCLK                     '2              set timebase to 4 clocks per transition

                drvh    #SF_CS                          '2!     CS high
                waitx   #14                             '2+14   CS deselect is 50ns at 350 MHz (50 / 2.777ns = 18)
                drvl    #SF_CS                          '2!     CS low

                movbyts command,#%%1230                 'reverse order of post-command address bytes for sending

                end

                flash_send(@command, count)             'send command


pri flash_send(p_buffer, count) | tx_byte

' Write bytes to the FLASH Chip via SPI
'
' @param p_buffer - memory location from which to get the data
' @param byteCount - number of bytes to send

' Local Variables:
' @local tx_byte - the byte value being sent over SPI

                org

                rdfast  #0,p_buffer                     'start fast read

.byte           rfbyte  tx_byte                         '2              read byte

                rep     @.r,#1                          '2              protect from interrupts
                fltl    #SF_SCLK                        '2!     reset smart pin CK
                drvl    #SF_SCLK                        '2!     start smart pin CK, starts base period
                shl     tx_byte,#24 + 1      wc         '2              get D7
                drvc    #SF_MOSI                        '2!     output D7
                wypin   #16,#SF_SCLK                    '2*     begin 16 clock transitions
                rep     @.r,#7                          '2              repeat to output D6..D0
                shl     tx_byte,#1           wc         '2              get data bit
                drvc    #SF_MOSI                        '2!     output data bit
                waitx   #2                              '2+2    delay makes 8 clocks/bit
.r
                djnz    count,#.byte                    '4|2    loop if another byte to send

                drvl    #SF_MOSI                        '2!     DI low

                end

pri flash_receive(p_buffer, count) | rx_byte

' Read bytes from the FLASH Chip via SPI
'
' @param p_buffer - memory location into which to put the data
' @param count - number of bytes to receive

' Local Variables:
' @local rx_byte - gather bits received into this byte

                org

                wrfast  #0,p_buffer                     'start fast write

.byte   rep     @.r,#1                                  '2              protect from interrupts
                fltl    #SF_SCLK                        '2!     reset smart pin CK
                drvl    #SF_SCLK                        '2!     start smart pin CK, starts base period
                wypin   #16,#SF_SCLK                    '2*     begin 16 clock transitions
                waitx   #3                              '2+3    align TESTP's to before clock fall (DC..350MHz+)
                rep     @.r,#8                          '2              repeat to input D7..D0
                waitx   #2                              '2+2    delay makes 8 clocks/bit
                testp   #SF_MISO                 wc     '2              input data bit
                rcl     rx_byte,#1                      '2              save data bit
.r
                wfbyte  rx_byte                         '2              write byte
                djnz    count,#.byte                    '4|2    loop if another byte to receive

                drvh    #SF_CS                          '2!     CS high, terminates command
                wypin   #1,#SF_SCLK                     '2*     CK high, leave SD card CS high

                end


{   ' REMOVE BEFORE FLIGHT: uncomment this line before release!!!

' ----------------------------------------------------------------------------------------------
'   these methods are for regression testing only - they are not used in production code

con { constants exposed for regression testing }

     BYTES_IN_HEAD_BLOCK = 4028
     WORDS_IN_HEAD_BLOCK = BYTES_IN_HEAD_BLOCK/2
     LONGS_IN_HEAD_BLOCK = BYTES_IN_HEAD_BLOCK/4

     BYTES_IN_BODY_BLOCK = 4088
     WORD_IN_BODY_BLOCK = BYTES_IN_BODY_BLOCK/2
     LONGS_IN_BODY_BLOCK = BYTES_IN_BODY_BLOCK/4

     MAX_FILE_LEN_IN_BLOCKS = 16 ' not real just our limit for passing data back to UT's

con { methods supporting regression testing }

pub TEST_count_file_bytes(p_filename) : bytes_used, bytes_free, block_count | signature

'' TEST METHOD: return information about a file: blocks allocated, bytes used, bytes free
''
'' @param p_filename - address of a zstring containing the filename
'' @returns bytes_used - the number of bytes written to file, E_FILE_NOT_FOUND if the file doesn't exist
'' @returns bytes_free - the number of bytes allocated but not yet written (in the last block)
'' @returns block_count - the number of blocks allocation to this file

' Local Variables:
' @local signature - the block state bits of the block being counted

  errorCode := SUCCESS
  if signature := get_file_head_signature(p_filename)                           'does file exist?
    bytes_used, bytes_free, block_count := count_file_bytes(field[IDToBlock][signature.[19..8]])
  else
    bytes_used := (errorCode := E_FILE_NOT_FOUND)

dat { regression testing buffers and such }

   blockForUser     BYTE    0[4096]
   signatures       LONG    0[MAX_FILE_LEN_IN_BLOCKS]

pub TEST_getHead4kBlock(p_filename) : p_buffer | signature

'' TEST METHOD: Return the named file's head block
''
'' @param p_filename - address of a zstring containing the filename
'' @returns p_buffer - address of a 4KB buffer containing the head block

' Local Variables:
' @local signature - temporary storage for a block signature

    p_buffer := @blockForUser
    ifnot signature := get_file_head_signature(p_filename)                      'if file doesn't exist...
        return (errorCode := E_FILE_NOT_FOUND)
    flash_read_block(field[IDToBlock][signature.[19..8]], @blockForUser, $000, $FFF)   'read head block into buffer


pub TEST_getFileBlockSignatures(p_filename) : p_sigLong, sigCount | signature, block_address

'' TEST METHOD: return the named file's list block signatures for blocks allocated to the file
''
'' @param p_filename - address of a zstring containing the filename
'' @returns p_sigLong - address of a long array containing the block signatures
'' @returns sigCount - the number of signatures in the array

' Local Variables:
' @local signature - temporary storage for a block signature
' @local block_address - the block offset within the file system

    p_sigLong := @signatures
    ifnot signature := get_file_head_signature(p_filename)                      'if file doesn't exist...
        return 0, 0                                                             '  return 0, 0
    repeat
        LONG[@signatures][sigCount++] := signature                              ' place this signature in list
        ifnot signature.[0]                                                     ' if last block, exit loop
            quit
        if sigCount >= MAX_FILE_LEN_IN_BLOCKS - 1                               ' if filled table, exit loop
            quit
        block_address := field[IDToBlock][signature.[31..20]]                   'get next block address
        flash_read_block(block_address, @signature, $000, $003)                 'read the first long of the head/body block

' ----------------------------------------------------------------------------------------------
'}

con { technical details }

{
head/last block
------------------------------------------------------------------------------------------------
000..003        long {EndPtr[11:0], ThisID[11:0], %vvv11100}    'vvv = lifecycle, 00 = head/last
004..03F        byte filename[60]                               'filename
040..FFB        byte data[4028]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB


head/more block
------------------------------------------------------------------------------------------------
000..003        long {NextID[11:0], ThisID[11:0], %vvv11101}    'vvv = lifecycle, 01 = head/more
004..03F        byte filename[60]                               'filename
040..FFB        byte data[4028]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB


body/last block
------------------------------------------------------------------------------------------------
000..003        long {EndPtr[11:0], ThisID[11:0], %vvv11110}    'vvv = lifecycle, 10 = body/last
004..FFB        byte data[4088]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB


body/more block
------------------------------------------------------------------------------------------------
000..003        long {NextID[11:0], ThisID[11:0], %vvv11111}    'vvv = lifecycle, 11 = body/more
004..FFB        byte data[4088]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB



vvv lifecycle rules
- single-zero ring counter state sequence is 011..101..110..repeat
- the block with the greater state is the valid block between two blocks with identical IDs
- this allows for make-before-break block replacement that can be recovered after unexpected power loss
-------------------------------------------------------------------------------------------------------
111                     inactive        no zeroes
011/101/110             active          one zero
001/010/100/000         canceled        two or three zeroes

011 > 110               new > old
101 > 011               new > old
110 > 101               new > old

}


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
