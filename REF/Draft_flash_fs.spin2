'' =================================================================================================
''
''   File....... flash_fs.spin2
''   Purpose.... This object is the full flash file system driver for the P2
''               it manages all but the first 512KB of the flash chip (where the boot image is stored)
''               it provides a standard file system interface to the flash chip
''   Author..... Chip Gracey
''   Conrtributions..... Jon McPhalen, Stephen M Moraco
''               -- see below for terms of use
''   E-mail.....stephen@ironsheep.biz
''   Started.... AUG 2023
''   Updated.... 23 AUG 2023
''
'' =================================================================================================


con { version }

  LIB_VERSION = 120                                             ' 1.2.0

  #true,  ON, OFF
  #false, NO, YES


con { fixed io pins }

  PGM_RX   = 63  { I }                                          ' programming / debug
  PGM_TX   = 62  { O }

  SF_CS    = 61  { O }                                          ' flash chip select
  SF_SCLK  = 60  { O }                                          ' flash clock
  SF_MOSI  = 59  { O }                                          ' flash data in
  SF_MISO  = 58  { I }                                          ' flash data out

  LED2     = 57  { O }                                          ' Eval and Edge LEDs
  LED1     = 56  { O }


con { driver constants }

  FIRST_BLOCK      = $080                                       ' Physical address of first block in this flash file system
  LAST_BLOCK       = $FFF                                       ' Physical address of last block in this flash file system
  BLOCKS           = LAST_BLOCK - FIRST_BLOCK+1                 ' Number of blocks in flash allocated to this file system

  BLOCK_SIZE       = $1000                                      ' Size in bytes: 4KB block (4096 bytes)
  BLOCK_SIZE_EXP   = encod BLOCK_SIZE

  MAX_FILES_OPEN   = 2                                          ' Maximum number of files that can be open at one time
  FILENAME_SIZE    = $040-$004                                  ' File name string length: 59 characters plus 0 terminator

  ID_TO_BLOCKS_SZ  = (BLOCKS * 12 + 15) / 16                    ' 12-bit fields in WORD array (rounded to full WORD)
  FLAGS_SIZE       = (BLOCKS * 1 + 7) / 8                       ' 1-bit fields in BYTE array (rounded to full BYTE)
  STATES_SIZE      = (BLOCKS * 2 + 7) / 8                       ' 2-bit fields in BYTE array (rounded to full BYTE)


  OKAY             = 0                                          ' No error / Success
  SUCCESS          = OKAY                                       ' No error / Success

  B_FREE           = %00                                        ' Block is not in use (free)
  B_TEMP           = %01                                        ' Block is being put to use
  B_HEAD           = %10                                        ' Block is head of a file (contains filename)
  B_BODY           = %11                                        ' BLock is body of file (any blocks after head)

  H_READ           = %001                                       ' Existing file is being read
  H_WRITE          = %010                                       ' New file is being written
  H_REWRITE        = %100                                       ' Existing file is being rewritten

  H_READ_WRITE     = H_READ | H_WRITE | H_REWRITE               ' (Any) File is open for reading and/or writing
  H_WRITE_ONLY     = H_WRITE | H_REWRITE                        ' File is open for writing or rewriting

  ' Error return codes

  E_BAD_HANDLE     = -1                                         ' Error: Handle in invalid
  E_NO_HANDLE      = -2                                         ' Error: Out of available handles
  E_FILE_NOT_FOUND = -3                                         ' Error: File not present
  E_DRIVE_FULL     = -4                                         ' Error: Out of space on flash chip
  E_FILE_WRITING   = -5                                         ' Error: File is open for writing
  E_FILE_READING   = -6                                         ' Error: File is open for reading
  E_FILE_OPEN      = -7                                         ' Error: File is open
  E_FILE_EXISTS    = -8                                         ' Error: the File exists
  E_END_OF_FILE    = -9                                         ' Error: no more data avaiable, at end of file
  E_FILE_MODE      = -10                                        ' Error: file not opened in desired mode
  E_FILE_SEEK      = -11                                        ' Error: Attempted seek past end of file
  E_BAD_BLOCKS_REMOVED = -12                                    ' Error: Block bit failure detetected, bad blocks removed
  E_NO_LOCK_AVAIL  = -13                                        ' Error: Unable to obtain a LOCK for driver use
  E_TRUNCATED_STRING = -14                                      ' Error: Buffer full, before reaching string terminator
  E_INCOMPLETE_STRING = -15                                     ' Error: End of file reached before string terminator

dat { pre-initialized: driver state tracking tables }

' physically: 3/4 of a word (12 bits) for every valid block ID, 12 bits per ID
' logically: a "BLOCKS"-sized array of 12-bit variables, 1 for ea. block ID - indexed by block ID
' contains block_address in ea. 12 bit field
IDToBlocks    WORD      0[ID_TO_BLOCKS_SZ]                                      'ID-to-block translation table
IDToBlock     LONG      0                                                       '(field pointer to 12-bit variables)

' physically: 1 byte for every 8 valid block IDs, 1 bit per block ID
' logically: a "BLOCKS"-sized array of single bit variables, 1 for ea. block ID - indexed by block ID
' contains [0,1] in ea. 1 bit field, where 1 means ID is valid
IDValids      BYTE      0[FLAGS_SIZE]                                           'ID-valid flags
IDValid       LONG      0                                                       '(field pointer to 1-bit variables)

' physically: 1 byte for every 4 valid block IDs, 2 bits per block ID
' logically: a "BLOCKS"-sized array of 2-bit variables, 1 for ea. block ID - indexed by block ID
' contains a Block-State value in ea. 2 bit field [B_FREE, B_TEMP, B_HEAD, B_BODY]
BlockStates   BYTE      0[STATES_SIZE]                                          'block states
BlockState    LONG      0                                                       '(field pointer to 2-bit variables)

tmpBlockBuffer BYTE     0[BLOCK_SIZE]                                           'buffer used for copying blocks

' handle-related variables and buffers
'   handle is index into each of the arrays below

hStatus       BYTE    0[MAX_FILES_OPEN]                                         'handle: status [sREAD, sWRITE, sREWRITE]
hHeadID       WORD    0[MAX_FILES_OPEN]                                         'handle: head blockID
hHeadBlock    WORD    0[MAX_FILES_OPEN]                                         'handle: head block_address
hHeadCycle    BYTE    0[MAX_FILES_OPEN]                                         'handle: head block lifecycle
hBlockPtr     WORD    0[MAX_FILES_OPEN]                                         'handle: pointer to next byte in block
hBlockBuff    BYTE    0[MAX_FILES_OPEN * BLOCK_SIZE]                            'handle: 4KB buffer for file data
hFilename     BYTE    0[MAX_FILES_OPEN * FILENAME_SIZE]                         'handle: 59+1 byte buffer for filename

errorCode     LONG    0                                                         'most recent error code

fs_lock       LONG    -1                                                        'flash lock semaphore for driver use

fs_mounted    LONG    false                                                     ' T/F where T means the filesystem is mounted

pub null()

'' This is not an application
''  (invoke format() or mount() to use the flash file system)


pub version() : result

'' Returns flash file system library version as integer
'' -- e.g., version 120 is 1.2.0 (major, minor, bugfix)

  return LIB_VERSION


pub serial_number() : snHi, snLo

'' Returns 64-bit unique id of flash chip
''
'' @returns snHi - high 32 bits of 64-bit unique id of flash chip
'' @returns snLo - low 32 bits of 64-bit unique id of flash chip

  flash_command($4B, 1)
  flash_send($00, 4)
  flash_receive(@snHi, 8)

  ' UID values are stored Big Endian
  ' -- swap ends to correct LE reads from flash

  org
                        movbyts   snHi, #%%0123
                        movbyts   snLo, #%%0123
  end


pub mount() : status | block_address, cycleBits, signature

'' Mount the filesystem so it is ready to use after scanning all blocks and initilizing internal tables and buffers
''
'' @returns status - E_BAD_BLOCKS_REMOVED if BAD blocks were found and fixed,
'' .. E_NO_LOCK_AVAIL if all 16 LOCKs are in use, otherwise 0 for success

' Local Variables:
' @local block_address - the block offset within the file system
' @local cycleBits - lifeCycle bit-pattern to place into block
' @local signature - block state bits of block being checked

  errorCode := SUCCESS                                                          ' preset to success

  ' don't mount if already mounted
  if fs_mounted
    'debug("* already mounted, SKIP")
    return
  else
    fs_mounted := true
  debug("* mount()")

  if fs_lock == -1
    fs_lock := locknew()                                                          'reserve a lock for driver use
    if(fs_lock < 0)                                                               'if lock allocation failed
        fs_mounted := false                                                         ' clear "mounted" inidcation
        return (errorCode := E_NO_LOCK_AVAIL)                                       '..abort with error

  'debug("- have lock, trying...")
  repeat while locktry(fs_lock) == 0                                            ' try to get the lock
    waitms(100)                                                                 ' .. wait 1/10 second fi didn't

  'debug("- mounting...")
  bytefill(@hStatus, 0, MAX_FILES_OPEN)                                         'clear handles
  bytefill(@IDValids, 0, Flags_SIZE)                                            'clear ID flags
  bytefill(@BlockStates, 0, States_SIZE)                                        'clear block states to B_FREE

  IDToBlock  := ^@IDToBlocks.[11..0]                                            'set field pointers
  IDValid    := ^@IDValids.[0]
  BlockState := ^@BlockStates.[1..0]

  'debug("- fixing power-out leftovers...")
  repeat block_address from 0 to BLOCKS - 1                                     'check each block and fix any duplicate IDs
    check_block_fix_dupe_id(block_address)                                      '(recovers from incomplete block switchover due to power loss)

  'debug("- locating files...")
  repeat block_address from 0 to BLOCKS - 1                                     'trace head blocks and cancel any broken files
    if field[BlockState][block_address] == B_TEMP                               'is this a valid block?
      flash_read_block(block_address, @cycleBits, $000, $000)                   'yes, read first byte of block
      ifnot cycleBits.[1]                                                       'is this also a head block?
        ifnot trace_file_set_flags(block_address, true)                         'yes, trace file, set block states to B_HEAD/B_BODY
          trace_file_set_flags(block_address, false)                            'if error, retrace file, return block states to B_TEMP

  'debug("- clearing dead blocks...")
  repeat block_address from 0 to BLOCKS - 1                                     'cancel B_TEMP blocks that didn't become B_HEAD/B_BODY blocks
    if field[BlockState][block_address] == B_TEMP                               'is this an B_TEMP block?
      flash_read_block(block_address, @signature, $000, $003)                   'if so, read first long of block to get ID
      field[IDValid][signature.[19..8]]~                                        '..cancel ID flag
      field[BlockState][block_address] := B_FREE                                '..return block state to B_FREE
      cancel_block(block_address)                                               '..cancel block to inhibit future CRC checks
      'debug(" -- found dead block...")
      status :=  (errorCode := E_BAD_BLOCKS_REMOVED)

  'debug("- mount done")

  lockrel(fs_lock)              ' release the lock, we're done with it
  'debug("- lock released")


pub unmount() | handle

'' Prepare for shutdown / power-off by closing any open files
''

' Local Variables:
' @local handle - temporary handle to check for open files
    debug("* unmount()")
    repeat handle from 0 to MAX_FILES_OPEN - 1              ' for each handle
    if hStatus[handle]                                    ' if handle is open...
        close(handle)                                       ' close it!


pub format() : status | block_address, cycleBits

'' Format the file system blocks and (re)mount it
''
'' @returns status - E_BAD_BLOCKS_REMOVED if BAD blocks were found and fixed,
'' .. E_NO_LOCK_AVAIL if all 16 LOCKs are in use, otherwise 0 for success

' Local Variables:
' @local block_address - the block offset within the file system
' @local cycleBits - lifeCycle bit-pattern to place into block

  'debug("* format()")
  ' ensure we have a lock first!  Abort if we can't get one

  if fs_lock == -1
    fs_lock := locknew()                                                        'reserve a lock for driver use
    if(fs_lock < 0)                                                             'if lock creation failed
      return (errorCode := E_NO_LOCK_AVAIL)                                     '..abort with error

  'debug("- have lock, trying...")
  repeat while locktry(fs_lock) == 0                                            ' try to get the lock
    waitms(100)                                                                 ' .. wait 1/10 second fi didn't

  'debug("- formatting...zzz")
  repeat block_address from 0 to BLOCKS - 1                                     'cancel all active blocks
    flash_read_block(block_address, @cycleBits, $000, $000)
    'if block_address // 128 == 0
    '  debug(" -- block ", uhex_word_(block_address),", cycle...", ubin_byte(cycleBits))
    if lookdown(cycleBits.[7..5] : %011, %101, %110)
      'debug(" -- clearing...")
      cancel_block(block_address)

  'debug("- formatting done")
  fs_mounted := false           ' clear "mounted" indcation so it will mount the scan structures

  lockrel(fs_lock)              ' release the lock, we're done with it
  'debug("- lock released")
  return Mount()                                                                '(re)mount flash

pub error() : result
'' Returns error code from most recent operation
''
'' @returns result - latest error code (0 for no error)

  return errorCode


pub open(p_filename, mode) : handle
'' Open file in mode; return handle (0..n) if successful
''
'' @param p_filename - address of a zstring containing the filename
'' @param mode - the mode in which to open the file:
'' -- mode "r", "R" to read an existing file
'' -- mode "w", "W" to write to a new file (overwrites existing file)
'' -- mode "a", "A" to write to the end of an existing file
'' @returns handle - E_FILE_MODE if mode letter is invalid,
'' .. E_FILE_OPEN if file is already open,
'' .. E_FILE_EXISTS if file exists,
'' .. E_FILE_NOT_FOUND if file does not exist,
'' .. E_NO_HANDLE if no handle is available, otherwise the next available handle

  if is_file_open(p_filename, H_READ_WRITE)  'if file is already open, abort
    return (errorCode := E_FILE_OPEN)

  case mode
    "r", "R" : return open_read(p_filename)
    "w", "W" : return open_write(p_filename)
    "a", "A" : return open_append(p_filename)
    other    : return (errorCode := E_FILE_MODE)

pub open_read(p_filename) : handle | signature

'' Open a file for reading, returning handle if success
''
'' @param p_filename - address of a zstring containing the filename
'' @returns handle - E_FILE_NOT_FOUND if file doesn't exist, E_FILE_WRITING if file is being written, or 0 if successful

' Local Variables:
' @local i -
' @local signature -

'' Open a file for reading, returns handle

  ifnot signature := get_file_head_signature(p_filename)                        'if file doesn't exist, abort
    return (errorCode := E_FILE_NOT_FOUND)

  if is_file_open(p_filename, H_WRITE_ONLY)  'if file is being written, abort
    return (errorCode := E_FILE_WRITING)

  handle := new_handle()                                                         'get new handle, aborts if no handle available
  if handle >= 0
    hStatus[handle] := H_READ                                                   'set handle status to READ
    flash_read_block(field[IDToBlock][signature.[19..8]], buffer_pointer(handle), $000, $FFF)   'read head block into buffer
    hBlockPtr[handle] := $040                                                   'point to first data byte in head block
    set_filename(handle, p_filename)                                            'set handle filename


pub open_write(p_filename) : handle | signature, ptr

'' Open a file for (re)writing
''
'' @param p_filename - pointer to a zstring containing the filename
'' @returns handle - efileWriting if file is being written, E_FILE_OPEN if file is open, or 0 if successful

' Local Variables:
' @local signature - the block state bits of the block being checked
' @local ptr - the address of the 4KB buffer for the file associated with this handle

  if is_file_open(p_filename, H_READ_WRITE)          'if file already open, abort
    return (errorCode := E_FILE_OPEN)

  handle := new_handle()                                                        'get new handle, aborts if no handle available
  if handle < 0                                                                 ' is error
    return (errorCode := handle)                                                ' yes, error is in handle, return it

  if signature := get_file_head_signature(p_filename)                           'does file already exist?
    hStatus[handle] := H_REWRITE                                                'yes, REWRITING
    hHeadID[handle] := signature.[19..8]                                        'yes, get block ID from head block
    hHeadCycle[handle] := next_active_cycle(signature.[7..5])                   'yes, get next lifecycle from head block
  else
    hStatus[handle] := H_WRITE                                                  'no, WRITING
    hHeadID[handle] := next_available_block_id()                                'no, get new ID
    hHeadCycle[handle] := %011                                                  'no, set new lifecycle

  ptr := buffer_pointer(handle)                                                 'get buffer pointer

  bytefill(ptr, $FF, BLOCK_SIZE)                                                'erase block buffer
  LONG[ptr].[1..0] := %00                                                       'set head/last
  LONG[ptr].[19..8] := hHeadID[handle]                                          'set ID
  strcopy(ptr + $004, p_filename, FILENAME_SIZE - 1)                            'set filename

  hBlockPtr[handle] := $040                                                     'point to start of data in head block

  set_filename(handle, p_filename)                                              'set handle filename


pub open_append(p_filename) : handle | signature
'' open for appeand not yet implemented!
''
'' @param p_filename - address of a zstring containing the filename
'' @returns handle - handle to open file if successful,
'' .. E_FILE_NOT_FOUND if file doesn't exist,
'' .. E_FILE_OPEN if file is already open,
'' .. or E_NO_HANDLE if no handle is available

' Local Variables:
' @local signature - the block state bits of the block being checked

if not exists(p_filename)                                                       ' if file doesn't exist, abort
  return (errorCode := E_FILE_NOT_FOUND)

  if is_file_open(p_filename, H_READ_WRITE)                                     ' if file already open, abort
    return (errorCode := E_FILE_OPEN)

  handle := new_handle()                                                        'get new handle, aborts if no handle available
  if handle < 0                                                                 ' is error
    return (errorCode := handle)                                                ' yes, error is in handle, return it

  ' open for write but place file pointer at end of file
  signature := get_file_head_signature(p_filename)                              'does file already exist?
  hStatus[handle] := H_REWRITE                                                  'yes, REWRITING
  hHeadID[handle] := signature.[19..8]                                          'yes, get block ID from head block
  hHeadCycle[handle] := next_active_cycle(signature.[7..5])                     'yes, get next lifecycle from head block

  seek_to_block(handle, file_size(handle))                                      ' set file pointer to end of file


PUB rename(p_old_filename, p_new_filename) : status | signature, new_block_address, old_block_address, next_cycle_bits

'' Rename a a file named p_old_filename to p_new_filename
''
'' @param p_old_filename - address of a zstring containing the existing filename
'' @param p_new_filename - address of a zstring containing the new filename
'' @returns status - E_FILE_NOT_FOUND if old file doesn't exist,
'' .. E_FILE_OPEN if old file is open,
'' .. E_FILE_EXISTS if new file exists,
'' .. otherwise 0 (SUCCESS) if successful

' Local Variables:
' @local signature - block state bits of block being renamed
' @local new_block_address - the block offset within the file system for the new block
' @local old_block_address - the block offset within the file system for the old block
' @local next_cycle_bits - active lifecycle bits for new block indicating block is newer than block containing the old filename

  ifnot signature := get_file_head_signature(p_old_filename)                         'if old file doesn't exist, abort
        return (errorCode := E_FILE_NOT_FOUND)

  if is_File_Open(p_old_filename, H_READ_WRITE)                                       'if old file is open, abort
        return (errorCode := E_FILE_OPEN)

  if get_file_head_signature(p_new_filename)                                         'if new file exists, abort
        return  (errorCode := E_FILE_EXISTS)

  if is_File_Open(p_new_filename, H_READ_WRITE)                                       'if new file is open, abort
        return  (errorCode := E_FILE_EXISTS)

  new_block_address := next_block_address()                                       'get a new block to use for renaming (may move head block)
  old_block_address := field[IDToBlock][signature.[19..8]]                        'get head block of file to rename (AddressOfNextBlock may have changed lookup)

  flash_read_block(old_block_address, @tmpBlockBuffer, $000, $FFF)                       'read head block of file to rename
  bytefill(@tmpBlockBuffer + $004, 0, FILENAME_SIZE)                            'clear filename space to prevent old trailing chrs
  strcopy(@tmpBlockBuffer + $004, p_new_filename, FILENAME_SIZE - 1)              'copy new filename into filename space
  next_cycle_bits := next_active_cycle(tmpBlockBuffer.[7..5])                       'get next lifecycle
  program_block(new_block_address, @tmpBlockBuffer, next_cycle_bits)                 'program first block of renamed file
  activate_block(new_block_address, next_cycle_bits)                                 'activate new block
  cancel_block(old_block_address)                                                  'cancel old block

  field[IDToBlock][signature.[19..8]] := new_block_address                        'update IDToBlock
  field[BlockState][new_block_address] := B_HEAD                                   'make new block HEAD
  field[BlockState][old_block_address] := B_FREE                                   'make old block FREE

PUB delete(p_filename) : status | signature

'' Delete a named file
''
'' @param p_filename - address of a zstring containing the filename
'' @returns status - E_FILE_NOT_FOUND if file doesn't exist, E_FILE_OPEN if file is open, or 0 if successful

' Local Variables:
' @local signature - block state bits of block being removed

  ifnot signature := get_file_head_signature(p_filename)                                                    'if file doesn't exist, abort
        return  (errorCode := E_FILE_NOT_FOUND)

  if is_file_open(p_filename, H_READ_WRITE)                          'if file open in any mode, abort
        return  (errorCode := E_FILE_OPEN)

  delete_chain_at_block_id(signature.[19..8])

pub exists(p_filename) : result

'' Determine if named file is present in file system
''
'' @param p_filename - address of a zstring containing the filename
'' @returns result - True/False where True means the file exists

  return get_file_head_signature(p_filename) ? true : false


pub file_size(p_filename) : fsize | signature

'' Return size of file in bytes
''
'' @param p_filename - pointer to zstring containing the filename
'' @returns fsize - either the size of the file in bytes or E_FILE_NOT_FOUND if the file doesn't exist

' Local Variables:
' @local signature - block state bits of block being checked
  errorCode := SUCCESS
  if signature := get_file_head_signature(p_filename)                               'does file exist?
        return count_file_bytes(field[IDToBlock][signature.[19..8]])              'yes, get file size
  else
     return (errorCode := E_FILE_NOT_FOUND)


PUB close(handle) : status

'' Close an open file, completes file (re)write, frees handle
''
'' @param handle - a file handle to an open file
'' @returns status - either E_BAD_HANDLE if the handle is not valid, otherwise 0 for success

  if handle < 0 or handle > MAX_FILES_OPEN - 1
     return (errorCode := E_BAD_HANDLE)

  case hStatus[handle]~                                                         'get handle and post-clear
    H_READ:                                                                     'READ?
      {okay, nothing to do}
    H_WRITE, H_REWRITE:                                                         'WRITE/REWRITE?

      LONG[buffer_pointer(handle)].[31..20] := hBlockPtr[handle]                'cap last block and write it
      write_block(handle)

      activate_block(hHeadBlock[handle], hHeadCycle[handle])                    'activate head block, replaces file if rewrite

      if hStatus[handle] == H_REWRITE                                           'if file rewrite, delete old file to clean up
        delete_chain_at_block_id(hHeadID[handle])
        field[IDValid][hHeadID[handle]]~~                                       'set IDValid again, since it was cleared during file deletion

      field[IDToBlock][hHeadID[handle]] := hHeadBlock[handle]                   'set IDToBlock
      field[BlockState][hHeadBlock[handle]] := B_HEAD                           'change head block status from B_TEMP to B_HEAD
    other:
      return (errorCode := E_BAD_HANDLE)

  errorCode := SUCCESS


pub seek(handle, position) : result | load_status
'' ...
''
'' @param handle - handle to a file that is open for read or read/write
'' @param position - location within the file to which to position the file pointer
'' @returns result - E_FILE_SEEK if the position is not within the file, E_BAD_HANDLE if the handle is not valid, otherwise 0 for success

' Local Variables:
' @local load_status -

'' Move file pointer to position
'' -- file at handle must be open
'' -- postion must be 0 to length of file
''    * position contrained between 0 and length

  if is_file_open(handle, H_READ_WRITE)                                         ' is file open for read/write?
    if position >= 0 and position <= file_size(handle)                          ' is position within file?
      load_status := seek_to_block(handle, position)                            ' yes, load buffer, setting file pointer to value within the buffer
      if(load_status < 0)                                                       ' did seek_to_block return an error?
        return load_status                                                      ' yes, return the error code
      else
        return SUCCESS                                                          ' no, return SUCCESS
    else
      return (errorCode := E_FILE_SEEK)                                          ' no, abort with error
  else
    return (errorCode := E_BAD_HANDLE)                                           ' no, abort with error

pub write(handle, p_buffer, count) : result | checkValue, byteIndex, wr_value, wr_status

'' Write count bytes from p_buffer to the file associated with handle
''
'' @param handle - the handle to the file to which to write byte(s)
'' @param p_buffer - the address of the buffer containing the users' data to write
'' @param count - the number of bytes to write to the file
'' @returns result - E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_MODE if the file is not open for writing,
'' .. otherwise 0 to indicate SUCCESS

' Local Variables:
' @local checkValue - a temporary variable to hold the status returned from checking the handle
' @local byteIndex - the index into the users' buffer for the next byte to write
' @local wr_value - the next value to be written to the file
' @local wr_status - the status returned from the wr_byte() function

  if checkValue := ensure_handle_mode(handle, H_WRITE | H_REWRITE)  <> 0        ' is handle valid and open for writing?
     return (errorCode := checkValue)                                           ' no, return error code

  'debug("write() [",zstr_(p_buffer),"](",udec_(count),")")
  repeat byteIndex from 0 to count - 1                                          ' for the max length of the buffer
    wr_value := BYTE[p_buffer][byteIndex]
    if wr_status := wr_byte(handle, wr_value) < 0                               ' write a byte to the file
      return (errorCode := wr_status)                                           ' an error occured, return the error code

  errorCode := SUCCESS          ' no error occurred from this operation, clear possibly older outstanding error code

pub wr_byte(handle, byteValue) : result | ptr, nextBlockID, checkValue

'' Write a byte to a file that is open for write or rewrite
''
'' @param handle - handle to a file that is open for write or rewrite
'' @param byteValue - value to write to the file
'' @returns result - E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_MODE if the file is not open for writing,
'' .. otherwise 0 to indicate SUCCESS

' Local Variables:
' @local ptr - the address of the 4KB buffer for the file associated with this handle
' @local nextBlockID - block ID of the next block to write to the file

  if checkValue := ensure_handle_mode(handle, H_WRITE | H_REWRITE)  <> 0        ' is handle valid and open for writing?
     return (errorCode := checkValue)                                           ' no, return error code

  ptr := buffer_pointer(handle)                                     'get buffer pointer

  if hBlockPtr[handle] == $FFC                                      'current block full?
    ' if block is already full, then write it as a 'more' block, and get a new block as tail and link this block to the new tail
    nextBlockID := next_available_block_id()                        'get next ID to link to
    if nextBlockID < 0                                              'is an error: no more blocks available?
        return nextBlockID                                          '  return the error code instead of a SUCCESS status

    LONG[ptr].[0]~~                                                 'change block type from 'last' to 'more'
    LONG[ptr].[31..20] := nextBlockID                               'make current block point to next block

    write_block(handle)                                             'write current block

    bytefill(ptr, $FF, BLOCK_SIZE)                                  'make block buffer look erased (fill w/$ff's)
    LONG[ptr].[1..0] := %10                                         'set block type to body/last
    LONG[ptr].[19..8] := nextBlockID                                'set block ID

    hBlockPtr[handle] := $004                                       'point to start of data in new block

  'debug("wr_byte() [",uhex_byte_(byteValue),"]")
  BYTE[ptr][hBlockPtr[handle]++] := byteValue                       'write byte into block buffer, post-increment pointer


pub wr_word(handle, word_value) : result

'' Write WORD (16-bits) to file associated with handle
'' -- order is Little Endian
''
'' @param handle - the handle of the file to which to write the WORD
'' @param word_value - the 16 bit WORD to write to the file
'' @returns result - E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_MODE if the file is not open for writing,
'' .. otherwise 0 to indicate SUCCESS

  return write(handle, @word_value, 2)


pub wr_long(handle, long_value) : result

'' Write LONG (32-bits) to file associated with handle
'' -- order is Little Endian
''
'' @param handle - the handle of the file to which to write the LONG
'' @param long_value - the 32 bit LONG to write to the file
'' @returns result - E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_MODE if the file is not open for writing,
'' .. otherwise 0 to indicate SUCCESS

  return write(handle, @long_value, 4)


pub wr_str(handle, p_str) : result
'' Write string (including the terminator) from p_str to file associate with handle
''
'' @param handle - the handle of the file to which to write the zString
'' @param p_str - the address of the zString to write to the file
'' @returns result - E_BAD_HANDLE if the handle is not valied,
'' .. E_FILE_MODE if the file is not open for writing,
'' .. otherwise 0 to indicate SUCCESS
  'debug("write_str() [",zstr_(p_str),"](",udec_(strsize(p_str)+1),")")
  return write(handle, p_str, strsize(p_str)+1)                 ' include string terminator


pub read(handle, p_buffer, count) : result | byteIndex, readValue, checkValue

'' Read count bytes from file associated with handle to p_buffer or to end of file which ever comes first
'' -- returns count of bytes read (negative result indicates error)
''
'' @param handle - the handle to the file from which to read bytes
'' @param p_buffer - address of the buffer into which to place the data read
'' @param count - the maximum number of bytes to place into the buffer
'' @returns result - E_BAD_HANDLE if the handle is not valied, E_FILE_WRITING if the file is not open for reading, otherwise the number of bytes read

' Local Variables:
' @local byteIndex - the index into the users' buffer for the next byte to be read
' @local readValue - a temporary variable to hold the byte read from the file (or the returned error code)
' @local checkValue - a temporary variable to hold the status returned from checking the handle

  if checkValue := ensure_handle_mode(handle, H_READ)  <> 0                     ' is handle valid and open for reading?
     return checkValue                                                          ' no, return error code

  repeat byteIndex from 0 to count - 1                                          ' for the max length of the buffer
    if readValue := rd_byte(handle) < 0                                         ' read a byte from the file
      if readValue == E_END_OF_FILE                                             ' if we've reached end of file return the number of bytes read
        return byteIndex
      else
        return readValue                                                        ' another error occured, return the error code
    else
      BYTE[p_buffer][byteIndex] := readValue                                    ' no error, place byte in the users buffer


pub rd_byte(handle) : value | ptr, signature, checkValue

'' Read next byte from file associated with handle
''  -- negative value indicates error or end of file
''
'' @param handle - the handle to the file from which to read a byte
'' @returns byteValue - E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for reading,
'' .. E_END_OF_FILE if no more data,
'' .. otherwise, the next byte [0-255] from the file

' Local Variables:
' @local ptr - the address of the 4KB buffer for the file associated with this handle
' @local signature - the block state bits of the block being checked

  if checkValue := ensure_handle_mode(handle, H_READ)  <> 0         ' is handle valid and open for reading?
     return checkValue                                                          ' no, return error code

  ptr := buffer_pointer(handle)                                                 ' get buffer pointer
  signature := LONG[ptr]                                                        ' get first long

  ifnot signature.[0]                                                           ' if last block and no more data, return error code
    if hBlockPtr[handle] == LONG[ptr].[31..20]
      return  (errorCode := E_END_OF_FILE)
  else
    if hBlockPtr[handle] == $FFC                                                ' else, if no more data then read next body block
      flash_read_block(field[IDToBlock][signature.[31..20]], ptr, $000, $FFF)
      hBlockPtr[handle] := $004                                                 ' point to start of data in body block

  value := BYTE[ptr][hBlockPtr[handle]++]                                         ' return data byte and increment pointer
  'debug("rd_byte() [",uhex_byte_(value),"]")

pub rd_word(handle) : value

'' Read next WORD from file associated with the handle
''
'' @param handle - the handle to the file from which to read a byte
'' @returns value - E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for reading,
'' .. E_END_OF_FILE if no more data,
'' .. otherwise, the next byte [0-255] from the file

  value := read(handle, @value, 2)


pub rd_long(handle) : value

'' Read next LONG from file associated with the handle
''
'' @param handle - the handle to the file from which to read a byte
'' @returns value - E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for reading,
'' .. E_END_OF_FILE if no more data,
'' .. otherwise, the next byte [0-255] from the file

  read(handle, @value, 4)


pub rd_str(handle, p_str, count) : result | byteIndex, readValue, checkValue

'' Read z-string from file at handle into buffer at p_str (count is max length of string + terminator)
''
'' @param handle - the handle to the file from which to read a byte
'' @param p_str - the address of the buffer into which to place the string
'' @param count - the maximum number of bytes to place into the buffer
'' @returns result - E_BAD_HANDLE if the handle is not valid,
'' .. E_FILE_MODE if the file is not open for reading,
'' .. otherwise, the length of the string placed into the buffer

' Local Variables:
' @local byteIndex - the index into the users' buffer for the next byte to be read
' @local readValue - a temporary variable to hold the byte read from the file (or the returned error code)
' @local checkValue - a temporary variable to hold the status returned from checking the handle

  bytefill(p_str, 0, count)                                                     ' clear the users buffer

  if checkValue := ensure_handle_mode(handle, H_READ)  <> 0                     ' is handle valid and open for reading?
     return checkValue                                                          ' no, return error code

  repeat byteIndex from 0 to count - 1                                          ' for the max length of the buffer
    readValue := rd_byte(handle)                                                ' read a byte from the file
    if readValue  < 0                                                           ' have error?
      'debug("EEE: ", sdec(readValue))
      if readValue == E_END_OF_FILE                                             ' yes, if we've reached end of file return the number of bytes read
        BYTE[p_str][byteIndex] := 0                                             ' place a 0 terminator in the users buffer
        return (errorCode := E_INCOMPLETE_STRING)                                      ' return error saying file ended without string terminator
      else
        return readValue                                                        ' another error occured, return the error code
    else
     'debug("ok: ", uhex_byte(readValue))
     if byteIndex == count - 1 and readValue <> 0                              ' no error, if we've reached the end of the buffer and the byte read is not a 0 terminator
        BYTE[p_str][byteIndex] := 0                                             ' ..place a 0 terminator in the users buffer
        return (errorCode := E_TRUNCATED_STRING)                                ' ..abort with error
     else
        BYTE[p_str][byteIndex] := readValue                                     ' no error, place byte in the users buffer (could be terminator)
        if readValue == 0                                                       ' if this is a string terminator...
          return byteIndex                                                      ' ..return the number of bytes placed into the buffer


pub directory(p_block_id, p_filename, p_file_size) | blockID, block_address, signature

'' Get next file's filename and size in bytes via current blockID
''
'' @param p_block_id - the next block ID to check for a file head. (Initialize to 0, will be auto-advanced by each call to this method)
'' @param p_filename - the filename of the file found (or a zero length string if no more files)
'' @param p_file_size - the number of bytes in the file found (or 0 when no more files)

' Local Variables:
' @local blockID - the id of the block being checked
' @local block_address - the offset within the file system of the block being checked
' @local signature - temporary storage for the block state bits of the block being checked

  BYTE[p_filename][0] := 0                                                      'reset filename

  repeat while LONG[p_block_id] < BLOCKS                                        'scan any remaining blockID's for file heads
        blockID := LONG[p_block_id]++                                           'get current blockID and post-increment it
        if field[IDValid][blockID]                                              'block ID valid?
          block_address := field[IDToBlock][blockID]                            'yes, get block from block ID
          if field[BlockState][block_address] == B_HEAD                         'is this a HEAD block?
                flash_read_block(block_address, p_filename, $004, $03F)         'yes, read filename
                LONG[p_file_size] := count_file_bytes(block_address)            'get file size
                return


pub stats() : usedBlocks, freeBlocks, fileCount | blockAddress

'' Get fielsystem stats: used/free block counts and file count
''
'' @returns usedBlocks - the number of blocks in use
'' @returns freeBlocks - the number of free blocks
'' @returns fileCount - the number of files recorded in filesystem

' Local Variables:
' @local blockAddress - the block offset within the file system

  usedBlocks := 0
  freeBlocks := 0
  fileCount := 0

  repeat blockAddress from 0 to BLOCKS - 1
    case field[BlockState][blockAddress]
      B_FREE: freeBlocks++
      B_TEMP: usedBlocks++
      B_HEAD: usedBlocks++
              fileCount++
      B_BODY: usedBlocks++


pub string_for_error(error_code) : p_interpretation

'' Return a string describing the error code
''
'' @param error_code - the error code to translate
'' @returns p_interpretation - interpretation of the errcode

    p_interpretation := @"?? unknonw error code ??"
    case error_code
        E_BAD_HANDLE:     p_interpretation := @"E_BAD_HANDLE: Handle in invalid"
        E_NO_HANDLE:      p_interpretation := @"E_NO_HANDLE: Out of available handles"
        E_FILE_NOT_FOUND: p_interpretation := @"E_FILE_NOT_FOUND: File not present"
        E_DRIVE_FULL:     p_interpretation := @"E_DRIVE_FULL: Out of space on flash chip"
        E_FILE_WRITING:   p_interpretation := @"E_FILE_WRITING: File is open for writing"
        E_FILE_READING:   p_interpretation := @"E_FILE_READING: File is open for reading"
        E_FILE_OPEN:      p_interpretation := @"E_FILE_OPEN: File is open"
        E_FILE_EXISTS:    p_interpretation := @"E_FILE_EXISTS: the File exists"
        E_END_OF_FILE:    p_interpretation := @"E_END_OF_FILE: no more data avaiable, at end of file"
        E_FILE_MODE:      p_interpretation := @"E_FILE_MODE: file not opened in desired mode"
        E_FILE_SEEK:      p_interpretation := @"E_FILE_SEEK: Attempted seek past end of file"
        E_BAD_BLOCKS_REMOVED: p_interpretation := @"E_BAD_BLOCKS_REMOVED: Block bit failure detetected, bad blocks removed"
        E_NO_LOCK_AVAIL:  p_interpretation := @"E_NO_LOCK_AVAIL: Unable to obtain a LOCK for driver use"
        E_TRUNCATED_STRING: p_interpretation := @"E_TRUNCATED_STRING: Buffer full, before reaching string terminator"
        E_INCOMPLETE_STRING: p_interpretation := @"E_INCOMPLETE_STRING: End of file reached before string terminator"


con { low-level support }

pri check_block_fix_dupe_id(thisBlockAddress) | otherBlockAddress, thisCycleBits, otherCycleBits, thisBlockID

' If there is more than one block with this blocks ID, cancel the older block
'
' @param thisBlockAddress - the block offset within the file system for "this" block

' Local Variables:
' @local otherBlockAddress -the block offset within the file system for the "other" block
' @local thisCycleBits - the lifecycle bits of "this" block
' @local otherCycleBits - the lifecycle bits of the "other" block
' @local thisBlockID - the blockID of "this" block

  flash_read_block(thisBlockAddress, @thisCycleBits, $000, $000)                       'read first byte of block

  ifnot lookdown(thisCycleBits.[7..5]: %011, %101, %110)                        'is block canceled or inactive?
    return                                                                      '..if so, block status remains B_FREE, done

  flash_read_block(thisBlockAddress, @tmpBlockBuffer, $000, $FFF)                      'read entire block

  if LONG[@tmpBlockBuffer + $FFC] <> block_crc(@tmpBlockBuffer)                  'is CRC bad?
    cancel_block(thisBlockAddress)                                               '..if so, cancel block to inhibit future CRC checks
    return                                                                      '..block status remains B_FREE, done

  thisBlockID := tmpBlockBuffer.LONG.[19..8]                                    'this block is good, get its ID

  ifnot field[IDValid][thisBlockID]~~                                           'set ID flag and if it wasn't already set..
    field[IDToBlock][thisBlockID] := thisBlockAddress                           '..set IDToBlock to this block
    field[BlockState][thisBlockAddress] := B_TEMP                                '..set B_TEMP status for this block
    return                                                                      '..done

  otherBlockAddress := field[IDToBlock][thisBlockID]                            'ID flag was already set, get other block with same ID

  flash_read_block(otherBlockAddress, @otherCycleBits, $000, $000)                     'read first byte of other block

  if lookdown(thisCycleBits.[7..5] << 3 | otherCycleBits.[7..5]: %011_110, %101_011, %110_101)  'if this block is newer..
    field[IDToBlock][thisBlockID] := thisBlockAddress                           '..set IDToBlock to this block
    field[BlockState][thisBlockAddress] := B_TEMP                                '..set B_TEMP status for this block
    field[BlockState][otherBlockAddress] := B_FREE                               '..set B_FREE status for other block
    cancel_block(otherBlockAddress)                                              '..cancel other block
  else
    cancel_block(thisBlockAddress)                                               'else, cancel this block, block status remains B_FREE


pri trace_file_set_flags(block_address, set) : valid | signature, block_id

' Trace file chain marking (or clearing) block states until end of file is reached (or an error in block sequence is found)
'
' @param block_address - the block offset within the file system for the block to trace
' @param set - true to set block states to B_HEAD/B_BODY, false to set block states to B_TEMP
' @returns valid - true if file is valid, false if file is invalid

' Local Variables:
' @local signature - block state bits of block being checked
' @local block_id - the blockID of the block being checked

  flash_read_block(block_address, @signature, $000, $003)                               'read first long of initial block
  field[BlockState][block_address] := set ? B_HEAD : B_TEMP                      'set first block state to B_HEAD or B_TEMP

  repeat BLOCKS                                                                 'limit repeat to BLOCKS in order to return false on endless loop
    ifnot signature.[0]                                                         'if last block, file is complete, return true
      return true
    block_id := signature.[31..20]                                               'get "next" ID from this full block
    ifnot field[IDValid][block_id]                                               'if ID invalid, error!, return false
      return
    block_address := field[IDToBlock][block_id]                                   'get address of block having this ID
    flash_read_block(block_address, @signature, $000, $003)                             'read first long of "next" block
    ifnot signature.[1]                                                         'if "next" is head block, error!, return false
      return
    field[BlockState][block_address] := set ? B_BODY : B_TEMP                    'set block state to B_BODY or B_TEMP


pri new_handle() : handle | potentialHandle

' Calculate and return next available handle
'
' @returns handle - eNoHandle if no handle is available, otherwise the next available handle

' Local Variables:
' @local potentialHandle - temporary handle to check for availability

  handle := E_NO_HANDLE                                                         'if no handle is available... return this
  repeat potentialHandle from 0 to MAX_FILES_OPEN - 1                           'find first free handle
    ifnot hStatus[potentialHandle]                                              'if handle not in use
      handle := potentialHandle                                                 '..select as handle to use
      quit                                                                      '..exit loop, we have our answer

  if handle < 0                                                                 'if error, set error code
    errorCode := handle

pri is_file_open(p_filename, mode_bits) : result | handle

' Return true if named file is open
'
' @param p_filename - pointer to zstring containing the filename
' @param mode_bits - some combiantion of H_READ, H_WRITE, H_REWRITE
' @returns status - T/F where T means the file is open

' Local Variables:
' @local handle - tmporary handle to check for availability

  repeat handle from 0 to MAX_FILES_OPEN - 1                                    'for each handle is already open?
    if hStatus[handle] & mode_bits
      if strcomp(@hFilename + handle * FILENAME_SIZE, p_filename)
        return true


pri ensure_handle_mode(handle, mode_bits) : result

' Determine if handle is open with dedired mode
'
' @param handle - handle to a file that might be open for read or read/write
' @param mode_bits - some combiantion of H_READ, H_WRITE, H_REWRITE
' @returns status - E_BAD_HANDLE if the handle is not valid,
' .. E_FILE_MODE if the file is not open in desired mode,
' .. otherwise 0 for success

  if handle < 0 or handle > MAX_FILES_OPEN - 1
    result := (errorCode := E_BAD_HANDLE)
  elseif hStatus[handle] & mode_bits
    result :=  SUCCESS
  else
    result :=  (errorCode := E_FILE_MODE)


pri write_block(handle) | ptr, block_id, block_address

' Commit the handle's block buffer to file system
'
' @param handle - handle to a file that is open for write or rewrite

' Local Variables:
' @local ptr -  the address of the 4KB buffer for the file associated with this handle
' @local block_id - the blockID of the block being written
' @local block_address - the offset within the file system of the block to write

  ptr := buffer_pointer(handle)                                                        'get buffer pointer
  block_id := LONG[ptr].[19..8]                                                  'get the block ID
  block_address := next_block_address()                                          'get the new block to write, sets block state to B_TEMP

  if block_id == hHeadID[handle]                                                 'if this is the head block
        program_block(block_address, ptr, hHeadCycle[handle])                     '..program block with head cycle
        hHeadBlock[handle] := block_address                                      '..remember the block so that it can be activated on close
  else                                                                          'else, this is a body block
        program_block(block_address, ptr, %011)                                   '..program block with new cycle
        activate_block(block_address, %011)                                       '..activate block
        field[IDToBlock][block_id] := block_address                               '..set IDToBlock
        field[BlockState][block_address] := B_BODY                                '..change block state from B_TEMP to B_BODY

pri seek_to_block(handle, file_position) : status | block_address, signature, byte_count, in_last_block, bytes_in_block, earlier_count, offset_into_block, offset_past_byte
' position to location within file by locating the buffer containing the byte at file_position, loading it then setting
' the file pointer (within buffer) to the location correspondng to the byte at file_position
'
' @param handle - handle to a file that is open for read or read/write
' @param file_position - file-relative postion to which to position the file pointer
' @returns status - otherwise 0 for success
  status := SUCCESS
  in_last_block := false
  block_address := hHeadBlock[handle]                                            'get address of head block
  repeat                                                                        ' trace blocks to count file bytes
    flash_read_block(block_address, @signature, $000, $003)                     ' read the first long of the head/body block
    case signature.[1..0]
      %00:                                                                      ' block is head/last
        bytes_in_block := signature.[31..20] - $040
        byte_count := bytes_in_block
        in_last_block := true                                                   '   indicate this is the final block
      %01:                                                                      ' block is head/more
        bytes_in_block := $FFC - $040
        byte_count := bytes_in_block
      %10:                                                                      ' block is body/last
        bytes_in_block := signature.[31..20] - $004
        byte_count += bytes_in_block
        in_last_block := true                                                   '   indicate this is the final block
      %11:                                                                      ' block is body/more
        bytes_in_block := $FFC - $004
        byte_count += bytes_in_block
    if in_last_block or byte_count >= file_position                             ' if no more blocks or position is in this block
      quit                                                                      ' yes, exit loop!
    block_address := field[IDToBlock][signature.[31..20]]                       ' no, get next block and loop again

  if file_position > byte_count                                                 ' are we in the last block but postion is past end of block?
    status := (errorCode := E_FILE_SEEK)                                        ' yes, abort with error SEEK PAST END OF FILE
  else
    earlier_count := byte_count - bytes_in_block                                ' count of byte in all blocks but last
    offset_into_block := file_position - earlier_count                          ' count of bytes to seek position within block
    offset_past_byte := (signature.[1] == 0 ? $040 : $004) + offset_into_block + 1 ' offset to addr after seek positon within block
    hBlockPtr[handle] := offset_past_byte                                       'set file pointer to position within block
    flash_read_block(block_address, buffer_pointer(handle), $000, $FFF)         'read the block into the buffer


pri next_block_address() : block_address | blockFreeCount, freeBlockAddress, freeIndex, next_cycle_bits

' Return the address of the next block to which we should write
'
' @returns block_address - E_DRIVE_FULL if no free block is available, otherwise the address of the next block to use

' Local Variables:
' @local blockFreeCount - the count of free blocks
' @local freeBlockAddress - the offset within the file system of the free block
' @local freeIndex - a counter of free blocks
' @local next_cycle_bits - the next lifecycle bits to use for the new block

  ifnot blockFreeCount := blocks_free()                                          'if no free block exists, abort with error
        return (errorCode := E_DRIVE_FULL)

  repeat                                                                        'randomly pick an B_FREE/B_HEAD/B_BODY (not an B_TEMP) block
        block_address := abs getrnd() // BLOCKS                                 '(random block selection results in +-5% wear leveling)
  until field[BlockState][block_address] <> B_TEMP

  ifnot field[BlockState][block_address]                                        'if the block is B_FREE, change its state to B_TEMP and exit
        field[BlockState][block_address] := B_TEMP
        return

  ' now we are using head or body so we have to move it!
  freeIndex := abs getrnd() // blockFreeCount                                   'randomly pick an B_FREE block to move the B_HEAD/B_BODY block to
  repeat freeBlockAddress from 0 to BLOCKS - 1
        ifnot field[BlockState][freeBlockAddress]                               'if the block is B_FREE
          ifnot freeIndex--
                quit

  flash_read_block(block_address, @tmpBlockBuffer, $000, $FFF)                  'read the B_HEAD/B_BODY block
  next_cycle_bits := next_active_cycle(tmpBlockBuffer.[7..5])                     'advance its lifecycle
  program_block(freeBlockAddress, @tmpBlockBuffer, next_cycle_bits)               'program the B_FREE block with the B_HEAD/B_BODY data
  activate_block(freeBlockAddress, next_cycle_bits)                               'activate the B_FREE block, now superior to the original block
  cancel_block(block_address)                                                   'cancel the original block to complete the move

  field[IDToBlock][tmpBlockBuffer.LONG.[19..8]] := freeBlockAddress             'update IDToBlock table
  field[BlockState][freeBlockAddress] := field[BlockState][block_address]\B_TEMP  'update blocks' states, new block is B_TEMP


PRI get_file_head_signature(p_filename) : foundSignature | block_address, BYTE header[FILENAME_SIZE]
' Look up file by name and return the block state bits of the files' head block (or 0 if file not found)
'
' @param p_filename - the zstring containing the filename to look up
' @returns foundSignature - the block state bits of the head block (or 0 if file not found)

' Local Variables:
' @local block_address - the block offset within the file system
' @local BYTE header[FILENAME_SIZE] - a temp buffer the block's filename is read into for compare

  repeat block_address from 0 to BLOCKS - 1                                      'scan head blocks for filename
        if field[BlockState][block_address] == B_HEAD                            'is this a head block?
          flash_read_block(block_address, @header, $000, $03F)                   'yes, read first 64 bytes of block
          if strcomp(p_filename, @header[$004])                                 'does the filename match?
                foundSignature := LONG[@header]                                 'yes, return first long of header (always non-zero or logically TRUE)
                quit                                                            ' end the repeat, we have our answer


pri count_file_bytes(block_address) : byte_count | signature

' Return the number of bytes written to file
'
' @param block_address - the offset within the file system of the first block of the file
' @returns byte_count - the number of bytes written to file

' Local Variables:
' @local signature - the block state bits of the block being counted

  repeat                                                                        'trace blocks to count file bytes
    flash_read_block(block_address, @signature, $000, $003)                             'read the first long of the head/body block
    case signature.[1..0]
      %00:                                                                      'head/last
        byte_count := signature.[31..20] - $040
        return
      %01:                                                                      'head/more
        byte_count := $FFC - $040
      %10:                                                                      'body/last
        byte_count += signature.[31..20] - $004
        return
      %11:                                                                      'body/more
        byte_count += $FFC - $004
    block_address := field[IDToBlock][signature.[31..20]]                        'get next block to count


pri delete_chain_at_block_id(block_id) | signature, block_address
' Delete blocks from file-chain starting at blockID
'   (this may be the entire file or last block of the file, etc.)
'
' @param blockID - block ID within a file chain from which to start deleting

' Local Variables:
' @local signature - block state bits of block being removed
' @local block_address - the block offset within the file system of block being removed

  repeat                                                                        'trace file and cancel IDs, block states, and blocks
        field[IDValid][block_id]~                                                'clear ID flag
        block_address := field[IDToBlock][block_id]                               'translate ID to block
        field[BlockState][block_address] := B_FREE                                'set block state to B_FREE
        cancel_block(block_address)                                               'cancel block
        flash_read_block(block_address, @signature, $000, $003)                         'read first long of block
        block_id := signature.[31..20]                                           'get ID of next block
  while signature.[0]                                                           'if not last block, loop


pri next_available_block_id() : block_id | possible_block_id

' Get a next available block ID
'
' @returns block_id - the next ID that is not in use (or E_DRIVE_FULL if no blockID's are available)

' Local Variables:
' @local possible_block_id - prospective blockID to check for availability

  block_id := E_DRIVE_FULL                              ' preset error
  repeat possible_block_id from 0 to BLOCKS - 1         ' pick the first free ID
        ifnot field[IDValid][possible_block_id]~~       ' set IDValid, was IDValid previously clear?
          block_id := possible_block_id                 ' if IDValid was clear, return new ID
          quit

  if block_id < 0                                       ' if error, set error code
    errorCode := block_id

pri blocks_free() : count | block_address

' Return the count of available blocks
'
' @returns count - the number of filesystem blocks that are not in use

' Local Variables:
' @local block_address - the block offset within the file system

  repeat block_address from 0 to BLOCKS - 1             ' count free blocks
        ifnot field[BlockState][block_address]
          count++


pri next_active_cycle(cycleIn) : cycleOut

' Calculate and return the next active lifecycle pattern in (3 -> 5 -> 6 -> 3 -> 5 -> 6 -> 3... pattern)
'
' @param cycleIn - current lifecycle pattern
' @returns cycleOut - next lifecycle pattern in sequence

  cycleOut := (cycleIn * %001_001) >> 1 & %111          'get next lifecycle pattern


pri buffer_pointer(handle) : p_buffer

' Return a pointer to the block buffer for this handle
'
' @param handle - the handle to the file
' @returns p_buffer -  the address of the 4KB buffer associated with this handle

  return @hBlockBuff + handle << BLOCK_SIZE_EXP


pri set_filename(handle, p_filename)

' Write filename into block buffer for this handle
'
' @param handle - the handle to the file
' @param p_filename - address of a zstring containing the filename

  bytefill(@hFilename + handle * FILENAME_SIZE, 0, FILENAME_SIZE)               ' empty filename buffer
  strcopy(@hFilename + handle * FILENAME_SIZE, p_filename, FILENAME_SIZE - 1)   ' copy new filename into buffer


pri block_crc(p_block_buffer) : crc
' Calculate and return the CRC for this pointed to block
'
' @param p_block_buffer - the address of the 4KB buffer for the file associated with this handle
' @returns crc - the calculated CRC for the block

  return getcrc(p_block_buffer, $AD0424F3 rev 31, BLOCK_SIZE - 4)  'compute CRC of a buffered block


con { flash operations }

pri flash_read_block(block_address, p_buffer, firstByte, lastByte)

' Return byte(s) read from physical block into memory at p_buffer
'
' @param block_address - the block offset within the file system
' @param p_buffer - memory location in which to place the data
' @param firstByte - address of first byte to read
' @param lastByte - address of last byte to read

  'debug("* rb(", uhex_word_(block_address), ", ", uhex_word_(firstByte), ", ", uhex_word_(lastByte),")")
  flash_command($03 | (FIRST_BLOCK + block_address) << 20 | firstByte << 8, 4)  'read 4KB block
  flash_receive(p_buffer, lastByte - firstByte + 1)                        'receive block data


pri program_block(block_address, p_buffer, cycle_bits) | pageIndex

' Write block in memory at buffAddress to physical block
'
' @param block_address - the block offset within the file system
' @param p_buffer - memory location from which to get the data
' @param cycle_bits - lifeCycle bit-pattern to place into block

' Local Variables:
' @local pageIndex - index [0-15] of 256-Byte page within 4KB block

  flash_command($06, 1)                                                         'enable write
  flash_command($20 | (FIRST_BLOCK + block_address) << 20, 4)                   'erase 4KB block

  BYTE[p_buffer].[7..5] := cycle_bits                                           'install lifecycle for CRC computation
  LONG[p_buffer + $FFC] := block_crc(p_buffer)                                   'compute and install CRC
  BYTE[p_buffer].[7..5]~~                                                       'block will be inactive until activated

  flash_wait()                                                                               'wait for erasure to complete (~45ms)

  repeat pageIndex from 0 to 15                                                              'program 16 pages within 4KB block
    flash_command($06, 1)                                                                'enable write
    flash_command($02 | (FIRST_BLOCK + block_address) << 20 | pageIndex << 16, 4)        'program
    flash_send(p_buffer + pageIndex << 8, 256)                                           'send 256 bytes
    flash_wait()                                                                                                             'wait for programming to complete (~400us)


pri activate_block(block_address, cycle_bits)

' Write new activation pattern into block
'
' @param block_address - the block offset within the file system
' @param cycle_bits - lifeCycle bit-pattern to place into block

  program_bit(block_address, cycle_bits << 5 | %00011111)                       'clear one cycle bit to activate block


pri cancel_block(block_address)

' Clear the block's cycle bits to cancel it
'
' @param block_address - the block offset within the file system

  'debug("* cancel block")
  program_bit(block_address, %00011111)                                         'clear all cycle bits to cancel block


pri program_bit(block_address, bit_pattern)

' Write new bit_pattern into 1st byte of block (this contains the life-cycle bits) this is our most atomic operation
'
' @param block_address - the block offset within the file system
' @param bit_pattern - the value to be placed in first byte of block

  flash_command($06, 1)                                                         'enable write
  flash_command($02 | (FIRST_BLOCK + block_address) << 20, 4)                   'program
  flash_send(@bit_pattern, 1)                                                   'send byte with bit pattern
  flash_wait()                                                                  'wait for programming to complete


pri flash_wait()| statusBits

' Wait for FLASH Chip to become ready
'

' Local Variables:
' @local statusBits - status register bits read from FLASH Chip

  repeat
    flash_command($05, 1)                                                    'read status register
    flash_receive(@statusBits, 1)
  while statusBits.[0]                                                          'loop until BUSY bit clear


pri flash_command(command, count)
' Send flash command to FLASH Chip via SPI
'
' @param command - the command for the chip to execute
' @param count - number of bytes to send

                org

                fltl    #SF_MISO                        '2!     DO input

                fltl    #SF_SCLK                        '2!     reset CK smart pin
                wrpin   #%01_00101_0,#SF_SCLK           '2              set CK for transition output, starts out low
                wxpin   #4,#SF_SCLK                     '2              set timebase to 4 clocks per transition

                drvh    #SF_CS                          '2!     CS high
                waitx   #14                             '2+14   CS deselect is 50ns at 350 MHz (50 / 2.777ns = 18)
                drvl    #SF_CS                          '2!     CS low

                movbyts command,#%%1230                 'reverse order of post-command address bytes for sending

                end

                flash_send(@command, count)                            'send command


pri flash_send(p_buffer, count) | tx_byte

' Write bytes to the FLASH Chip via SPI
'
' @param p_buffer - memory location from which to get the data
' @param byteCount - number of bytes to send

' Local Variables:
' @local tx_byte - the byte value being sent over SPI

                org

                rdfast  #0,p_buffer                     'start fast read

.byte           rfbyte  tx_byte                         '2              read byte

                rep     @.r,#1                          '2              protect from interrupts
                fltl    #SF_SCLK                        '2!     reset smart pin CK
                drvl    #SF_SCLK                        '2!     start smart pin CK, starts base period
                shl     tx_byte,#24 + 1      wc         '2              get D7
                drvc    #SF_MOSI                        '2!     output D7
                wypin   #16,#SF_SCLK                    '2*     begin 16 clock transitions
                rep     @.r,#7                          '2              repeat to output D6..D0
                shl     tx_byte,#1           wc         '2              get data bit
                drvc    #SF_MOSI                        '2!     output data bit
                waitx   #2                              '2+2    delay makes 8 clocks/bit
.r
                djnz    count,#.byte                    '4|2    loop if another byte to send

                drvl    #SF_MOSI                        '2!     DI low

                end

pri flash_receive(p_buffer, count) | rx_byte

' Read bytes from the FLASH Chip via SPI
'
' @param p_buffer - memory location into which to put the data
' @param count - number of bytes to receive

' Local Variables:
' @local rx_byte - gather bits received into this byte

                org

                wrfast  #0,p_buffer                     'start fast write

.byte   rep     @.r,#1                                  '2              protect from interrupts
                fltl    #SF_SCLK                        '2!     reset smart pin CK
                drvl    #SF_SCLK                        '2!     start smart pin CK, starts base period
                wypin   #16,#SF_SCLK                    '2*     begin 16 clock transitions
                waitx   #3                              '2+3    align TESTP's to before clock fall (DC..350MHz+)
                rep     @.r,#8                          '2              repeat to input D7..D0
                waitx   #2                              '2+2    delay makes 8 clocks/bit
                testp   #SF_MISO                 wc     '2              input data bit
                rcl     rx_byte,#1                      '2              save data bit
.r
                wfbyte  rx_byte                         '2              write byte
                djnz    count,#.byte                    '4|2    loop if another byte to receive

                drvh    #SF_CS                          '2!     CS high, terminates command
                wypin   #1,#SF_SCLK                     '2*     CK high, leave SD card CS high

                end

con { methods supporting regression testing }


con { technical details }

{
head/last block
------------------------------------------------------------------------------------------------
000..003        long {EndPtr[11:0], ThisID[11:0], %vvv11100}    'vvv = lifecycle, 00 = head/last
004..03F        byte filename[60]                               'filename
040..FFB        byte data[4028]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB


head/more block
------------------------------------------------------------------------------------------------
000..003        long {NextID[11:0], ThisID[11:0], %vvv11101}    'vvv = lifecycle, 01 = head/more
004..03F        byte filename[60]                               'filename
040..FFB        byte data[4028]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB


body/last block
------------------------------------------------------------------------------------------------
000..003        long {EndPtr[11:0], ThisID[11:0], %vvv11110}    'vvv = lifecycle, 10 = body/last
004..FFB        byte data[4088]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB


body/more block
------------------------------------------------------------------------------------------------
000..003        long {NextID[11:0], ThisID[11:0], %vvv11111}    'vvv = lifecycle, 11 = body/more
004..FFB        byte data[4088]                                 'data
FFC..FFF        long crc32                                      'crc32 of 000..FFB



vvv lifecycle rules
- single-zero ring counter state sequence is 011..101..110..repeat
- the block with the greater state is the valid block between two blocks with identical IDs
- this allows for make-before-break block replacement that can be recovered after unexpected power loss
-------------------------------------------------------------------------------------------------------
111                     inactive        no zeroes
011/101/110             active          one zero
001/010/100/000         canceled        two or three zeroes

011 > 110               new > old
101 > 011               new > old
110 > 101               new > old

}


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
